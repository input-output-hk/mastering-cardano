:figure-numbered:

== Decentralized Applications

Decentralized Applications (DApps) aim to empower end-users through ensuring that the encoded digital processes and data stored are not centrally controlled (as discussed in previous chapters). So far in the previous chapters, we have covered some of the components that support decentralised applications including the blockchain network, smart contracts and wallets. In this chapter we focus on those technological components that support user interaction and bridge the gap between foundational blockchain and smart contract infrastructure and users.

=== Traditional Web Application Architecture

To be able to appreciate the novelty that decentralized applications bring, we first provide an overview of traditional web applications. <<fig-tradweb>> depicts an abstract overview of traditional web application interaction.

[[fig-tradweb]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Traditional web architecture. 
[#fig-tradweb]
image::TraditionalWebArchitecture.png[]

When browsing web sites, at an abstract level, the process can be broken down into three steps:

. Your request for a web page (depicted in Step 1 in <<fig-tradweb>>). When you use a web browser on your computer (or mobile phone) and go to a website, really what is happening is your browser makes a 'request' to the web server that hosts the web page, asking it for the content of the specific page.

. The web server which is centrally owned and controlled by some entity, receives the request and puts together its 'response' — more specifically the web page content to return. This 'response' is sent back to your web browser, operating on your device (depicted in Step 2 of <<fig-tradweb>>).

. Once a web page has been loaded in your web browser, subsequent data and interaction can take place between the web page itself and the web server (depicted in Step 3 of <<fig-tradweb>>). This could be to retrieve, for example, the latest news articles on a news website. Web applications are typically composed of more than one web page. Usage of one web page may lead to directing a user to another web page, resulting in a request for a new web page (which would initiate the process for requesting a new web page depicted in step 1).

Some web pages have static content, i.e. their content is always the same (and perhaps hard-coded). For example, consider a web page that always displays the text 'Hello World!'. While other pages may be more dynamic, which allow for the web server to decide on the specific content to respond with. For example, consider a web page that displays the current date and time — the content dynamically changes according to the date and time. Really, most web pages nowadays consist of some degree of static content and some amount of dynamic content. Though it is also not unheard of to have completely static web pages — for example, many company landing pages often have a static view of what they want their clients to see as the first page of their web site.

The actual 'response' that the web server sends back to your web browser most typically consists of two parts: (a) HTML code; and (b) JavaScript code (and some other media assets and styling sheets). The HTML code describes what the web page should look like.footnote:[ The content likely also makes use of CSS code, but this detail can be ignored unless you want to dig deeper into web page design.] Your browser uses the HTML code it receives as a means of 'drawing' the visual aspect to the web page. Consider a web page that can be used as a calculator. The HTML would describe and provide the instructions for your browser to visualise all aspects of the calculator including the different buttons on the calculator, and the display. Yet with such a visual representation (that HTML provides) only, pressing the buttons would not have any effect. A second component is needed to provide instructions to the browser that describes the functionality of the web page — i.e. for the calculator use-case, functionality for displaying a '1' when the '1' button is pressed, and for adding two numbers together and displaying their result when required. This functionality is encoded within the JavaScript component of a web page.

The HTML and JavaScript code described above is sent to your browser on your computer, and is executed in your browser (on your computer). Really this means that you could manipulate the HTML and JavaScript code, which means you can change what a web page you interact with looks like, and also its functionality.footnote:[ Most web browsers allow users to use 'Developer Tools' that are built into the web browsers themselves, that allow you to manipulate web pages once they are in your browser.] This code received from the web browser, which is executed in your browser, is what we call “client-side” — i.e. code that executes in the client’sfootnote:[ It may help to consider that when using a web site you are the client, and this is why it is referred to as client-side code, since the code is executing on your laptop. Really though the terminology comes from ;'client-server' architectures (which has resemblances to the analogy provided).] browser. Since the code can be manipulated by yourself (the client), web site operators cannot just trust any interactions or code that take place on your device, and it is for this reason that some functionality is not encoded into the 'client-side' HTML and JavaScript but encoded into 'server-side' code which executes on the web server owned by the particular entity the original web page was received from. For the code that is executed on the web server, the website operator has full control over that logic and as users of that website we must trust the operator. To exemplify this further consider an online shopping platform. Whilst end-users are displayed with products and prices on screen and are able to select which products they would like to purchase, the site operator cannot trust end-users to calculate the total cost due after selecting products. Since as described above, end-users would be able to manipulate the total calculation taking place within their browser. Therefore, the web site is built in such a way that code concerned with total calculation is ultimately done on the web server ('server-side'). Once a total is calculated and a client is ready to pay, clients' are typically sent to a payment page where they enter their bank card details. Again, processing of card transactions is typically done 'server-side' for the same reasons. Yet, in this scenario, clients that are making purchases need to trust the operator and the code that is handling the total calculation (and executing on the web server) to not overcharge after entering their card details. Traditional web applications and their architectures heavily support keeping site operators in a position of power, i.e. where platform providers are in full control and end-users are reliant on the platforms, and must trust that the platforms do their job properly — and when they do not must try to seek recourse in some other manner if possible (e.g. through contacting the operator, or seeking legal recourse if necessary and possible).

=== Decentralized Application Architecture

The advent of blockchain platforms and smart contracts built on them, provided a new place where code could be executed, i.e. in smart contracts on a blockchain. Executing code in smart contracts, unlike code executed in client browsers or server-side, provides guarantees that the code cannot be manipulated or altered — not even by the programmer that created the code! Furthermore the code executed in smart contracts is publicly available, and therefore users can look into the smart contract logic prior to interacting with them. Through the availability of smart contract code, a new architecture was possible that enabled for Decentralized Applications (DApps). DApps build on traditional web applications, in that they also make use of client-side and server-side code, yet smart contracts can be utilized to provide guarantees to all stakeholders. Consider the example discussed in the section above, regarding the calculation of the total due for an online shopping platform. If the calculation of the total is done on the client-side, then users could manipulate the amount due, therefore service providers calculate totals on the server-side. While this makes complete sense, server operators could manipulate the logic to calculate a higher total due — though end-users are likely to notice this before payment. Yet in a similar vein server operators could display one amount, and process a transaction for a different amount. This is really the status-quo of traditional web architecture. Using a DApp, instead such logic could be delegated into a smart contract that would provide guarantees to both the service provider as well as to end-users, since the code is transparent and publicly available for everyone to see. Furthermore, the code is immutable, it cannot be changed — not even by the developer that wrote it. We will now provide an overview of typical DApp architecture, followed by a walkthrough on how to use a DApp, and then close off with code snippets demonstrating how a DApp can be built. <<fig-dapp>> depicts an abstract overview of typical DApp interaction.

[[fig-dapp]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Decentralized Application (DApp) architecture. 
[#fig-dapp]
image::dAppArchitecture.png[]

Interaction with DApps, at an abstract level, can be broken down into three steps exactly like traditional web applications. Yet following the initial web page request (depicted in step 1) and web page response (depicted in step 2), future interaction (depicted in interactions marked as 3) between the client browser is not restricted only to communication with the centralised platform (or other centralised services), but can interact with decentralized platforms such as Cardano’s blockchain and smart contracts running on top of it. Consider the same example discussed above. Initially, an end-user can request the web page that displays different products (and in turn their browser receiving the web page including HTML and JavaScript). Thereafter, when the user wants to select a product to purchase which will require for the total to be calculated, this interaction could take place directly from the client’s web browser with a smart contract deployed on the blockchain. Thereafter, payment could be made again through direct interaction between the user’s web browser and smart contracts. Fulfilment of the order could even take place by underlying smart contracts — if the service is one that can be fulfilled digitally through smart contracts, e.g. if a user was buying a particular token in exchange for another cryptocurrency.

While the server is responsible for delivery of the initial HTML and JavaScript sent to the client’s web browser, and even most of the logic coordinating future interaction, any required guarantees can be provided based on logic encoded in smart contracts. Really the front-end HTML code, and JavaScript code that coordinates the interaction with underlying smart contracts can be seen as the gateway facilitating interaction with the actual logic encoded in the smart contracts. If it was desirable to do away with the centralised request/response delivering the initial HTML/JavaScript code, then other distributed platforms could be used to replace the centralised components such as IPFS (which will discuss in more depth later in this chapter).

To further exemplify how guarantees can be provided through smart contracts (in spite of initial HTML/JavaScript code being delivered by centralised infrastructure), we’ll now introduce how to use a DApp, and then later how to build a DApp.

==== Prerequisites

We now list a number of prerequisites required to follow the upcoming sections on how to use a DApp and how to build a DApp.

_Installing a Wallet_

Prior to building a DApp, we need to ensure that we have a wallet
installed in a browser that will allow for the client web-page to
communicate with the blockchain directly. We’ll use the Lace wallet in the rest of this chapter, but you may use any other wallet that supports the Cardano blockchain.

#Should we add instructions here, or as a tutorial on installing Lace been handled elsewhere? Depending on this we may want to add a tutorial to installing the wallet, and backing up pass phrase etc here or in another chapter.#

_Configuring Wallet to Connect To Testnet_

We’ll configure the Wallet to connect to the Cardano test network so that we can test without having to spend real cryptocurrency. In Lace, you can do this by:

. Clicking on the currently selected Wallet (as depicted in <<fig-wallet-settings>>)
. Then selecting 'Settings'
. Then click on 'Network' to 'Switch from mainnet to testnet'
. Click on 'Preprod' which is meant for pre-production testing

[[fig-wallet-settings]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Finding Wallet Settings. 
[#fig-wallet-settings]
image::wallet-to-settings.png[pdfwidth=50%]

You can check whether you are connected to a test network in Lace to see if the test network is listed at the top of the wallet screen as depicted in <<fig-wallet-preprod>>.

[[fig-wallet-preprod]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Preprod indication. 
[#fig-wallet-preprod]
image::wallet-preprod.png[pdfwidth=50%]

_Receiving Test Cryptocurrency_

In order to interact with the blockchain, users must spend some cryptocurrency. Since we want to avoid spending real cryptocurrency whilst testing we’ve switched to the Preprod test network (as discussed above), and need to obtain some test cryptocurrency. To do so we’ll request some test Ada (Cardano’s cryptocurrency) from a faucet.footnote:[Faucets are the term typically used for services that send test cryptocurrency.] One such faucet can be found here: +
https://docs.cardano.org/cardano-testnets/tools/faucet[_https://docs.cardano.org/cardano-testnets/tools/faucet_]

To retrieve test Ada, configure the fields as follows:

* Environment: Preprod Testnet
* Action: Receive test ADA

Then, copy your wallet address. In Lace this can be done by clicking on 'Copy address' located at the bottom of the main screen of the wallet as depicted in <<fig-wallet-copy-address>>. Then pase the address in the address field. Ensure to click on 'I’m not a robot' and press 'Request Funds'. A success message should appear shortly, and the test Ada should appear in your wallet within a few minutes.

[[fig-wallet-copy-address]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Copy wallet address. 
[#fig-wallet-copy-address]
image::wallet-copy-address.png[pdfwidth=45%]

The filled in details are depicted in <<fig-faucet>>.

Note: The public address of the wallet is hidden, since all transactions are publicly available for anyone to see. You should keep this in mind when sharing your wallet addresses.



[[fig-faucet]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Requesting test Ada from a faucet. 
[#fig-faucet]
image::faucet.png[]


==== Using a DApp

Now that we have some test cryptocurrency in our wallet, let’s try to use a DApp. We’ll use a decentralized exchange (DEX) to swap some of our testnet Ada for some other token. More specifically we’ll use a preprod test network version of the Minswap DEX as follows:

. Go to https://testnet-preprod.minswap.org/[_https://testnet-preprod.minswap.org/_]
. Connect your wallet by clicking 'Connect Wallet', then choosing 'Lace' (or a different wallet if you are not using Lace).
. The wallet will popup asking you to confirm that you want to connect your wallet to the minswap.org site. By doing so we’ll be able to use our wallet with the minswap.org site and interact directly with the blockchain. So, we’ll press “Authorize”. You can then choose whether you want to always allow the site to connect to your wallet, or whether it can only connect this time. Once your wallet is connected, go back to the Minswap main screen by pressing the 'X' as depicted in <<fig-minswap-close>>.

[[fig-minswap-close]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Closing Minswap's side-bar. 
[#fig-minswap-close]
image::minswap-close.png[]

[start=4]
. Click on the 'Trade' link in the top left (depicted in <<fig-minswap-trade>>) so that we’re sent to the 'swap' functionality.

[[fig-minswap-trade]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Click the 'Trade' link. 
[#fig-minswap-trade]
image::minswap-trade.png[]

[start=5]
. The DApp is likely automatically loaded with details to swap from Ada (which you should have in your wallet) to Min (Minswap’s own token). The testnet version of Minswap only supports swapping between Ada and Min. When you use the mainnet’s version though you can choose to swap to other tokens as well. Enter an amount of Ada that you will swap in from your wallet, and the amount of Min that will be swapped out will be displayed (<<fig-minswap-review-trade>> depicts a swap of 123 test Ada to the relevant amount of test Min at the time of writing).

[[fig-minswap-review-trade]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Review trade details. 
[#fig-minswap-review-trade]
image::minswap-review-trade.png[pdfwidth=45%]

[start=6]
. You can then confirm the swap by clicking 'Trade now'. This should initiate your wallet to pop-up prompting you to choose whether you agree to the transaction as depicted in <<fig-lace-confirm>>.

[[fig-lace-confirm]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Confirm trade in Lace. 
[#fig-lace-confirm]
image::lace-confirm.png[pdfwidth=45%]

[start=7]
. Once you confirm the transaction you may be required to enter the password you set for the wallet.
. You should then see that the transaction was signed by your wallet as depicted in <<fig-lace-done>>.

[[fig-lace-done]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Transaction signed and submitted. 
[#fig-lace-done]
image::lace-done.png[pdfwidth=45%]

[start=9]
. Once the transaction is confirmed on the blockchain, and the Minswap interface updates, you should see your balance of Min has increased (and Ada decreased) as depicted in <<fig-minswap-balances-updated>>.

[[fig-minswap-balances-updated]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Balances updated in Minswap. 
[#fig-minswap-balances-updated]
image::minswap-balances-updated.png[pdfwidth=45%]

And that’s it! You have used your first DApp (if you haven’t already done so, of course). To further build on what was discussed in the previous section, it is important to highlight the different interactions that took place from your browser and what it was communicating with. First we requested the DApp by visiting the web site (i.e. https://testnet-preprod.minswap.org/[_https://testnet-preprod.minswap.org/_]), through which your browser requested the web page (i.e. HTML and JavaScript and other images and media-assets) from the centralised Minswap server. We then instructed the DApp to connect to our wallet, and confirmed in the wallet that we agree to it connecting with the DApp. Our wallet runs on our computers and is the interface that we can trust to verify interactions with the underlying blockchain. The DApp fetches swap prices to display on screen by communicating with the centralised server directly — and though this may raise eyebrows in that the centralised server can manipulate prices, the guarantees with respect to actual swap prices used are provided through the final smart contract call that is used to initiate the swap (discussed next). When the user agrees to the swap in the wallet popup, it is at this point that the wallet directly communicates with the smart contract (deployed on the blockchain), within which the swap price is guaranteed to be the current price as defined by the smart contract logic. So, the guarantee provided to the user is that the swap will be performed at the current price (defined with decentralized smart contract code) — irrespective of whether the centralized server reports a different price. This potential price discrepancy is why such DEXs allow for users to specify a 'slippage' amount and/or minimum/maximum prices for swaps - so that users can express what minimum/maximum swap price they agree to in the case that there is a discrepancy between the prices reported on screen (by the centralized server) and the actual current price that the swap would use. This discrepancy emerges not only from the fact that servers may report different prices, but also given that time passes between user acceptance and the time the actual swap would take place — and within this time it may be the case that other swaps were executed for the specific price-pair that would affect the swap price.

Having explored using a DApp, let’s now delve into aspects of internal workings of a DApp by re-creating parts of a DApp.

==== Creating a DApp

We’ll now create the following aspects of a DApp:

* Server-side code: A NodeJS server that will send a page's HTML/JavaScript to the end-user.
* Client-side code: This is the code that will be sent from the server (discussed above), but will execute in the client-side browser. This code will connect to the wallet and communicate with a deployed smart contract.

We will not create smart contract code in this section (since that is handled in #Chapter XXX#). Indeed, DApps can be created that communicate with existing deployed smart contracts that may not necessarily be written by the same developers/teams — just as we demonstrate now below.

_Creating a Server (with NodeJS)_

We now discuss creating a NodeJS server that will be used to serve
content to requesting users. You can use any other framework to create server-side code if you wish (such as Python, PHP, .NET, Java, or any other framework you may prefer). We’ll use NodeJS' express package. Follow these steps to create the server:

. First, you need to ensure that NodeJS is installed, and that you can run 'node' and 'npm' from the command line.
. Create a new directory where your server code will be saved. We’ll refer to this as the 'server' directory.
. In the server directory, run: *npm init* +
and for ease of this tutorial, you can just keep all default settings. +
 +
 This will create a package.json file that defines the settings of the NodeJS project. Verify that the 'main' setting is set to 'index.js'. This setting defines the main entry point file for code in the NodeJS project.
. Create the 'index.js' file in the server directory.
. The template code is provided below.
. We are making use of the 'express' package, and therefore need to install it. You can do so by running the following command: *npm install express*
. Create an HTML file that the server will send to the client. We’ll call this index.html. For now, just put the text 'Hello World!' in index.html and save the file.
. Thereafter you can run the server using the following command: *node index.js*
. Open a browser, and go to the url: localhost:3000 +
 You should see a page similar to <<node-hello-world>>

[source,javascript]
----
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
});

app.listen(port, () => {
    console.log(`Server is running at http://localhost:${port}`);
});
----

[[node-hello-world]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.A first web server!. 
[#node-hello-world]
image::node-hello-world.png[pdfwidth=45%]


_Creating the Client-Side Code_

Now that we have a server able to send HTML/JavaScript to end-users, let’s write the client-side code to connect to a user’s wallet and interact with the underlying smart contracts. We’ll only provide the bare minimal code that is needed. Indeed, you may want to look into implementing a full HTML page (including html, head and body tags), but we’ll only provide the necessities for the sake of simplicity.

First, we’ll create an HTML button and JavaScript that will connect the client-side code to the wallet. The code to provide a connect button is provided below.

[source,javascript]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>

<script>
  async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
      try {
        await window.cardano.lace.enable();
        const wallet = await window.cardano.lace.getUsedAddresses();
        console.log("Connected to Lace Wallet:", walletAddress);
      } catch (error) {
        console.error("Error connecting to Lace Wallet:", error);
      }
    } else {
      console.error("Lace Wallet not found");
    }
  }
</script>
----

After reloading the webpage (i.e. refreshing the url, localhost:3000), you should see the button on screen. If the code is correct, once you press the button, the Lace wallet should pop-up requesting the user to allow for the underlying client-side code to be able to connect to the Lace wallet as depicted in <<dapp-connect-to-lace>>. Upon confirming that the DApp can connect to the wallet, we will not see any changes in the page, since we did not provide any code to do so.

[[dapp-connect-to-lace]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Connect the DApp to Lace. 
[#dapp-connect-to-lace]
image::dapp-connect-to-lace.png[]

Now that we have connected the client-side code to the wallet, let’s write some code that will interact with an underlying smart contract.



#Continue with a note on on-chain/off-chain SCs parts?#

=== Onchain vs Off Chain Code
In the Cardano and Plutus context, on-chain and off-chain codes refer to two different aspects of the same smart contract system.

On-chain code refers to the part of a smart contract that runs on the blockchain itself. This code is written in Plutus Core, and it essentially implements the custom logic that controls how the contract's assets can be spent. Once a smart contract is deployed, its on-chain code becomes unchangeable—it is, in fact, a part of the blockchain.
