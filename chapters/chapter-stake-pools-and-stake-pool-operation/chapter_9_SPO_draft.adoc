
= Stake Pools and Stake Pool Operation (Draft)



== Introduction

The strength of the Cardano network lies in its widespread and diverse distribution of stake pools, stake pool operators, delegators, builders, and community members at large. The ethos of this well-distributed network and broader ecosystem has found its way into the creation of this chapter.

While reading this chapter, you may notice that some of the sections were written in tones distinct from one another. This is not by accident. Since the Cardano network is maintained by excellent people from every corner of the Earth, it only made sense for this chapter to be written by some of the very best community members the Cardano ecosystem has to offer.

The intent of the _Stake Pools and Stake Pool Operations_ chapter is to deliver a thorough technical and conceptual overview of stake pool operation. For those new to Cardano, this chapter will give insight into what it takes to run and maintain a global, distributed network like Cardano. 

It is recommended that prospective stake pool operators read through this chapter, understand the concepts, then participate and practice operations on one or more of the publicly available testnets until sufficient expertise is met before spinning up on mainnet. Seasoned pool operators will hopefully be able to use this guide as a refresher, fill potential gaps in knowledge, and best of all contribute where needed. 

Some tools and guides are listed at the end of this chapter to assist with both learning how to operate stake pools and maintaining tight operations for long-term mainnet pools.

== Quick Glossary


Technical subjects often carry the baggage of being laden with a significant amount of technical terminology. The topic of stake pools on the Cardano blockchain is no different, and the reader may find it useful to read through and refer to the following list of relevant terms and definitions. 

**ADA:** The name of the main currency on the Cardano blockchain. 

**Block:** A list of ordered records containing the previous block hash, timestamp, transaction data, and other stored information. 

**cardano-cli:** Command Line Interface (CLI) utility tool for key generation and general pool and node functions.

**cardano-node:** Collection of the https://github.com/input-output-hk/cardano-ledger[ledger], https://github.com/input-output-hk/ouroboros-network/tree/master/ouroboros-consensus[consensus], https://github.com/input-output-hk/ouroboros-network/tree/master/ouroboros-network[networking], and https://github.com/input-output-hk/cardano-shell[node shell] software that may be compiled and ran as a single binary. 

**Delegator:** ADA wallet owner that has assigned stake to a stake pool. 

**KES:** Stands for **K**ey **E**volving **S**ignature, meaning that KES keys are only valid for a certain period of time, after which new keys must be generated for block producers to maintain the ability to produce blocks. 

**nonce:** Source of randomness on the Cardano blockchain.

**Operator:** The individual that runs and maintains the stakepool.

**Owner:** The individual in control of the Pledge associated with the stake pool. 

**Pledge:** The Owner's declared stake to the stake pool. The actual delegated amount must meet or exceed the declared stake amount for the pool to remain valid. 
 
**VRF:** **V**erifiable **R**andom **F**unction is a cryptographically verified random number generator.

(Addresses and keys will be covered in the following section)

== What is a Stake Pool?

A Cardano stake pool is a server-based infrastructure that helps maintain the Cardano blockchain by validating transactions and adding blocks. The infrastructure of a single stake pool could be one single node but is typically a collection of nodes connected to the greater Cardano network (a distributed assortment of interconnected stake pools and full nodes). A stake pool typically consists of a block producing node and multiple separate relays. 

To become an active block producer, a node requires the following cryptographic files:

* the __verified random function signing key__ (vrf.skey)
* the __operational certificate__ (op.cert)
* the __key evolving signature signing key__ (kes.skey)

When a full node is not started with these files, it is referred to as a passive node or when connected to a block producer a __relay__. A relay sits between the open Cardano network and block producing node(s) of a stake pool. Its purpose is to allow a block producing node to interact with the network securely as the block producing node should only be connected and known to the specific relays the stake pool operator (SPO) controls. This separation of concerns reduces the attack surface of a stake pool and allows the block producing node to focus on minting blocks and propagating these to a small set of well-known relays, which will in turn propagate the blocks to the wider network. Relays are typically publicly known as they are registered with the pool, so other relays can find them in a peer-to-peer manner. Relays may also be run privately with static topologies listing other relays.

Cardano uses a proof of stake (PoS) consensus mechanism. Network participants holding ada (Cardano’s native token) can delegate their stake to a stake pool, effectively pooling their resources and increasing the pool’s chances of being selected to validate a block and earn rewards.

Stake pools are run by SPOs, who are responsible for maintaining the pool’s infrastructure and ensuring that the pool operates reliably. The rewards earned by the pool are then distributed among the stakeholders who have delegated their ada to the pool, proportional to their stake. 

In this way, Cardano’s consensus mechanism incentivizes a distributed network of participants to maintain the security and integrity of the network, rather than relying on a single entity to validate transactions.

==== Stake Pool Roles 

In the Cardano blockchain network, several roles are essential to stake pool operation:

* Stake pool operator (SPO): the individual or organization running the stake pool infrastructure and is responsible for its maintenance and uptime. This role determines and sets the pool’s operational parameters, such as the fee structure. Rewards are paid directly by the protocol. While the SPO can influence the amount of rewards paid by changing fee parameters, the SPO does not influence the rewards distribution itself.
* Owner: The owner is the role contributing the pledge to the staking pool. The owner can be the SPO or a separate entity. Pledge is a specific type of delegation explained in a later chapter.
* Delegator: A delegator is a participant in the network who holds ada and delegates their stake to a stake pool. By doing so, they  participate in the validation of transactions and earn rewards.

These roles work together to ensure the reliable and secure operation of the Cardano network and its consensus mechanism.

==== Keys 

Cardano cryptographic keys are made up of ed25519 key pairs, which include a public verification key file and a secret (private) key file. The public key filename is commonly formatted as ``keyname.vkey``, whereas the private key filename is typically formatted as ``keyname.skey``. The private key file, which is used to sign transactions, is extremely sensitive and should be adequately safeguarded. Under all circumstances, this entails limiting third-party access to your private keys. The most effective technique to prevent private key exposure is to guarantee that the necessary private key is never held for any length of time on any internet-connected machine (hot node). Please note the key pair filenames are examples and may be named differently.

===== Wallet Keys

``root.skey`` -  is the most sensitive private secret key of any wallet. An attacker can use this key to derive the Cardano wallet payment.skey and stake.skey . A hardware wallet’s 12 or 24 word seed phrase can be converted to a root.skey in an emergency (hardware wallet malfunction, for example), the payment and stake keys can be recovered by using the CLI and root.skey. A root.skey can thus not only be used to generate private keys for Cardano, but also for other blockchains such as Bitcoin. 

``payment.skey`` - is a highly sensitive Cardano payment address secret (private) signing key file. The private signing key file gives you access to tokens in your payment address and should be kept safe at all times.

``payment.vkey`` - is the public verification key file for the payment address. It is not sensitive and can be shared publicly.

``stake.skey`` - is a sensitive Cardano stake address secret (private) signing key file. This private signing key file gives you access to any rewards held in the stake address, as well as the ability to delegate the wallet to a pool. 

``stake.vkey`` - stake address public verification key file (not sensitive; may be shared publicly).

===== VRF Hot Keys 

The verified random function (VRF) keys control participation in the slot leader selection process.

``vrf.skey`` -  secret (private) signing key file for a Cardano stake pool’s VRF key. This key is required to start a stake pool’s block producing node. It is sensitive but must be placed on a hot node to start a stake pool.

``vrf.vkey`` - public verification key file for a Cardano stake pool’s vrf.skey. It is not sensitive and is not required to start a stake pool’s block producing node.

===== KES Hot Keys 

The key evolving signature keys are  operational node keys that authenticate the rightful operator of a pool.

``kes.skey`` -  secret (private) signature key file for the stake pool’s KES key (needed to start the stake pool’s block producing node; sensitive, but must be placed on a hot node to start a stake pool and be rotated regularly). KES keys are needed to establish a stake pool’s operating certificate, which expires 90 days after the certificate’s defined KES period has passed. As a result, fresh KES keys must be generated along with a new certificate every 90 days or sooner for a Cardano stake pool to continue minting blocks.

``kes.vkey`` - public verification key file for a Cardano stake pool’s corresponding kes.skey (not sensitive and  not required to start a block producer).

===== Stake Pool Keys and Supporting Files

``cold.skey`` - secret (private) offline signing key file for a Cardano stake pool (extremely sensitive). The cold.skey is required to:

* register a stake pool
* update stake pool registration parameters
* rotate stake pool KES keys
* retire a stake pool

``cold.vkey`` - public verification key file for a stake pool’s cold.skey private signing key file. It is not sensitive and can be shared publicly.

``cold.counter`` - counter file that tracks the number of times an operational certificate has been generated for the relevant stake pool.

*_Note:_*  Always rotate KES keys using the latest cold.counter and increment by exactly 1.

``op.cert`` -  The operational certificate represents the link between the operator’s cold.skey and their operational key kes.skey. The certificate’s job is to check whether or not an operational key is valid, to prevent malicious interference. The certificate identifies the current operational key and is signed by the offline cold.skey (sensitive and required to start a stake pool’s block producing node; must be placed on a hot node in order to start a stake pool).

==== Addresses 

Current Cardano wallet addresses are encoded in bech32 and can have two parts: a payment address and a staking address. A payment address (together with its associated key pairs) stores, receives, and sends money. A stake address (and related keys) is used to store and withdraw rewards, as well as define the stake pool owner and rewards accounts, and the wallet’s target stake pool delegation.

An Enterprise address is a specific Cardano wallet address with no usable staking part. Enterprise addresses could be used for example by exchanges that wish to comply with regulation, or whenever staking is not allowed for any other reason.

``payment.addr `` -  payment address usually generated with the help of both a payment.vkey and a stake.vkey, thus the resulting payment address is associated with both keys. Usually the payment.vkey and stake.vkey are derived from the same cryptographic entropy or root.skey referring to the same original secret or seed phrase. The first payment address of any wallet is the  base address. Cardano supports HD wallets, so any number of payment addresses can be derived from the same secret.

``stake.addr`` - stake address for a Cardano wallet generated with the stake.vkey file used to control protocol participation, create a stake pool, and delegate and receive rewards. This address cannot receive payments but will receive the rewards from participating in the protocol. From one original secret, only one stake address can be derived, thus all payment.addr with the same underlying secret share the same stake address part.

It is also possible to combine payment.vkey and stake.vkey from two different original secrets, this creates a so-called ``mangled`` or https://www.youtube.com/watch?v=KULzovfWn-M[``Franken Address``]. If tokens are sent to such an address one wallet can spend the tokens the other wallet can participate in the protocol and earn rewards with the same tokens. 

==== Pool Saturation

The protocol parameter ``k`` defines the saturation point for stake pool rewards. This saturation point is defined as ``total supply of Cardano divided by k``. At the time of this writing, with k at 500, the saturation point is at about 70m ada. A stake pool with stake above the saturation point will on average be allotted more slots and should mint more blocks. However, rewards for the pool are capped off at the saturation point. Resulting in the distribution of the same reward total to a larger amount of participating stake and delegator shares, diluting rewards for all pool participants. This incentivizes participants in a pool to be aware of pool saturation when delegating.

This concept of saturation is meant to encourage stake distribution across stake pools instead of a majority of stake pooling in a single pool.

Reaching saturation is a positive sign for a pool, as it indicates that the pool has become popular and is receiving a large amount of stake. However, it also means that delegators may have to look for alternative pools if they wish to delegate additional stake. The SPO of the saturated pool can also opt to increase pool minting fees to manage the stake saturation level.

It is also possible for the SPO to open more pools and attempt to use the popularity of the first pool to try to fill more pools. This topic of pool-splitting or multi-pools is highly contentious in the Cardano community. From a decentralization perspective, a SPO should not engage in pool splitting unless they can saturate the existing pool completely with their own stake, turning one pool effectively into a private pool before opening the next public pool. Distributed pool production both helps increase the Minimum Attack Vector (MAV) and protect against Sybil attacks (where a malicious actor creates multiple entities or accounts in an attempt to control block production. 

==== Pledge vs Stake

Pledge is a specific type of delegation the SPO announces to the public in the pool registration by setting the pledge height in number of ada tokens and also setting which owner wallets contribute to the pledge by delegation at all times. The SPO herby gives a pledge promise to the pool, if this pledge promise is broken and this broken promise is snapshotted at an epoch transition, no rewards will be paid until the pool registration is adapted to reduce the pledge and this becomes effective and valid again or the pledge is returned to the already specified owner addresses meeting the unmodified pledge promise.

To prevent Sybil attacks, Cardano has an incentive model intended to encourage stake pool owners to associate as much pledge as possible with the pool in order to make the stake pool more financially attractive to potential delegators. The higher the pledge, the higher staking rewards for all pool participants will be. Rewards rise linearly with pledge; maximum rewards are achieved when the pool is fully saturated with pledge. A pool saturated with pledge will earn about 30% more rewards than a pool with zero pledge, these pools are also called private stake pools, as they do not incentivize additional delegation by ADA holders as the pool is already saturated with pledge and will become oversaturated, diminishing rewards.

As there is no minimum pledge requirement, zero pledge is a valid amount for a stake pool. Pledge shows skin in the game from the owner which can potentially gain trust from delegators. However, declaring pledge is not without risk as pledge is declared publicly. The SPO could become a target for criminal activity attempting to steal the pledge. Combined with regulation requirements with mandatory doxing of SPOs in some jurisdictions this could pose a potential security risk. 

Franken addresses could come in handy in these scenarios: The SPO could declare the pledge and continue to manage the pool without having ready-access to the payment key of the pledge. The SPO would only have access to the SPO wallet with a payment key securing minimal funds for day-to-day operations sufficient to pay for pool maintenance fees. The main pledge is secured with the payment key of another wallet. The owner address would be made up of one payment address part of the pledge wallet and the staking address part of the SPO wallet. As long as the pledge resided on this mangled address the SPO can bring in the stake as pledge without the risk of physical extortion as the SPO has absolutely no access to the pledge payment key.

Regular stake as opposed to pledge is just that, regular stake brought in by delegation. This stake is liquid and can move in and out of delegation at will. Pledge is not locked either, but moving it out before pledge commitment changes become active will break the pledge promise.

==== Fee Structure

The fee structure of a Cardano stake pool is determined solely by the stake pool operator and is critical for long-term sustainable operation. Costs covered by the fees generally include: fixed server cost, time spent on pool and server maintenance, marketing cost, or cost in relation to regulatory compliance, like management of a company with respective reporting duties.

The fee structure determines how much of the rewards generated by the pool will be kept by the operator and how much will be distributed to delegators. If the pool has not minted blocks in an epoch, no rewards are generated and no fees are paid. Pool fees are always taken from the rewards, so at best they diminish the delegator rewards, fees are never taken from delegator stake as Cardano natively uses non-custodial, https://www.essentialcardano.io/glossary/liquid-staking[liquid staking]. 

There are two different type of fees a Cardano stake pool operators can set:

* Fixed fee specified in amount of ada — this fee is meant to cover the fixed cost of pool operation, currently at the time of writing this is a mandatory fee of at least 170 ADA per epoch (the 170 ada is also referred to as minPoolCost). 
* Variable fee specified as a percentage — after deduction of the fixed fee an additional variable fee can be deducted from the total staking rewards from an epoch. While the fixed fee is independent of the number of blocks as long as there is at least one minted block in an epoch, the variable fee is highly dependent on the performance of the pool and the number of minted blocks relative to expected blocks. The more blocks there are minted, the higher the total rewards will be, the higher the variable fee payout for the operator. Typically, at the time of writing, the variable fee is set between 0 and 5%.

*_Note:_* While 5% variable fee might sound like a big number, this fee should always be set in relation with the expected return on staking (ROS). At the time of writing the ROS is about 4% per year. A 5% variable fee set by a stake pool will reduce those 4% ROS per year by just 0.2 points to 3.8% ROS per year.

== Stake Pool Operator (SPO) Requirements

Being that Cardano is an open protocol, and that cardano-node and cardano-cli are free and open-source software (FOSS), anyone is free to create and operate a stake pool. However, it is imperative that stake pool operators meet the level of technical expertise required to reliably and securely operate a pool on the Cardano network. While the requirements mentioned in this section are not authoritative, they are generally recognized as critical to stake pool operation.

It is also important to understand that many community-made tools and scripts exist that significantly lower the technical barrier to entry for stake pool operation. These tools exist to assist with tasks of operation and not to serve as a replacement for technical knowledge or ability.


==== *Linux*

A strong understanding of and ability to navigate, utilize and manage the Linux operating system is a must for any stake pool operator. For each release of cardano-node, binaries are made available for Linux, Mac and Windows but only Linux is supported in the block producer and relay roles. It is possible to build from source and operate cardano-node and cardano-cli on OpenBSD and potentially other unix-based operating systems, but that is an advanced and separate topic.

Suggested readings and courses:

* https://training.linuxfoundation.org/training/introduction-to-linux/[Introduction to Linux (LFS101x) by The Linux Foundation]
* https://ubuntu.com/tutorials/command-line-for-beginners#1-overview[The Linux command line for beginners Tutorial by Canonical]


==== *Networking*

A firm grasp of the Transmission Control Protocol and Internet Protocols (TCP/IP) and experience in working with and maintaining networks and interconnected devices as well as the protocols they connect with is crucial for SPOs as stewards of a large and distributed network. 

Suggested readings and courses:

* https://www.penguintutor.com/linux/basic-network-reference[TCP/IP Networking reference guide by Penguin Tutor]
* https://www.comptia.org/certifications/network[CompTIA Network + Certification]
* http://www.tcpipguide.com/[The TCP/IP Guide]

==== *Reading Documentation and Learning*

SPOs are required to not only keep nodes up-to-date, but to keep themselves up-to-date and informed as new node versions are released and on-chain changes are proposed and introduced with new node versions.

The Cardano node source-code is open-source, meaning that it can be looked at, cloned, forked, compiled and improved by the community and SPOs. Cardano’s code is currently released on Github.com, although it could be released on any version control platform. An SPO should be able to look at a project on Github such as Cardano, read through documentation, understand and follow along well enough to compile and run the node. 

Suggested reading:

* https://developers.cardano.org/docs/get-started/installing-cardano-node/[Cardano.org guide for installing Cardano node]

==== *Getting Started*

Prospective SPOs, both system administration newbies and veterans alike, should absolutely get started by using Cardano on public testnets. The Preview and Pre-production testnets are the two public testnets currently supported by IOG (there are other public and open testnets such as the https://github.com/cardano-community/guild-operators[Guild Network] that can be freely joined and used as well). The intended use of the Preview Testnet is for developers and users to test and provide feedback before things are released on mainnet and leads mainnet forks by 4 epochs by practice. The Pre-Production Testnet is used primarily by SPOs and developers to test major upgrades and releases before released on mainnet. The Pre-Production Testnet typically forks a single epoch ahead of mainnet. 

When someone considers launching a stakepool, it can be tempting to just download and run some of the fantastic scripts and tools put together by the community to help with the day-to-day operations of a pool. However, these tools were developed with the intent of making life easier for those that already know what they are doing. 

Instead of taking the easy path in the beginning and rushing directly to mainnet operation, it is strongly suggested that SPOs take time to learn how to do things by hand on one of the existing testnets. These tasks will include things like creating keys, compiling the node and CLI, crafting transactions and registering signed certificates to the blockchain. Time spent doing this will help reduce time and stress when problems arise during stake pool operations.

Here are a few useful guides and courses for setting up a stake pool:

* https://docs.cardano.org/development-guidelines/operating-a-stake-pool/creating-a-stake-pool/[Cardano Docs: Creating a stake pool]
* https://cardano-course.gitbook.io/cardano-course/handbook[Cardano Course: Handbook]
* https://developers.cardano.org/docs/operate-a-stake-pool/[Cardano Developer Portal: Operate a Stake Pool]
* https://www.coincashew.com/coins/overview-ada/guide-how-to-build-a-haskell-stakepool-node[Concashew’s Stake Pool Guide]

*Please note:* The recommended readings and courses shared in this section are not endorsements but rather suggested potential starting points for those interested in learning more and gaining experience in operations relative to stake pool operation.

==== *Putting it all together, long time maintenance*

Due of the stability of the Haskell-node, basic node operation is not quite the challenge it was in the early days of the Incentivized Testnet (ITN), especially when the current node is paired with community tools mentioned in "Getting Started" like https://cardano-community.github.io/guild-operators/[CNTools], https://bitbucket.org/muamw10/jormanager/src/develop/[JorManager], https://github.com/gitmachtl/scripts[StakePool Operator Scripts], or others not listed. 

Listed below are some things prospective SPOs should consider mastering or getting a firm grasp of before operating on mainnet in a professional manner. 

* Monitor node health and configure alerting for when something goes wrong such as missed blocks, node crashes, stuck block height, etc.
* Read and interpret logs from cardano-node to troubleshoot and find potential issues. 
  Investigate each missed block and determine what went wrong. Long-term luck should be near 100% and while block collisions that occur when the same slot is assigned to more than one pool happen, they are uncommon. More on this subject can be found in the https://github.com/input-output-hk/mastering-cardano/blob/main/chapters/chapter-stake-pools-and-stake-pool-operation/making_blocks.adoc[Slot Battles, Height Battles, Forkers and Propagation] chapter. 
* Help other SPOs analyze, contribute, and create cardano-node Github issues on the testnets or mainnet.
* Perform pool maintenance such as node or infrastructure updates without any service interruption.
* https://github.com/input-output-hk/mastering-cardano/blob/main/chapters/chapter-stake-pools-and-stake-pool-operation/server_security_and_hardening.adoc[Harden the pool environment.]
* https://github.com/input-output-hk/mastering-cardano/blob/main/chapters/chapter-stake-pools-and-stake-pool-operation/timesync.adoc[Keep the node and server synced to universal time.]
* Perform pool-relevant tasks such like pool registration updates without exposing keys.
* Expand resource provisioning for cardano-node without service interruption.
* Plan and configure failover for critical node failure.

== Assigning Leadership Slots to Stake Pools

:url-repo: https://github.com/input-output-hk/mastering-cardano/chapters/chapter-stake-pools-and-stake-pool-operation
:imagesdir: illustrations

==== Overview
On proof-of-work blockchains like Bitcoin, miners create blocks by solving cryptographic puzzles, a very resource-intensive task. On Cardano, a proof-of-stake blockchain, stake pools are chosen to create a block based on a stake-weighted lottery system, described in the https://eprint.iacr.org/2016/889.pdf[Ouroboros paper], but we will give a simplified overview here.

==== Epochs, Blocks, and Slots
The leadership schedule on Cardano is broken up into epochs and  slots, with epochs being longer periods of time than slots. On Cardano mainnet, a new epoch starts every 5 days and begins at 21:44:51 UTC time. Each epoch contains 432,000 x one second slots (5 days). Other Cardano-based test networks or sidechains could of course have a different configuration, but we’ll discuss the Cardano mainnet here. 

In each slot , there is a possibility a block could be made. To maintain a secure system for creating blocks, it’s important for each stake pool node to determine if the pool is:

. Allowed to make a block in a given slot.
. Able to prove to other nodes that they were allowed to make a block.
. Able to hide from others that they are chosen to make a block in the future.

image::limbo.png[width=100%,title="Limbo"]
==== Playing Limbo
To simplify the explanation of how a pool is chosen to create a block, we will treat it as a game of Limbo. In order to win at Limbo, a person (the stake pool) needs to go under the bar (a threshold value). For every slot, the bar is uniquely set to a given height for each stake pool. The height is determined by how much stake is in the pool. Larger pools have a higher bar and thus it’s easier for them to win the game (make blocks). Smaller pools will have the bar set lower for them. The bar is not set to the exact same height every time, but rather randomly placed for every pool participating and then adjusted up or down based on the stake in the pool.

To determine whether or not the stake pool has made it under the bar in a given slot, several factors are assessed. 

First is the epoch nonce value. The epoch nonce is a long random number made up of a combination of the rolling nonce, which is updated every block, and also a block hash. The rolling nonce value is selected from the block right before the start of the stability window of the previous epoch.

Currently, the stability window is 1.5 days long, so the value from the block before that window is taken. Leadership information cannot be calculated until 1.5 days before the next epoch starts for the next epoch. The second value that goes into the epoch nonce is the hash of the last block of the previous epoch. Those values are concatenated and then hashed to give us the epoch nonce. The epoch nonce value is the same for all pools.

The epoch nonce is combined with the absolute slot number and the pool’s verifiable random functon (VRF) secret key to give a random output for any given slot. This value is then weighted based on how much stake is in the pool versus the total amount of ada that is delegated in the system. If this weighted random value is less than the threshold value, the pool is allowed to create a block. The pool has successfully won the game of Limbo for that slot!

==== Security
It’s important that only the pool operator knows when they will be making a block in the future. For this reason, the pool’s VRF secret key is used to check for leadership selection. The pool’s VRF public key is published on the blockchain. Because of this, it’s impossible for anyone other than the pool operator to know when they have a potential block-making opportunity. Other nodes can verify the VRF signature of the block using the pool’s public VRF key only after the fact to ensure the algorithm is fair and that the pool was allowed to make the block. Due to this secrecy, security is preserved, and it is untenable for an attacker to perform any type of DDoS attack against any particular stake pool.

== Slot Battles, Height Battles, Forkers and Propagation

:url-repo: https://github.com/input-output-hk/mastering-cardano/chapters/chapter-stake-pools-and-stake-pool-operation
:imagesdir: illustrations


==== Ouroboros leader selection review
On the Cardano blockchain stake pools make blocks on behalf of their delegators according to the Ouroboros protocol. In Ouroboros, the stake pool selection algorithm is a lottery that runs on every slot (1 slot per second according to current protocol parameters) and the probability of a pool being selected is proportional to the stake it holds. If a pool wins the lottery it is considered a leader for that slot. The details of this algorithm are described in the  https://eprint.iacr.org/2016/889.pdf[Ouroboros paper] and in other sections of this book and thus will not be repeated here but whats important is every pool with stake could theoretically be a leader (make a block) on any slot in any epoch thus leading to situations where multiple pools could be leaders for the same slot or nearly the same slot. There can only be one block on the chain in a particular slot so when multiple pools create blocks that are in contention with each other the stage is set for what we have termed "battles" in the Cardano community.

==== Types of battles
To understand the types of battles we can have in Cardano we need to review a few important parts of what makes blockchains work. Referring to the illustration below for three blocks on chain starting with the one on the left at height 8,265,668 and in slot 244,252 with a block hash of "c7b2…​8bac". The next block with a hash of "f777…​498c" at height 8,265,669 includes parent hash "c7b2…​8bac" thus we say it is built ON the previous block. Note that the slot for this block is 244,261 which means it was made 9 slots (9 seconds in current protocol parameters) after the previous block. And finally the third block at height 8,265,670 includes parent hash "f777…​498c" and was made in slot 244,309. This demonstrates how blocks are built on top of each other and how the blockchain grows.

image::nittygritty-illustration-1.png[width=100%,title="Basic blockchain illustration"]
===== Slot Battles
When two blocks are presented at exactly the same height AND have the same parent hash AND slot have the same slot, we have whats called a "Slot Battle".  

image::nittygritty-illustration-2.png[width=50%,title="Slot Battle"]

===== Height Battles
When two blocks are presented at exactly the same height AND have the same parent hash BUT have a different slot, we have whats called a "Height Battle".

image::nittygritty-illustration-3.png[width=50%,title="Height Battle"]

===== Forkers
The third classification that we track is Forkers which represents the situation where a pool operator has multiple block-producing nodes operating on the network at the same time. This usually happens when a pool operator is upgrading their systems and have temporarily started a second instance of their node before shutting down their old instance. Thus both instances will create a block and try to distribute it to the network. This is not a battle but it is important to track because it can cause a lot of confusion and wasted effort for the chain and thus we try to minimize it as a community.

image::nittygritty-illustration-4.png[width=50%,title="Forker"]

===== Summary
The following table summarizes the types of contention we can have on the Cardano blockchain.
[cols="1,1,1,1,1", options="header"]
|===
|Type |Same Slot |Same Parent Hash |Same Height |Same Stake Pool
|Slot Battle |Yes |Yes |Yes |No
|Height Battle |No |Yes |Yes |No
|Forker |Yes |Yes |Yes |Yes
|=== 

=== Resolution of battles and forks
When a battle or fork happens on the network, all nodes must reach consensus on which block to add to the chain and which one(s) to throw away. There are two primary rules followed in the Praos era (after the vasil hard fork) to decide:

.  Chain Length, the longest chain length is always preferred.
.  If the chain length is the same, we choose the block with the lowest block vrf.


==== Block VRF
The block VRF is a number generated from the epoch nonce, the slot number, and the private VRF key registered by the pool. The value of this function is not dependent on contents of the block and is not subject to manipulation by the pool operator. Block VRF values can be very large and are represented as a 128 character hexadecimal number.  

=== Propagation
When a pool makes a block, it must be distributed to the network in order to be added to the chain. This is called "propagation" and is the process of sending the block to all other nodes on the network. Pool operators spend a lot of time optimizing their setups to distribute their blocks to as many nodes on the network as possible. The way this works is beyond the scope of this section, but it is important to understand that it takes time for blocks to make their way to all network participants and not all nodes receive the blocks at the same time.

The cardano ecosystem has some tools avaliable to visualize each pools propogation time. An example below shows a real example of a pool’s measured propogation for the blocks it has created. As you can see on average every node receives the block within about 600mS but there are some outliers that take much longer. This is why it is important to have a good distribution strategy for your blocks.

image::nittygritty-illustration-5.png[width=50%,title="Propogation time"]

==== Tying it all together: Some real examples

===== The typical situation:
90%+ of the blocks on the chain are created with a normal cycle and no drama. The following illustration shows a normal example of a pool creating a block and then the next pool creating a block on top of it. The first pool creates a block in slot 10 and the second pool creates a block in slot 15. The second pool’s block is built on top of the first pool’s block and the chain continues.

<need illustration>

1.  Pool A creates a block in slot 10
2.  Pool A sends a block to all of its peers on the network
3.  Pool A's peers forward the block further to all of their peers and so on.  Some nodes receive the block in slot 10, some in slot 11, some in slot 12, etc.
4.  Pool B creates a block in slot 15 and because it already has seen Pool A's block, it builds on top of it and extends the chain further and the cycle continues.

===== The height battle example:
But what if pool B creates a block in slot 15 and it does not have Pool A’s block yet? This is where we have a height battle as both Pool A’s block in slot 10 and pool B’s block in slot 15 will have the same parent block and thus the contention is settled by the block VRF value. The block with the lowest block VRF value will be added to the chain and the other block will be thrown away.

===== The slot battle example:
Alternatively if both Pool A and Pool B create a block in slot 10 there is immediate contention. This is a slot battle and the block with the lowest block VRF value will be the one that is added to the chain and the other block will be thrown away.

[sidebar]
.Interesting Historical Trivia
--
In previous versions of the Cardano Incentivized testnet protocol the first pool to submit a block would win the battle. This lead to centralization as nodes with faster internet connections or those that were proximate to most other nodes would always win the battle.
--
 
===== The underpowered node problem:
Sometimes pool operators will have problems with their node that makes it slow to produce blocks. Usually this is because the hardware is underpowered or the node is not optimized. This can cause other pool operators to loose their blocks through no fault of their own. The example below shows what can happen to in this case.

1.  Pool A creates a block in slot 10
2.  Pool B is assigned a block in slot 11 but is very slow to generate the block and it takes 5 seconds to create and propogate the block to other nodes.
3.  Meanwhile Pool C is assigned a block in slot 14 and since it hasn't seen Pool B's block yet, it builds on top of Pool A's block.
4.  Finally in slot 15 Pool B’s block is distributed and all nodes need to pick between Pool B’s block and Pool C’s block when if all pools were operating at full speed, Pool B’s block would have been the one that was added to the chain and then Pool C’s block would have built on top of that.

Underpowered nodes cause pools to loose blocks without good reason thus leading to lower chain density and less decentralization. This underpins the importance a for pool operators to have a good block distribution strategy.

== `cardano-cli`

=== Prologue

As its name suggests, the _Cardano command line interface_ (`cardano-cli` for short), is the low-level CLI (command line interface) component of the `cardano-node` repository. It is the perfect companion to the `cardano-node` and is often built alongside or provided as a pre-compiled binary together with `cardano-node`. What for? To simply interact with the blockchain being built in the background by `cardano-node`. Would you drive a car without a steering wheel?!

Here, we will focus on the subset of `cardano-cli` commands most useful to Cardano Stake Pool operators. This entire chapter contains the steps required to set up a stake pool from the very beginning. Namely:

* Key generation for addresses and pools
* Certificate generation
* Node queries
* Basic transaction

To walk through these, we will assume you have:

* `cardano-cli` installed in your machine.
* `cardano-node` installed in your machine, running and synced to a publicly available Cardano network (`preview`, `preprod` or `mainnet` for example).
* the `CARDANO_NODE_SOCKET_PATH` properly set in your environment so that `cardano-cli` knows how to talk to your running instance of `cardano-node`.
+
_Note that the last two points are only required when submitting a transaction or querying the ledger. In other words, a running node is handy when you need to interact with or access the current state of the blockchain. Generating keys, addresses or certificates only require `cardano-cli` and should sometimes be done entirely offline for security reasons!_

Before starting, let's check that both `cardano-node` and `cardano-cli` are up to date. Paste the following code snippet below in your terminal.

----
cardano-node version
----

Your terminal should reply something along those lines:

----
 cardano-node 1.35.6 - linux-x86_64 - ghc-8.10
 git rev 07b0c71d2e6662aec4389ec282a7e91f68c3d85f
----

Let's ask `cardano-cli`.

----
cardano-cli version
----

----
cardano-cli 1.35.6 - linux-x86_64 - ghc-8.10
git rev 07b0c71d2e6662aec4389ec282a7e91f68c3d85f
----

Same version (`1.35.6`), and better, both originate from the same code branch (`+git rev 07b0c7...3d85f+`). Perfect!

____
Notice how we access the `version` command of `cardano-cli` (or `cardano-node`): a single space character is used to navigate through the available commands and here, `version` takes no extra parameters. As you will see later, parameters are passed using a double hyphen (`--`).
____

== Keys generation

Public/private key pairs are everywhere in cryptography. In Cardano, the controller of a private key can spend ada contained in an address, sign a block or prove to other nodes they were meant to sign a specific block.

____
*All private keys should be sufficiently protected from both prying eyes and accidental deletions or squashings alike. Since the launch of Shelley, many examples of mismanaged keys exist leading to non-functional stake pools or in rare instances, stolen funds.*
____

=== Addresses

Every action recorded on the ledger will _a minima_ require a transaction fee. An address must pay for this transaction fee and/or provide funds as a deposit (cf. section _Basic transaction_). Here, let's describe how to generate address key pairs and derive a base address that will be used to create and register a stake pool. Note: This section is not a complete reference for `cardano-cli` relative to addresses.

==== Payment key pair

We will refer to this as the *`payment`* key pair. We will use the suffix *`vk`* to identify the *payment public key* (or verification key) and the suffix *`sk`* to identify the *payment private key* (or secret key). Remember that in Cardano, ada contained in an address is under the control of the `payment.sk` only.

Let's generate one.

----
cardano-cli address key-gen --verification-key-file ./payment.vk --signing-key-file ./payment.sk
----

As alluded to earlier, `address` and `key-gen` are two nested commands of `cardano-cli`, while `--verification-key-file` and `--signing-key-file` are parameters of the entire command.

In the directory where you executed the command, you should have the following files:

----
payment.sk
payment.vk
----

Both files have the structure shown below:

----
cat ./payment.vk
----

----
{
    "type": "PaymentVerificationKeyShelley_ed25519",
    "description": "Payment Verification Key",
    "cborHex": "5820205d42785c7dc9a46898655ecda8dad8b14e47747dc94ba184edc8ada0b72969"
}
----

The `payment.sk` has the same structure, with the type `PaymentSigningKeyShelley_ed25519` and of course a different `cborHex` value. You won't know more, it is a secret after all.

We now have what we need to derive an address to receive funds:

----
cardano-cli address build --payment-verification-key-file ./payment.vk --mainnet > payment.addr
----

The newly created `payment.addr` file contains an address in the format:

----
addr1v9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3gnt67k6
----

Three things to note:

* `--payment-verification-key-file` is the sole parameter needed for payment address creation.
* We used the `--mainnet` parameter to create this address. It means that this address won't be of any use on a testnet. Conversely, the `--testnet-magic` parameter would allow us to create an address for a specified testnet. Mishaps avoided!
* Cardano Preview Testnet is on `--testnet-magic 2` and Cardano Preprod Testnet is  on `--testnet-magic 1`

==== Staking key pair

Using the address generated above has one big drawback... it can receive and send ada, but has no staking rights associated to it, making it what we call an `enterprise address`. Let's add those.

In the same folder where our payment key pair is located, let's generate a *`staking`* key pair. Following convention, we will call them *`stake.vk`* and *`stake.sk`*.

----
cardano-cli stake-address key-gen --verification-key-file ./stake.vk --signing-key-file ./stake.sk
----

Both files have the structure shown below:

----
{
    "type": "StakeVerificationKeyShelley_ed25519",
    "description": "Stake Verification Key",
    "cborHex": "5820eaa448543c3f95cbecf5c7ef00e481695388462c7e470b90052920138272a88b"
}
----

Similarly, we can build the corresponding staking address using the `stake.vk`.

----
cardano-cli stake-address build --stake-verification-key-file ./stake.vk --mainnet > stake.addr
----

The newly created `stake.addr` file contains:

----
stake1uy4hlpcmhd026m4ny9y9uxl94rez479g8h0sqalljf9zehguqnhcm
----

==== Building an address

As you have seen, the payment key pair and the staking key pair can both be used to generate addresses. While the payment address (or `enterprise address`) can be used to receive or send ada, that is not the case for the staking address. As such, a staking address is useless. It will only come to life when associated with ada residing within a payment address.

----
cardano-cli address build  --payment-verification-key-file ./payment.vk --stake-verification-key-file ./stake.vk --mainnet > base.addr
----

The newly created  `base.addr`  file contains an address that combines the best of both worlds, the ability:

1) To send and receive ada.
2) Delegate stake and perceive rewards for doing so.

----
addr1q9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3ft07r3hw6744htxg2gtcd7t28j9tu2s0wlqpmllyj29nwssucyxn
----

Note that this address is longer than an `enterprise address`.

==== File Summary #1

Your working directory should now contain 7 files:

----
base.addr
payment.addr
payment.sk
payment.vk
stake.addr
stake.sk
stake.vk
----

It is now a good time to back up those key pairs and send some ada to the `base.addr` in order to fund our next venture: creating a stake pool.

=== Stake Pool related key pairs

The creation and operation of a Cardano stake pool relies on three public/private key pairs.

==== Stake Pool keys or Cold Keys

As the name suggests, it is strongly advised to keep these in a cold environment _i.e._ on a machine permanently disconnected from the internet or other networks.

____
*The pool private cold key governs all pool actions: pool creation, key rotations (cf. KES or VRF key pairs), fee structure, reward/pledge address setting and pool retirement.*
____

----
cardano-cli node key-gen --cold-verification-key-file ./pool.vk --cold-signing-key-file ./pool.sk --operational-certificate-issue-counter-file ./counter
----

Notice that in addition to the `cold-verification-key-file` and `cold-signing-key-file`, we also generated a mandatory `counter` file.

----
{
    "type": "NodeOperationalCertificateIssueCounter",
    "description": "Next certificate issue number: 0",
    "cborHex": "820058203e9dff9346dab83c109a9da73aabf4642ebe64e0274b6a0931ee4b8d838ea304"
}
----

This `counter` will be used to create an `operational certificate` for the stake pool. For now, let's keep in mind that the `operational certificate` is generated by using this `counter` and a KES public key defined in the section "KES keys pair".

We have not yet registered the Cardano stake pool, but we can already know its future on-chain `id` .

----
cardano-cli stake-pool id --cold-verification-key-file ./pool.vk
----

and the answer is

----
pool1xhjzslnkyxvj23almagsmzeck0el7989cqz9rlms8a0pvdly0de
----

==== VRF keys pair

The Verifiable Random Function key pair, or VRF, is used by the node to determine whether or not to attempt to sign a block. A node will check if that is true at every slot.

----
cardano-cli node key-gen-VRF --verification-key-file ./vrf.vk --signing-key-file ./vrf.sk
----

Let's have a look:

----
{
    "type": "VrfVerificationKey_PraosVRF",
    "description": "VRF Verification Key",
    "cborHex": "5820b49718bee9e359b666950c255f2ff7a3ace260963baeb8e8b618d75575dd8ce7"
}
----

The VRF key will reside on the connected block-producing node, as it is used as a parameter to start `cardano-node`.

____
While it is possible to modify the VRF key of a stake pool by sending a new `pool-registration certificate` (more on this later), doing so will forfeit pool rewards for 2 epochs... This should help encourage tight security practices!
____

==== KES keys pair

The Key Evolving Signature signing key, or KES, is the key used by the node to sign a block.

----
cardano-cli node key-gen-KES --verification-key-file ./kes.vk --signing-key-file ./kes.sk
----

Let's have a look:

----
{
    "type": "KesVerificationKey_ed25519_kes_2^6",
    "description": "KES Verification Key",
    "cborHex": "5820f93acee67a1af6529ff02818a18c813d05a71c3cde8a16606133dbbee7f583bc"
}
----

The KES signing key must also reside on the block-producing node.

A `kes.sk` used by a node has a validity range of 93 days (or 62 kes-periods) and needs to be renewed before this period expires. That's  where the `counter` and the `operational certificate` come into play.

==== Operational certificate

Create an `operational certificate`:

----
cardano-cli node issue-op-cert --kes-verification-key-file ./kes.vk --cold-signing-key-file ./pool.sk --operational-certificate-issue-counter-file ./counter --kes-period 694 --out-file opcert
----

*Some explanations are in order:*

* The `counter` will automatically be incremented by exactly *one* after running the above command. Check by yourself:
+
----
{
    "type": "NodeOperationalCertificateIssueCounter",
    "description": "Next certificate issue number: 1",
    "cborHex": "820158203e9dff9346dab83c109a9da73aabf4642ebe64e0274b6a0931ee4b8d838ea304"
}
----

* The `--kes-period` defines the *starting point* of a validity range for the `kes.sk` referenced in the `operational certificate`. One way to calculate the `current-kes-period` of the network on *Cardano mainnet* is to use the formula below. We assume here that `byron_slots`, `byron_end_time` and `slots_per_kes_period` are constant values:
+
----
current-kes-period = (byron_slots+(CurrentTime - byron_end_time))/slots_per_kes_period
current-kes-period = (4492800+(CurrentTime-1596059091))/129600
----
+
`CurrenTime` on your machine can be obtained like this:
+
----
printf '%(%s)T\n' -1
----
+
Some noteworthy Cardano community members have even built fully parameterized ways to calculate the `current-kes-period` for any given network, such as https://github.com/gitmachtl/scripts/blob/master/cardano/mainnet/0x_showCurrentEpochKES.sh[this one]. We cannot thank them enough.

* *You must generate a new KES key pair and a new `operational certificate` before the end of the validity period of exactly 62 kes-periods.* Your block producing node will have to be restarted using the new `kes.sk` and new `operational certificate`. This process is called "KES rotation". *One period corresponds to 1.5 day. That is why KES rotation must be performed at maximum every 93 days.* You can however perform this rotation at an earlier date if more convenient.
+
____
In the example above using `--kes-period 694` , the `operational certificate` will certify that the `kes.sk` is valid until the network reaches the `kes-period 756`.
____

* Since the Babbage era (September 2022), it is important to know that an *`operational certificate` must be rotated using an +1 counter* (previously, it could be any value higher than the last counter) and *only if the pool has produced at least one block during the interval of 93 days.* In case the pool has not produced any blocks during this period of 93 days (or 62 kes-periods), the `counter` must be edited back to its previous value before generating a new `operational-certificate`. An example is shown at the end of this section.
+
`cardano-cli` offers a query that recapitulates all that:
+
----
cardano-cli query kes-period-info --op-cert-file ./opcert --mainnet
----
+
and replies
+
----
✓ Operational certificate's KES period is within the correct KES period interval
✗ No blocks minted so far with the operational certificate at: ./opcert
  On disk operational certificate counter: 0
{
    "qKesCurrentKesPeriod": 695,
    "qKesEndKesInterval": 756,
    "qKesKesKeyExpiry": null,
    "qKesMaxKESEvolutions": 62,
    "qKesNodeStateOperationalCertificateNumber": null,
    "qKesOnDiskOperationalCertificateNumber": 0,
    "qKesRemainingSlotsInKesPeriod": 7891408,
    "qKesSlotsPerKesPeriod": 129600,
    "qKesStartKesInterval": 694
}
----
+
Notice here that by the time we generated our first `operational certificate`, 1 kes-period passed. See the difference between `"qKesCurrentKesPeriod": 695` and `"qKesStartKesInterval": 694` !

*Rotation example with a `counter` reset:*

Let's pretend that 62 kes-periods have passed and the pool has not produced any blocks while using our first `operational certtificate`. It would be then be time to rotate the pool's KES key via a new `operational-certificate`. However, because the pool did not produce any blocks, we must rotate the KES key using a `counter` without the automatic increment performed by the `cardano-cli node issue-op-cert` command.

To revert that automatic increment, we can create a new counter and specify it value using the command below.

----
cardano-cli node new-counter --cold-verification-key-file ./pool.vk --counter-value 0 --operational-certificate-issue-counter-file ./new.counter
----

We set a `--counter-value` of `0` and created the new counter file `new.counter`.

Let's see how `new.counter` looks:

----
{
    "type": "NodeOperationalCertificateIssueCounter",
    "description": "",
    "cborHex": "820058203e9dff9346dab83c109a9da73aabf4642ebe64e0274b6a0931ee4b8d838ea304"
}
----

The `"description"` field has unfortunately been destroyed but what matters is the `cborHex` value, reset to `+"8200...8ea304"+`. Do you notice a difference with the last time we looked at it?

It had a different `cborHex`! `+"8201...8ea304"+`. That little integer change makes all the difference. Make sure to edit manually the `"description"` field of the `new.counter` to avoid getting lost later on.

To finish, this `new.counter` can be used to generate a fresh `operational-certificate`, not forgetting to use a new pair of KES keys and an up-to-date `current-kes-period` of the network. Et voilà.

==== File Summary #2

Your working directory should now contain 16 files:

----
base.addr
counter
kes.sk
kes.vk
new.counter <<< Example file that can safely be destroyed.
opcert
payment.addr
payment.sk
payment.vk
pool.sk
pool.vk
stake.addr
stake.sk
stake.vk
vrf.sk
vrf.vk
----

== Certificates

Certificates are actions performed on the ledger that allow us to:

* Register a stake address (and deregister)
* Register a stake pool (and deregister)
* Delegate an address to a stake pool

[discrete]
==== Address registration (and deregistration)

The stake component contained within a `base.addr` must be registered on the ledger prior being able to delegate ada, receive staking rewards, or use this `base.addr` as way to declare the pool's pledge or receive pool rewards. This is done by sending a registration certificate for the corresponding `stake.addr` on the blockchain.

For the moment, let's construct this registration certificate and we will send it on-chain later:

----
cardano-cli stake-address registration-certificate --stake-verification-key-file ./stake.vk --out-file stake.registration
----

A deregistration certificate for an address can easily be produced using the `cardano-cli stake-address deregistration-certificate`. It is the best way to stop participating in ada staking. To incentivize users, deregistering an address refunds the 2 ada deposit paid for address registration. More on that later.

[discrete]
==== Stake pool registration

Like a `base.addr`, a stake pool will need to make itself known to the network before being able to receive delegation and eventually produce blocks.

This `stake-pool registration-certificate` is a bit complex since it contains an abundance of information relative to pool keys, owner(s), fee structure, pool relays and metadata. Let's observe line by line:

----
cardano-cli stake-pool registration-certificate \
--cold-verification-key-file ./pool.vk \
--vrf-verification-key-file ./vrf.vk \
--pool-reward-account-verification-key-file ./stake.vk \
--pool-cost 340000000 \
--pool-margin 0.02 \
--pool-owner-stake-verification-key-file ./stake.vk \
--pool-pledge 0 \
--pool-relay-ipv4 xxx.xxx.xxx.xxx \
--pool-relay-port xxxx \
--metadata-url url-to-metadata \
--metadata-hash hash-of-metadata \
--mainnet \
--out-file pool.registration
----

`--cold-verification-key-file`: To ensure the right cold secret key signature is present when sending the certificate on-chain.

`--vrf-verification-key-file`: Other pools will check whether the pool had the right to produce a block for a given slot.

`--pool-reward-account-verification-key-file`: The `stake.vk` of the `base.addr` you would like to receive the rewards for running the pool. There can be only one.

____
The reward address will not by required to sign the transaction sending the certificate on-chain.
____

`--pool-cost`: the fixed cost the pool will charge before calculating the margin fee. It cannot be set lower than 340 ada or 340000000 lovelaces at this time on mainnet.

`--pool-margin`: the percentage fee taken by the pool on the remaining rewards after pool cost has been deducted from all block rewards. Its boundaries are 0 (0 %)  and 1 (100%). In this example, it is set at 2%.

`--pool-owner-stake-verification-key-file`: The `stake.vk` of the `base.addr` you would like to use as pledge for the pool. It can be the same as the reward account, but different one may be used. You can have more than one pledge `base.addr`.

____
*The transaction sending the certificate will include a signature for each and every address referenced as a pool owner.*
____

`--pool-pledge`: The lowest amount in lovelace that must be collectively present in the owner(s) account(s), otherwise the pool forfeits all rewards for delegators and itself. Here, to be safe, let's set it to 0.

____
*The address(es) declared as pool's pledge must all be delegated to the pool being registered.*
____

`--pool-relay-ipv4`: The IP address of the relay node used to shield the block produced from connections to the wider network. Note that an `ipv6` option exists.

`--pool-relay-port`: The port on which the relay `cardano-node` will listen to.

NOTE: If more than one relay is used, these parameters can be duplicated like so.

----
--pool-relay-ipv4 IP#1 \
--pool-relay-port xxxx#1\
--pool-relay-ipv4 IP#2 \
--pool-relay-port xxxx#2\
----

Alternatively, the `--single-host-pool-relay` can be used to declare a  stake pool relay's DNS name that corresponds to an A or AAAA DNS record.

----
--single-host-pool-relay dns.record \
--pool-relay-port xxxx \
----

`--metadata-url`: a publicly available URL that serves the metadata of the pool. Below an example of a pool's metadata.json file.

----
{
"name":"Pool's name",
"description":"Example pool",
"ticker":"EXP",
"homepage":"https://examplepool.com"
}
----

`--metadata-hash`: A hash of the accessible metadata.json must be provided to ensure it has not been tempered with. Once the metadata.json file has been downloaded from the url, we can generate a hash with `cardano-cli`:

----
cardano-cli stake-pool metadata-hash --pool-metadata-file ./metadata.json --out-file ./metadata.hash
----

Explore the `cardano-cli stake-pool registration-certificate` command to know more about other options available (`ipv6` or `SRV DNS records` for example).

[discrete]
==== Stake pool deregistration

If you wish to retire a pool, you can easily create a `deregistration certificate`:

----
cardano-cli stake-pool deregistration-certificate --cold-verification-key-file ./pool.vk --epoch 410 --out-file pool.deregistration
----

The  `--epoch`  parameter defines the desired epoch the pool is to become inactive. The epoch must obviously be in the future, but not too far out! No more than 18 months to be precise. This is determinged on Cardano mainnet by a parameter in the `mainnet-shelley-genesis.json` configuration file as the  `eMax`  value. This pool deregistration certificate will have to be sent on-chain and to incentivize pool operators, deregistering a pool refunds the 500 ada deposit paid for pool registration.

____
*Only the pool cold keys are required to retire a pool. The owner has no say in it if they are not the pool operator!*
____

[discrete]
==== Delegation certificate

A `base.addr` can be delegated to a stake pool via a `delegation certificate` like so:

----
cardano-cli stake-address delegation-certificate --stake-verification-key-file ./stake.vk --cold-verification-key-file ./pool.vk --out-file delegation.certificate
----

As expected, you will need the `stake.vk` of the address you wish to delegate, as well as the `pool.vk` of the pool you wish to delegate to. Since the pool is operated by you, this should be no issue!

____
Do not hesitate to explore the `cardano-cli stake-address delegation-certificate` command to find out how one can delegate to another stake pool for which one is not the operator (_i.e._ for which one does not have the corresponding `pool.vk`).
____

[discrete]
==== File Summary #3

Your working directory should now contain 21 files:

----
base.addr
counter
delegation.certificate
kes.sk
kes.vk
new.counter <<< Example file that can safely be destroyed.
metadata.hash
opcert
payment.addr
payment.sk
payment.vk
pool.deregistration <<< Example file that can safely be destroyed.
pool.registration
pool.sk
pool.vk
stake.addr
stake.registration
stake.sk
stake.vk
vrf.sk
vrf.vk
----

Congratulations! We are almost done!

Now that all addresses, keys and certificates are in your hands you will be able to interact on-chain (cf. Section Transactions) and let the world know you are here for serious business.

== Queries

Before building transactions we need to first familiarize ourselves with node queries. We have already encountered one `cardano-cli` query function when looking for the `kes-period-info` of the network.

All query commands can be listed like this:

----
cardano-cli query
----

Rather than diving exhaustively through the entire list, let's focus on some useful queries for the next "Basic transaction" section. Do not hesitate to explore other queries on your own.

[discrete]
==== Protocol parameters

First, let's grab the `protocol-parameters` and copy it in a `pparameter.json` file.

----
cardano-cli query protocol-parameters --mainnet > pparameters.json
----

`pparameter.json` contains a long list of smart contract related costing models as well as useful information to estimate the cost of a transaction. For this we are interested in the latter.

[discrete]
==== UTxOs in an address

In order to manually build the transaction that will post the certificates we created earlier, we first need to know which UTxO to use. An UTxO is uniquely represented on-chain by the combination of a `TxHash` and a `TxIx` (_i.e_ transaction hash and transaction index). An address can hold multiple UTxOs.

We can access the UTxO(s) of an address like so:

----
cardano-cli query utxo --address addr1q9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3ft07r3hw6744htxg2gtcd7t28j9tu2s0wlqpmllyj29nwssucyxn --mainnet
----

----
                           TxHash                                 TxIx        Amount
--------------------------------------------------------------------------------------
0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211     0        5000000 lovelace + TxOutDatumNone
----

For demonstrative purposes, the address generated in the very first section of this tutorial has been funded with 5 ada, or 5000000 lovelaces. This ada amount will *_not_* be enough to carry on with the next steps but it gives you a real world example!

[discrete]
==== Slot height of the network

Transactions in Cardano have an expiry date and the user can define it. To do so, one must first know the `Cardano Time` expressed in `slot` height.

----
cardano-cli query tip --mainnet
----

----
{
    "block": 8668162,
    "epoch": 406,
    "era": "Babbage",
    "hash": "cf5902001ba7024b07c999421804a77b6bf7858c2298e7ead1c5732a6697bcc7",
    "slot": 90368116,
    "syncProgress": "100.00"
}
----

== Basic transaction

Finally, we are getting there! In this section we will create a single transaction that will post the `stake.registration` of the `base.addr`, the `pool.registration` and the `delegation.certificate` that were generated in the previous sections. All in one go.

[discrete]
==== Estimate the transaction fee

We will first create a dummy transaction (`tx.draft`) in order to estimate the transaction fees.

----
cardano-cli transaction build-raw \
--tx-in 0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211#0 \
--tx-out addr1q9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3ft07r3hw6744htxg2gtcd7t28j9tu2s0wlqpmllyj29nwssucyxn+0 \
--invalid-hereafter 0 \
--fee 0 \
--certificate-file ./stake.registration \
--certificate-file ./pool.registration \
--certificate-file ./delegation.certificate \
--out-file tx.draft
----

Because it is a `tx.draft` all values are set to `0` .

* `--tx-in`: the UTxO that will be consumed in the format *`TxHash#TxIx`*. Nothing prevents you from consuming more UTxO! Use additional `--tx-in` lines to do so.
* `--tx-out`: the address where ada change will be sent back to. Nothing prevents you from specifying more than one address! Use additional `--tx-out` lines to do so.
* `--invalid-hereafter`: the transaction will be valid until this slot height is reached.
* `--fee`: the transaction fee what we want to calculate!
* `--certificate-file`: adding a certificate to the transaction.

Once we have the `tx.draft`, we can calculate the fees.

----
cardano-cli transaction calculate-min-fee \
--tx-body-file tx.draft  \
--tx-in-count 1 \
--tx-out-count 1 \
--witness-count 3 \
--mainnet \
--protocol-params-file pparameters.json
----

____
You may adjust the `--tx-in-count`, `--tx-out-count`, and `--witness-count` values accordingly. Here, we consume one UTxO, have the change sent back in a single address and will sign the transaction with 3 witnesses (a.k.a. secret keys).
____

The command replies :

----
197313 Lovelace
----

Perfect! Only 0.197313 ada. Not too expensive for a transaction containing three certificates.

____
*Note: Transaction fees are deterministic and as such, have a lower bound. However, one is always allowed to pay more than is required. Please take care with fee inputs.*
____

[discrete]
==== Build the final transaction

----
cardano-cli transaction build-raw \
--tx-in UTxO_TxHash#TxIx \
--tx-out $(cat base.addr)+value \
--invalid-hereafter 90369116 \
--fee 197313 \
--certificate-file ./stake.registration \
--certificate-file ./pool.registration \
--certificate-file ./delegation.certificate \
--out-file tx.final
----

* `--tx-in UTxO_TxHash#TxIx`: `TxHash`#`TxIx` of the UTxO you want to consume!
* `--tx-out $(cat base.addr)+value`
+
[IMPORTANT]
====


*`--tx-out` value is expressed in lovelaces.*
* Registering an address requires a deposit of 2 ada (2000000 lovelaces).
* Registering a pool requires a deposit of 500 ada (500000000 lovelaces).
* This means that the change to the `base.addr` will be : *_value = input - (502 deposit + transaction fee)_*
* Deregistration of an address or a pool will be accounted for by adding 2 ada or 500 ada, respectively, to the ada change value one must calculate to correctly balance a transaction! For example, to degerister simultaneously a base address and a pool: *_value = (input + 502 deposit) - transaction fee_*
====

* `--invalid-hereafter`: The slot tip of the network plus some slots to give your transaction time to get accepted by the network. Here, 1000 slots (seconds on mainnet) or ~ 15 minutes in the future, from the last query we made at `"slot": 90368116`.
* `--fee`: the exact value we calculated earlier.
* `--certificate-file`: adding a certificate to the transaction.
+
____
*Note:*  The order in which the certificates are declared will matter in the final transaction. You cannot delegate to a pool that does not exist yet. You cannot register a pool with an owner's address that is not registered yet. Hence, we register the `base.addr` (its staking part) first, then the pool and finally delegate to it.
____

[discrete]
==== Sign and send a transaction

----
cardano-cli transaction sign \
--tx-body-file ./tx.final  \
--signing-key-file ./payment.skey \
--signing-key-file ./stake.skey \
--signing-key-file ./pool.skey \
--mainnet \
--out-file tx.final.signed
----

The transaction must be signed by three private keys in this case.

* `payment.skey` will authorize spending funds from the `base.addr`.
* `stake.skey` will authorize the use of `base.addr` (its staking part) as a pool owner and authorize delegation to the pool at the same time.
* `pool.skey` will authorize the registration of the pool

____
*The address used to collect pool rewards does not need to sign this transaction. Here, it happens that we use the same address to fulfill the reward and the pledge functions. The pool owner (pledge) does not need to sign a `de-registration certificate`. Updating the pool parameters consists in sending a new `pool-registration` certificate. Deposit for the pool only occurs during the first registration.* 
____

----
cardano-cli transaction submit \
--tx-file tx.final.signed \
--mainnet
----

Congratulations ! It is all done, the pool is now registered! With some delegated stake, it will sign blocks and pay rewards to the `base.addr` (after the block producing node is started with the appropriate keys of course).

==== 	Rewards withdrawal

Eventually, with enough saturation, the pool will mint blocks and start accumulating some ada rewards. However, these ada are in the stake account associated to the `base.addr` and as such cannot be spent as UTxOs.

Let's query a random address that accumulated ada rewards:

----
cardano-cli query stake-address-info --address stake1u97v0sjx96u5lydjfe2g5qdwkj6plm87h80q5vc0ma6wjpq22mh4c --mainnet
----

----
[
    {
        "address": "stake1u97v0sjx96u5lydjfe2g5qdwkj6plm87h80q5vc0ma6wjpq22mh4c",
        "delegation": "pool1kchver88u3kygsak8wgll7htr8uxn5v35lfrsyy842nkscrzyvj",
        "rewardAccountBalance": 370751053
    }
]
----

This one contains `370751053` lovelaces or  `370.751053 ada` rewards.

A withdrawal transaction can be made to transform these ada rewards into spendable UTxO.

Again, let's estimate first the transaction fee for this:

----
cardano-cli transaction build-raw \
--tx-in 0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211#0 \
--tx-out $(cat base.addr)+0 \
--withdrawal $(cat stake.addr)+0 \
--invalid-hereafter 0 \
--fee 0 \
--out-file withdraw.draft
----

`--withdrawal`: specifies from which `stake.addr` rewards will be withdrawn from; `+` separates the address from the value withdrawn in lovelace.

____
Since we only create a fake transaction in order to calculate transaction fees, we set the value withdrawn at 0.
____

Next:

----
cardano-cli transaction calculate-min-fee \
--tx-body-file withdraw.draft  \
--tx-in-count 1 \
--tx-out-count 1 \
--witness-count 2 \
--mainnet \
--protocol-params-file pparameters.json
----

----
178525 Lovelace
----

Almost done. Let's craft the real withdrawal transaction now.

----
cardano-cli transaction build-raw \
--tx-in 0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211#0 \
--tx-out $(cat base.addr)+375572528 \
--withdrawal $(cat stake.addr)+370751053 \
--invalid-hereafter 90455278 \
--fee 178525 \
--out-file withdraw.draft
----

[IMPORTANT]
====


*All values are expressed in lovelaces.*

* The `base.addr` will receive as change : *`UTxO_value + rewards_withdrawn - transaction_fees`*
* *Rewards are withdrawn in full. Partial withdrawals are not allowed.*
* Nothing prevents the addition of extra `--tx-out` fields, as long as the transaction is balanced correctly (total input - transaction fees = total output).
====

We can now sign the transaction:

----
cardano-cli transaction sign \
--tx-body-file ./withdraw.draft  \
--signing-key-file ./payment.skey \
--signing-key-file ./stake.skey \
--mainnet \
--out-file withdraw.signed
----

Two witnesses are required:

* The `payment.sk` of the `base.addr` that pays for the transaction fee.
* The `stake.sk` of the stake.addr, to allow the withdrawal of ada rewards.

The transaction can now be sent

----
cardano-cli transaction submit \
--tx-file tx.final.signed \
--mainnet
----

== Epilogue

This guide to create a stake pool describes all `cardano-cli` actions required become an *_autonomous Stake Pool Operator_* on Cardano. Let's hope this longer-than-desired document helped shed some light on the many moving parts involved.

____
Community tooling exists today that abstracts most of the steps presented, such as the https://github.com/cardano-community/guild-operators[Guild-Operators] or the https://github.com/gitmachtl/scripts[Stake Pool Operators Scripts] repositories.

In addition, many operations that need a running instance of `cardano-node` (to query or post on the ledger) can be performed using a copycat of `cardano-cli` called https://github.com/blockfrost/blockfrost-cardano-cli[`blockfrost-cardano-cli`]. It can be sometimes faster than querying your local `cardano-node` instance!

Because handling private keys is not a small feat, it is recommended to utilize tools that use hardware wallets. One that comes to mind is `cardano-hw-cli`, a version of `cardano-cli` that leverages hardware wallets to manage both addresses and pool private keys. You can find it https://github.com/vacuumlabs/cardano-hw-cli[here].

*_Please note that such tools should not be used without a clear overview and hands-on experience of how things work. And please, do yourself a huge favor: practice on testnets if it's your first time!_*
____

== Node Monitoring (to be completed)

== Keeping Time

Ouroboros is the name of the protocol that runs Cardano, represented by the timeless symbol of the serpent eating its own tail. Until https://eprint.iacr.org/2019/838.pdf[Ouroboros Chronos] implementation is here however, the timeless Ouroboros needs stake pool operators to help it keep track of time.

Clock synchronization is typically essential in distributed networks. Nodes must avoid clock drift caused by counting time at slightly different rates from each other. In Ubuntu or other Linux distros, a plethora of Network Time Protocol (NTP) programs exist to help reduce timesync offsets to the order of a few milliseconds. A commonly used program for this is Chrony which needs to be installed and running on the computer used as a node or relay for Cardano. On Ubuntu, Chrony can be installed with `apt install chrony`.

After installing Chrony, it is recommended to configure (default config file /etc/chrony/chrony.conf) with nearby high-performant NTP servers and poll them fairly often to reduce drift from the global clock. NTP categorizes sources into stratums. In general, stratum 0 is reserved for atomic clocks or other highly accurate time measurements. Stratum 1 is useful for systems allowed to deviate within a few milliseconds from stratum 0, and so on as the stratum is increased. Stratum may be checked with the `chrony ntpdata`command. The following is an example chrony.conf configuration: 

[source, chrony.conf]
----
pool 192.168.2.100 minpoll 1 maxpoll 2 maxsources 1
pool time.cloudflare.com minpoll 3 maxpoll 4 maxsources 1
pool time.google.com minpoll 3 maxpoll 4 maxsources 1
maxupdateskew 5.0
makestep 0.1 -1
rtsync
leapsectz right/UTC
----
==== Comments on the example configuration :
* To add NTP servers add the pool with IP (such as 192.168.2.100) or DNS (such as time.google.com). 
* A low minpoll and maxpoll value means less time drift. Maxsources sets maximum sources from the pool. 
* Publicly available timesync servers from some of the larger corporations are fairly reliable and high performant such as time.cloudflare.com, time.google.com or time.facebook.com. The https://www.ntppool.org/en/[NTP pool project] also has an overview of NTP time pools all across the globe. Finally, running a local timesync server is another option to encourage decentralization. https://www.satsignal.eu/ntp/Raspberry-Pi-NTP.html[Guides exist] for those that would like to build one using a Raspberry Pi.

* In the example configuration, a local Stratum 1 GPS across LAN (192.168.2.100) is used with a fast polling rate, as well as 2 public NTP servers (stratum 3 Cloudflare and stratum 1 Google) with a slower polling rate. An overly-aggressive polling rate may result in blacklisting by public timesync servers. 

* On modern fiber connections near the timesync server, a low acceptable value for Chrony’s internal estimate on how fast or slow the computer clock runs relative to the timesync server with maxupdateskew 5.0 (down from a default skew of 1000 ppm) is recommended.

* Chrony can adjust system clocks more often than default by setting a low makestep value such as makestep 0.1 -1 meaning adjusting for a drift of 0.1 at any time such a drift occurs. NICs with an internal clock for timestamps (can be discovered using ethtool -T) may also be enabled with hwtimestamp and the interface name or * for all interfaces. 

* Drift may be checked with `chronyc tracking` and `chronyc sourcestats` to view offsets and skew. 

* Rtsync can be set to enable the kernel to periodically copy the real time clock (every 11 minutes on Linux). In case the connected timesync server does not send leap seconds in advance, it may also be set with leapsectz right/UTC. In general, it is recommended to use Coordinated Universal Time for server time as this is the established common time standard, as most GPS based timesync servers report in UTC. 

With that out of the way in a fairly short time (pun intended) a stakepool operator will be able to keep Cardano nodes collaborating well with the rest of the network in a timely manner!

== Server Security and Hardening


``Security is a state of being that is characterized by a lack of fear or anxiety about one’s physical, economic, technological, or social well-being, or about the well-being of those for whom one is responsible. To reach this state in information technology (IT), it is necessary to take all preventative measures, put security policies and procedures into place, and carry out routine security assessments to find and address potential vulnerabilities. IT security is essential to achieving this state of affairs today with the widespread use of electronic communication by safeguarding computer systems, networks, and the data they store and transmit as well as by preventing data breaches.``

'''''

In this topic, we will acknowledge the security aspects involved with becoming a stake pool operator (SPO). We will first look at the basic security principles of system administration in general, and then we will cover Cardano node security, containerized environments, how to configure secure shell (SSH), the benefits of using a virtual private network (VPN), and offer our final thoughts on stake pool security.

=== System Administration security

Some commonly used best practices in IT server administration for any project are outlined here.

*NOTE*

==== All examples listed here are just suggestions of the commands you can use on the Unix operating system (OS). Do not take anything for granted and please do your own research (DYOR) or read the command related manual (RTFM).

'''''

==== Best practice:

* Use a secure operating system with long-term support for your server to ensure that you have access to the latest security updates and patches.
* Always start with a clean minimal setup as OS hosting your Cardano environment.
* Ensure your day-to-day machine user account and cloud provider accounts have secure authentication methods, such as strong passwords and 2FA.
* Where possible, always set your server to use 2 public IPs. One for administration purposes (SSH and/or VPN) and one for the service you want to expose. This will minimize targeted attacks on your administration pipelines and leave only the services you chose to expose publicly (i.e. Webserver) as targets (this is commonly referred to as`minimizing the attack surface area`).
* It is important to be cautious when doing system administration and make sure to always have a plan, document it and test it before applying it to the production environment besides having an automated reporting system (i.e. Prometheus/Grafana). Additionally, it is always recommended to have a recovery plan in case of any incident.
* Avoid running services as root when possible, as doing so increases the risk of unauthorized access or data breaches.
* Mind the exposed services, as they can be a target for cyber attacks. Be aware of the services that are running on your server, and take steps to secure them. It is recommended to not leave any unused ports open on your server, as they can be used to gain unauthorized access to your system. Disable any unneeded open port/service or at least filter them using an adequate firewall rule. You have several options to list open ports with their associated service (some of these commands will also list services listening on 127.0.0.1 which is on the lo interface i.e. loopback): `sudo netstat -latupen` , `sudo lsof -i`, `sudo ss -antlp`.
* Implement Fail2Ban to block unauthorized access attempts or DOS attempts. This tool can help you to block/delay persistent and/or malicious IPs (port scanners/ crawlers, bruteforce techniques) from accessing your server.
* Change your server DNS to use known secure DNS (i.e. 1.1.1.1 and 1.0.0.1)
* Use a hardware/software firewall on your server and lock down the ports to only allow necessary traffic. Firewall rules can also mitigate DoS attacks and port flooding by using connlimit rules, see iptables-extensions(8) for examples. Use a firewall as a backup mechanism, after minding the open services. While a firewall can help to prevent further admin incidents, it can also increase the level of complexity and require additional specific attention.
* Keep your server’s operating system and installed software up-to-date with the latest updates to ensure that you have the latest security patches and fixes.
* Disable IPv6 on your server if you are not using it, as it can be used as a potential attack vector. Example command: `nano /etc/sysctl.conf` and add the line net.ipv6.conf.all.disable_ipv6 = 1
* Limit the programs with suid or sgid bit set, you may list them all with: `$ sudo find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l {} \;`
* An additional step to ensure that you are protected from known vulnerabilities is to conduct a vulnerability scan using a tool such as nmap. While this may not be as precise or comprehensive as a commercial vulnerability scanner, it can still provide valuable insights.
* For those using systemd services, security may be checked with systemd-analyze security. It’s possible to harden every UNSAFE or EXPOSED service without messing with the distribution service file by adding an override.conf file in /etc/systemd/system/unit.service.d/ directory (unit being the name of any systemd service). Directives (like ProtectHome, ProtectSystem, ProtectHostname, etc.) are described in systemd.exec(5). The command line to do it is `systemctl edit unit.service`.
* A quick and easy way to monitor the overall health, load, and security of your system is by using a terminal multiplexer like `tmux`, along with the `tmuxp` session manager to save and reproduce tmux sessions from YAML or JSON files. This method is lightweight, efficient, and secure for remote access via SSH, and can be used as a text-based alternative or complement to Grafana. Some examples of commands that can be used in this setup are `dmesg, journalctl, iptables, tload, htop, systemctl, or any combination of watch, tail, and grep`.

=== Node Security:

* It is highly recommended to not operate both the `Block Producer` and a `Public Relay` on the same host, as the relay is exposed to the public and if it is compromised or under attack (DOS), your block producer will also be offline, resulting in missing the opportunity to produce blocks, which can negatively impact your ranking and associated rewards. To prevent this, it is best to secure the block producer behind a firewall and only allow it to connect to the relay nodes. The relay nodes can then connect to the block producer and other peer relays.
* It is recommended to only store the essential files (such as kes.skey, vrf.skey, etc.) on your server for running the cardano-node. It is also strongly recommended to keep other files related to your wallet/pool, such as private keys, on a separate, secure, and preferrably air-gapped device.
* Additionally, it is important to avoid running any programs, including `cardano-node` and `db-sync`, with root privileges. Instead, create a non-privileged account and use it for these tasks, and this applies to both non-containerized and containerized environments.
* It is always advisable to use a hardware wallet for your Pool as it will keep your private keys safe and secure.
* It is important to keep in mind that having a proper server security is crucial to ensure the availability, integrity, and confidentiality of your blockchain network. Having a proper segregation of different functionalities and roles in different servers and using unprivileged accounts can help to reduce the risk of unauthorized access or data breaches.

'''''

=== Containerized Environments

Another option is to use containerized environments where the Cardano’s software can run logically separated from the hosting server, therefore containing possible breaches. As an added layer of security the use of such software/environment will also increase the level of IT knowledge to properly configure them.

Containerized Enviroments provides several advantages from a security point of view:

* Isolation: containers are isolated from one another and from the host system. This means that a security vulnerability or attack in one container will not affect other containers or the host system.
* Least Privilege: Each container runs with a specific set of permissions, reducing the risk of privilege escalation. This means that a malicious container will only have access to the resources it needs to function.
* Segmentation: allows for the creation of multiple isolated networks for different containers. This allows for better segmentation of different services and reduces the attack surface.
* Patching: allows for quick and easy patching of vulnerabilities in an application, without the need to patch the entire system.
* Auditing: provides detailed information about the container environment, including system calls, network connections, and file access. This information can be used to identify potential security issues and track down the source of a security incident.
* Security Scanning: provides security scanning feature and also several third party security scanning tools can be used to check images for vulnerabilities.
* Sandboxing: containers run in a Sandboxed environment, so that any malicious activity is restricted and the host system is not affected.
* Control over the environment: allows you to control the environment in which your application is running, and to ensure that it is running in a consistent and predictable environment.

It is important to keep in mind that while using containerized environments can greatly enhance security, it is not a complete solution. Adequate configuration and security measures must still be implemented within the containerized environment to guarantee the safety of your system.

A plethora of options exist that provide similar containerization functionality:

* LXC (LinuX Containers), Docker, rkt (Rocket), OpenVZ, LXD (built on top of LXC), Kubernetes, Mesos.

Please note that while these alternatives provide similar functionality, they may have different architectural designs and may require different configurations and management processes. It is essential to evaluate the needs of your organization and compare each solution before making a decision.

'''''

==== Securing SSH

Given that SSH is frequently the primary method of remote server administration, we will highlight some key security considerations for securing SSH:

. Use a different port than the default 22/tcp, such as a port over 10000/tcp for added security. Example: `nano /etc/ssh/sshd_config` and change the line `Port 22` to `Port 10022`
. Disable access to root login on the SSH config and only use unprivileged account(s) with SUDO access. Example: `sudo nano /etc/ssh/sshd_config` and change the `PermitRootLogin to no`
. Use port knocking (`knockd`) to add an additional layer of security to your SSH connections.
. Disable (or fake) banners to prevent displaying unnecessary information that could potentially be used by attackers. Example: `nano /etc/ssh/sshd_config` and change the line `Banner /etc/issue.net` to `#Banner /etc/issue.net`
. Define a number of max concurrent sessions to limit the number of simultaneous connections to your server. Example: `nano /etc/ssh/sshd_config` and add the line `MaxSessions 10`
. Add it to your fail2ban instance to delay any attempt at brute-forcing or password guessing. Example: `nano /etc/fail2ban/jail.local` and add the section `[sshd] enabled = true`
. Disable password login in SSH. It is recommended not to use username/password authentication for SSH, instead use certificate-based (PKI) authentication for added security. Don’t forget to password protect your private key when you generate it. Example: `ssh-keygen -t rsa`
. When applicable, restrict access to the only IP address you’ll be using to connect to your server. Example: `nano /etc/ssh/sshd_config` and add the line `AllowUsers user@xxx.xxx.xxx.xxx`
. Use SFTP or SCP to transfer files (over SSH) to and from your server, as it provides an added layer of security compared to FTP.
. You can use SSH tunneling to encrypt and redirect traffic within remote nodes, in order to access backend infrastructure.

It is important to keep in mind that SSH is a fundamental service that allows remote access to a server, it is crucial to have it properly configured and secured to avoid any unauthorized access to your server. It is also recommended to have a plan for monitoring and auditing SSH access (Grafana/fail2ban), as well as regular security updates and patches.

==== Use a VPN (as alternative to ssh tunneling)

Using a VPN (i.e. Wireguard) to access a server backend (Grafana/Prometheus/etc) is especially important for Stake Pool Operators (SPO) as it provides several benefits in terms of security and accessibility. A VPN (Virtual Private Network) creates a secure and encrypted connection between the client device and the server backend, protecting the data transmitted over the connection from potential eavesdropping or tampering.

This is particularly important when accessing sensitive information such as financial data, personal information, or confidential blockchain information. Additionally, a VPN allows remote access to the server backend, enabling SPOs to access the backend from anywhere in the world, as long as they have an internet connection. This can be especially useful for SPOs who are running their nodes remotely or in different locations. Furthermore, using a VPN can also help to bypass any geographical restrictions or censorship. Overall, using a VPN to access a server backend is an effective way to secure and facilitate access to sensitive information and resources for SPOs.


'''''

=== Final Thoughts

Keep your setup simple and minimize your attack surface. Being overly cautious can increase the risk of having too much to monitor, or in some cases, cut yourself off from your system. Carefully manage your risks until you feel confident in your security, while having a contingency plan in place is always wise.

Your laptop, your air-gapped system, your relay node servers, and your block producer server will all have different levels of security based on their operational and economic value and the context in which they are being used (cloud, dedicated, or bare metal and geographical location). It’s important to have a security plan in place after considering different scenarios and making decisions accordingly.

Take the time to design the infrastructure you want to set up before you begin implementing it. This will save you time in the long run for maintenance and improvement.

== Offline Operations (to be completed)

== Multi-Channel Settlement (to be completed)
