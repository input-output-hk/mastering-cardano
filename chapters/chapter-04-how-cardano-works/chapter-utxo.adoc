
=== The EUTXO model(((EUTXO model)))

==== Accounting models

Every cryptocurrency requires an _accounting model_ to track ownership, and Cardano is no exception.

One widely used option is the _account-based_ (or _balance-based_) model, where users hold accounts that store their balances, and transactions adjust those balances. This model will likely be familiar to most readers with a bank account, as it mirrors the system banks use and aligns with how many of us typically understand accounting.

Ethereum(((Ethereum))) is one example of a cryptocurrency that uses the account-based model(((account-based model))).
For instance, if Alice initially holds 100 ETH and Bob holds 10 ETH, and Alice sends 30 ETH to Bob, their balances would be updated as follows:

.Alice sends 30 ETH to Bob in the account-based model(((account-based model)))
image::Alice_sends_30_ETH_to_Bob.png[]

==== The UTXO(((unspent transaction output (UTXO)))) Model

The account-based model(((account-based model))) is not the only option, nor is it used by Cardano. Instead, Cardano follows Bitcoin(((Bitcoin)))'s _UTXO model_ and extends it to the _extended UTXO(((unspent transaction output (UTXO)))) model (EUTXO)_.

The term 'UTXO(((unspent transaction output (UTXO))))' is an acronym for _unspent transaction(((transaction))) output_ and denotes just that: the output of a transaction(((transaction))) that has not yet been spent.

_Transactions_ are the fundamental building blocks of all blockchains, regardless of the accounting model(((accounting model))) they employ. Transactions(((transaction))) trigger changes and facilitate actions. However, while the account-based model(((account-based model))) updates balances, the UTXO(((unspent transaction output (UTXO)))) model spends previously unspent outputs(((transaction, output))) from past transactions and generates new unspent outputs(((transaction, output))).

Transactions(((transaction))) in the UTXO(((unspent transaction output (UTXO)))) model have one or more _inputs_ and one or more _outputs_. Each input spends an existing UTXO(((unspent transaction output (UTXO)))) (thereby rendering it ‘spent’), while each output creates a new UTXO(((unspent transaction output (UTXO)))), which can later be used as input for another transaction(((transaction))).

You can think of unspent transaction(((transaction))) outputs(((transaction, output))) as ‘coins’ or ‘banknotes’ that can be spent in future transactions. When you receive a payment, you receive a new coin or banknote, which you can use in a future transaction(((transaction))). When you spend money, you hand over coins or banknotes you received in the past.

In a sense, the UTXO(((unspent transaction output (UTXO)))) model is finer-grained than the account-based model(((account-based model))) – it tracks each ‘coin or banknote’ rather than just total balances.

The UTXO(((unspent transaction output (UTXO)))) model resembles cash, whereas the account-based model(((account-based model))) is more like a bank account. When paying with cash, you hand over whole banknotes or coins, which are unspent outputs(((transaction, output))) from past transactions (when someone paid you). UTXOs work the same way – they must be spent in full, just like coins or banknotes. If you don’t have the exact amount, you hand over more and receive change(((change))) in return.

In the UTXO(((unspent transaction output (UTXO)))) model, this change(((change))) is called a _change output_, where one or more outputs(((transaction, output))) from a transaction(((transaction))) typically return to yourself.

However, the analogy with cash is not perfect. While you must spend entire UTXOs, you can create new UTXOs with arbitrary values, provided the total value(((value))) of the new UTXOs does not exceed the value(((value))) of the UTXOs being spent. This differs from cash transactions, where you cannot simply create new banknotes or coins.

[example]
======
For example, if you have an input ‘coin’ worth 100 ada(((ADA))), you can create two outputs(((transaction, output))): one worth 70 ada(((ADA))) and another worth 30 ada(((ADA))). You cannot do this with cash, where splitting a banknote into smaller denominations is impossible without receiving change(((change))) from a third party.
======

[example]
======
Let’s reconsider the example of Alice and Bob using the UTXO(((unspent transaction output (UTXO)))) model: Alice has 100 ada(((ADA))) split between two UTXOs – one worth 60 ada(((ADA))) and the other worth 40 ada(((ADA))). Bob has a single UTXO(((unspent transaction output (UTXO)))) worth 10 ada(((ADA))).

If Alice wants to send 30 ada(((ADA))) to Bob, she can create a transaction(((transaction))) using one of her UTXOs, for instance, the 40 ada(((ADA))) UTXO(((unspent transaction output (UTXO)))). The transaction(((transaction))) will have two outputs(((transaction, output))): one output worth 30 ada(((ADA))) to Bob and another worth 10 ada(((ADA))) as change(((change))) back to Alice.

Alternatively, Alice could use her 60 ada(((ADA))) UTXO(((unspent transaction output (UTXO)))) and send 30 ada(((ADA))) back to herself. She could also combine both her UTXOs (60 ada(((ADA))) and 40 ada(((ADA)))) as inputs(((transaction, input))) and create one or more change(((change))) outputs(((transaction, output))), such as 70 ada(((ADA))) total, or even split it into two outputs(((transaction, output))) like 50 ada(((ADA))) and 20 ada(((ADA))), as long as they sum up to 70 ada(((ADA))).

Even with this simple example, Alice has numerous ways to structure her transaction(((transaction))). The key is that the sum of the output values must match the sum of the input values, with the outputs(((transaction, output))) to Bob adding up to 30 ada(((ADA))) and the change(((change))) outputs(((transaction, output))) reflecting the remaining balance.

======

While this process sounds complex, in practice, users don't need to worry about the details – wallets handle it automatically. They select the appropriate UTXOs as inputs(((transaction, input))) and create the correct transaction(((transaction))) outputs(((transaction, output))). This process of selecting the right inputs(((transaction, input))) is known as _coin selection_.

Coin selection works similarly to choosing the right coins and banknotes from a physical wallet when paying with cash – you don't want too many coins cluttering your wallet, you avoid receiving too many small coinsfootnote:[In the cryptocurrency context(((context))), small-value(((value))) UTXOs are known as _dust_. ] as change(((change))), but you also don’t want to use up all your small change(((change))). Wallets aim to strike a balance between these competing objectives.

.Alice sends 30 ada(((ADA))) to Bob in the UTXO(((unspent transaction output (UTXO)))) model
image::Alice_sends_30_ADA_to_Bob.png[]

It is important to note that this example is simplified. In reality, Alice would also need to account for _transaction fees_(((transaction, fees))), which means the change(((change))) outputs(((transaction, output))) returning to her would be slightly less than the difference between her inputs(((transaction, input))) and the 30 ada(((ADA))) sent to Bob.

In the pure UTXO(((unspent transaction output (UTXO)))) model, outputs(((transaction, output))) consist of an _address_ and a _value_. The address(((address))) – which, in Cardano’s case, includes a _PubKey Hash_ (the hash of a verification key)(((verification key))) – specifies who is allowed to spend the output later. To spend this output, transactions must be _signed_ using the corresponding signing key(((signing key))), and multiple signing keys can be used.

The _value_ represents an arbitraryfootnote:[A certain minimum amount of ada(((ADA))) – _minimum deposit_, which always needs to be included.] combination of ada(((ADA))) and native tokens(((Cardno, native tokens))).

Cardano transactions must be _balanced_ – roughly speaking, the sum of input values must equal the sum of output values. There are some exceptions and refinements to this simple rule:

    * Each transaction(((transaction))) needs to include _transaction fees_(((transaction, fees))),
      which get subtracted from the input values before being compared to the output values
    * Cardano native tokens(((Cardano, native tokens))) can be _minted_ (created) or _burnt_ (destroyed) in a transaction(((transaction)))
    * Staking rewards can be withdrawn, getting added to the outputs(((transaction, output))) without having compensating
      inputsfootnote:[These staking(((staking))) rewards come from an internal reward account, not a regular UTXO(((unspent transaction output (UTXO)))).].

===== About change

Change is essential for a transaction(((transaction))) to have any real-world effect. Without it, a transaction(((transaction))) serves no purpose. In the account-based model(((account-based model))), change is in the account balances. For those familiar with imperative programming, account balances in this model are like _global_ variables(((global variables))) that get updated by transactions. In the UTXO(((unspent transaction output (UTXO)))) model, change happens within the set of UTXOs – some UTXOs are spent, and new ones are created. However, no output is ever modified. Once created, an output remains unchanged permanently. The transaction(((transaction)))’s effect lies solely in consuming existing outputs(((transaction, output))) and generating new ones. For those familiar with functional programming, UTXOs are comparable to _immutable_ data structures(((immutable data structures))), which are _consumed_ but never modified by transactions.

In the example above, before Alice sends 30 ada(((ADA))) to Bob, the UTXO(((unspent transaction output (UTXO)))) set consists of Alice's two UTXOs (60 ada(((ADA))) and 40 ada(((ADA)))) and Bob's UTXO(((unspent transaction output (UTXO)))) of 10 ada(((ADA))).

.The old UTXO(((unspent transaction output (UTXO)))) set before Alice's transaction(((transaction)))
image::change_before_utxo.png[]

Alice’s transaction(((transaction))) consumes her UTXO(((unspent transaction output (UTXO)))) worth 40 ada(((ADA))) and generates two new UTXOs – one worth 30 ada(((ADA))) sent to Bob and another worth 10 ada(((ADA))) returned to Alice.

So while no individual output changes, the _set_ of unspent outputs(((transaction, output))) changes – one output is removed from the set (because it is now _spent_), and two new ones are added.

.The new UTXO(((unspent transaction output (UTXO)))) set after Alice's transaction(((transaction)))
image::change_after_utxo.png[]

Of course, there may be many more UTXOs on the blockchain that are not considered here, but they have no impact on the specific transaction(((transaction))) examined here.

==== Extending it: the EUTXO model(((EUTXO model)))

The UTXO(((unspent transaction output (UTXO)))) model is simple and elegant, allowing users to send and receive funds without restriction.

​​​​These days, however, users expect more from a blockchain than just the ability to send and receive funds. They want to create smart contracts(((smart contract))) that can do more than merely move funds; they seek the ability to implement arbitrary logic and enforce complex rules. They also want to create fungible(((fungible))) or non-fungible(((non-fungible))) tokens (NFTs)(((non-fungible, token (NFT)))) and trade them on decentralized exchanges(((decentralized exchanges))) or sell them on decentralized marketplaces(((decentralized marketplaces))).

In the UTXO(((unspent transaction output (UTXO)))) model, a transaction(((transaction))) can spend inputs(((transaction, input))) locked at a specific address(((address))) if it is signed(((signed))) by the corresponding signing key(((signing key))).

In the extended UTXO(((unspent transaction output (UTXO)))) model(((EUTXO model))), this concept is generalized by replacing the requirement for specific signatures with arbitrary logic.

In addition to using hashed public keys as part of addresses, the EUTXO model(((EUTXO model))) introduces addresses that contain hashed _scripts_, written in a programming language (_Plutus Core_ in the case of Cardano).

During validation(((validation))), when a transaction(((transaction))) has an input at a script(((script))) address(((address))), the corresponding script(((script))) (also referred to as a _validator_ in this context(((context)))) is executed. If the script(((script))) execution completes without error, spending the input is considered valid; otherwise, it is deemed invalid.

To make this idea work, three additional components are needed:

* In the UTXO(((unspent transaction output (UTXO)))) model, a transaction(((transaction))) output consists of an address(((address))) and a value(((value))). The EUTXO model(((EUTXO model))) adds a third component – a piece of data called a datum(((datum))).footnote:[Adding a datum(((datum))) to an output is optional, but outputs(((transaction, output))) at script(((script))) addresses without a datum(((datum))) are unspendable. Datums can also be added to public key addresses.]

* A transaction(((transaction))) attempting to spend an output at a script(((script))) address(((address))) must include another piece of data in the input, known as the _redeemer_. The redeemer(((redeemer))) acts as a ‘key’ to ‘unlock’ an input – a generalization of the signature used to unlock outputs(((transaction, output))) at public key addresses.

* When a Plutus Core(((Plutus Core))) script(((script))) is executed for validation(((validation))), it receives the datum(((datum))), redeemer(((redeemer))), and  _context_ as arguments. The context(((context))) contains the transaction(((transaction))) being validated along with all its inputs(((transaction, input))) and outputs(((transaction, output))), but no other information.

This design strikes a balance between expressiveness and security:

* Bitcoin(((Bitcoin))) provides smart contract capabilities through _Bitcoin script_, but these scripts(((script))) can only access the output being validated and the Bitcoin(((Bitcoin))) equivalent of a redeemer(((redeemer))), not the entire transaction(((transaction))) with all inputs(((transaction, input))) and outputs(((transaction, output))). As a result, Bitcoin(((Bitcoin))) script(((script))) is highly limited and cannot support the sophisticated smart contracts(((smart contract))) that users expect from blockchains like Ethereum(((Ethereum))).

* Ethereum(((Ethereum))) smart contracts(((smart contract))) are powerful and flexible but also extremely challenging to implement correctly. Their context(((context))) encompasses the entire state of the blockchain, complicating the prediction of execution outcomes. This has led to several notorious exploits and bugs, resulting in the unexpected loss of millions of ether.


Cardano's EUTXO model(((EUTXO model))), incorporating datums, redeemers, and contexts, is both powerful and flexible enough to match the capabilities of Ethereum(((Ethereum))) while remaining simple enough to enhance predictability regarding transaction(((transaction))) outcomes.

Cardano transactions can be validated _locally_, without needing to submit them to the blockchain first, since the context(((context))) includes only the transaction(((transaction))) itself along with its inputs(((transaction, input))) and outputs(((transaction, output))). Although a transaction(((transaction))) may fail upon submission – such as when another transaction(((transaction))) has already spent an expected input – if it succeeds, it will yield the predicted result.

As a result, Cardano transactions incur a fee(((transaction, fees))) only if they succeed and are included in the blockchain. In contrast, Ethereum(((Ethereum))) transactions can fail yet still cost gas. This scenario is unlikely to occur on Cardano, provided users adhere to the established safety mechanisms.

Transaction determinism(((determinism))) is extremely important and deserves further explanation:

On a blockchain like Ethereum(((Ethereum))), the outcome of a transaction(((transaction))) can potentially be influenced by _any_ activity occurring on the blockchain. This makes it impossible to determine the effect of a transaction(((transaction))) off-chain before submission.

In contrast, on a blockchain using the EUTXO model(((EUTXO model))), the outcome of a transaction(((transaction))) is solely determined by the transaction(((transaction))) itself, its inputs(((transaction, input))) and outputs(((transaction, output))), and nothing else. Therefore, it _is_ possible to predict the effect of a transaction(((transaction))) off-chain before submission.

As mentioned above, the only aspect that may change on an EUTXO blockchain is the set of UTXOs. However, the outputs(((transaction, output))) themselves remain immutable. A transaction(((transaction))) may encounter a situation where its inputs(((transaction, input))) are consumed by other transactions before it is submitted, leading to failure without incurring a fee(((transaction, fees))). Nonetheless, if all inputs(((transaction, input))) remain unspent, the transaction(((transaction))) will produce the predicted outcome.

One exception to this rule – related to the handling of time(((time))) – will be discussed later.

[[atomic-swaps]]
===== Atomic swaps

Let's clarify this with an example – _atomic swaps_.

We have mentioned _native tokens_ and NFTs before, and we will explore them in more detail later, but for now, let's discuss a simple example.

Let's say Alice is the owner of an NFT, and she is willing to sell it to Bob for 100 ada(((ADA))).

She doesn't necessarily trust Bob, so she doesn't just want to send her NFT to Bob and hope he will pay her 100 ada(((ADA))) later.

Likewise, Bob doesn't trust Alice and doesn't want to send her 100 ada(((ADA))), hoping she will send him the NFT afterward.

This problem can be addressed using the UTXO(((unspent transaction output (UTXO)))) model, even without smart contracts(((smart contract))). For instance, Alice or Bob can create a transaction(((transaction))) with two inputs(((transaction, input))): Alice's NFT and Bob's 100 ada(((ADA))). The outputs(((transaction, output))) would be 100 ada(((ADA))) for Alice and the NFT for Bob. Alice can then partially sign the transaction(((transaction))) and send it to Bob off-chain (for example, via email). Bob can subsequently add his signature and submit the transaction(((transaction))) to the blockchain.

This approach is secure because neither party can submit the transaction(((transaction))) without the other's signature. Additionally, Bob cannot manipulate the transaction(((transaction))) to his advantage prior to signing, as doing so would invalidate Alice's signature.

This transaction(((transaction))) exemplifies an _atomic swap_ – it facilitates the exchange of Alice's NFT and Bob's 100 ada(((ADA))) ‘atomically,’ without requiring trust. Either Alice receives her 100 ada(((ADA))), and Bob receives the NFT, or neither party completes the transaction(((transaction))).

.Alice and Bob perform an atomic swap(((atomic swap))) in the UTXO(((unspent transaction output (UTXO)))) model
image::atomic_swap_utxo.png[]

This approach has at least two issues: first, the partially signed(((signed))) transaction(((transaction))) must be sent off-chain, which is not ideal and can be cumbersome for users. Second, Alice must find Bob and agree on the terms of the swap, which again requires an off-chain process.

Within the EUTXO model(((EUTXO model))), this can be enhanced by employing a script(((script))) to enforce the swap's terms. Alice can create a transaction(((transaction))) that spends her NFT and generates an output locked by a script(((script))) that requires _someone_ (potentially Bob, but Alice does not need to specify) to send 100 ada(((ADA))) to Alice to unlock it.

So how does this work?

.Alice has an NFT she wants to sell
image::atomic_swap_eutxo_1.png[]

Alice creates an atomic-swap script(((script))), sends her NFT to the corresponding _script address_ (given by the hash of the script(((script)))), and sets the price (100 ada(((ADA))) in our example) within the _datum_ of the output.

.Alice locks her NFT in a script(((script))) output guarded by the atomic-swap script(((script)))
image::atomic_swap_eutxo_2.png[]

To unlock that UTXO(((unspent transaction output (UTXO)))) and spend it, the script(((script))) will verify that the spending transaction(((transaction))) includes an output of 100 ada(((ADA))) directed to Alice. The script(((script))) can 'see' the entire spending transaction(((transaction))) (but nothing beyond that), allowing it to check for an output of 100 ada(((ADA))) to Alice.

In practice, the script(((script))) will likely also enable Alice to reclaim her NFT at any time(((time))). Without this functionality, she might encounter difficulties retrieving her NFT if no one expresses interest in purchasing it.

Anyone will be able to spend this UTXO(((unspent transaction output (UTXO)))) and obtain Alice's NFT, provided they also send 100 ada(((ADA))) to Alice.

.Alice and Bob perform an atomic swap(((atomic swap))) in the EUTXO model(((EUTXO model)))
image::atomic_swap_eutxo_3.png[]

In this example, Alice ceases control of her NFT by sending it to a script(((script))) address(((address))) while ensuring that she will receive 100 ada(((ADA))) if someone other than herself wishes to spend that UTXO(((unspent transaction output (UTXO)))).

Note that in this case, the second transaction(((transaction))) only requires a signature from Bob to authorize the spending of the 100 ada(((ADA))) that belongs to him. Spending the NFT is permitted by executing the script(((script))), rather than requiring anyone to sign the transaction(((transaction))).

Later, we will discuss a potential issue with this smart contract, known as the _double satisfaction_ problem, but it can be effectively resolved within the EUTXO model(((EUTXO model))).

===== Validation

So far, we have briefly touched on how Cardano nodes validate transactions.

Validation occurs in two _phases_.

====== Phase 1

The first phase consists of ‘cheap’, quick checks. These checks do not incur a fee(((transaction, fees))), even if they fail. They include, but are not limited to, the ‘indeterministic’ aspects of validation(((validation))) – things that cannot be verified before submission.

One such check concerns the availability of inputs(((transaction, input))): a transaction(((transaction))) is only valid if all its inputs(((transaction, input))) remain _unspent_. It is possible for a transaction(((transaction)))'s inputs(((transaction, input))) to be consumed between its creation and submission and the time(((time))) when a node validates it. This means that while the transaction(((transaction))) may appear valid upon submission, it can become invalid if a concurrent transaction(((transaction))) spends one of its inputs(((transaction, input))) before it is included in a block.

Another check is the _balance check_: the sum of input values must equal the sum of output values minus transaction fees(((transaction, fees))) (ignoring the minting or burning of _native tokens_ for simplicity). This check is deterministic and can be performed before submission.

Transactions(((transaction))) also include a _validity interval_, specifying a time(((time))) range within which the transaction(((transaction))) is valid. Both ends of this interval can either be unrestricted or tied to specific slots. For a transaction(((transaction))) to be valid, the block’s slot must fall within this interval, so during validation(((validation))), the node ensures this condition is met before including the transaction(((transaction))) in a block.

.Validity intervals
image::validity_intervals.png[]

Each transaction(((transaction))) also includes a set of _required signatures_, which nodes verify during the first validation(((validation))) phase to ensure that all the necessary signatures are present.

====== Phase 2

The second validation(((validation))) phase is more costly, but it is only performed after all phase 1 checks have passed. This phase can also be conducted off-chain before the transaction(((transaction))) is submitted.

In this phase, scripts(((script))) are executed. Most importantly, if a transaction(((transaction))) attempts to spend script(((script))) inputs(((transaction, input))), the corresponding scripts(((script))) are evaluated one by one. If any script(((script))) fails, the entire transaction(((transaction))) is deemed invalid, and validation(((validation))) fails.

As we will discuss later, scripts(((script))) are also used in other contexts, such as native tokens(((Cardano, native tokens))) and staking(((staking))), and all related scripts(((script))) are executed during this validation(((validation))) phase.


====== Script outputs(((transaction, output)))

To execute scripts(((script))) during phase 2 validation(((validation))), nodes must _have_ these scripts(((script))). Since script(((script))) addresses are determined by the _hash_ of the script(((script))) rather than the script(((script))) itself, the transaction(((transaction))) must include all relevant scripts(((script))), as it is practically impossible to reverse the hashing process and recover the script(((script))) from its hash.

However, including scripts(((script))) directly in transactions can lead to duplication on the blockchain and larger transaction(((transaction))) sizes, especially when the same script(((script))) is reused multiple times.

To mitigate this, Cardano introduced _script outputs_. In addition to address(((address))), value(((value))), and datum(((datum))), an output can optionally include a script(((script))). Transactions(((transaction))) can then reference these script(((script))) outputs(((transaction, output))) instead of including the entire script(((script))), as long as a relevant script(((script))) output already exists.

The decision to create a script(((script))) output depends on the expected usage of the script(((script))):

- If the script(((script))) is only used once, creating a script(((script))) output is unnecessary.
- If the script(((script))) is reused frequently, creating a script(((script))) output can be beneficial. Although the initial transaction(((transaction))) with the script(((script))) output may be larger and more expensive, future transactions referencing that script(((script))) will be smaller and cheaper.


====== Collateral

It is technically possible to force the submission of a transaction(((transaction))) that will fail during phase 2 validation(((validation))), although there is never a legitimate reason to do so. When this occurs, nodes must perform unnecessary and resource-intensive work.

To discourage this, transactions requiring phase 2 validation(((validation))), such as those attempting to spend a script(((script))) input, must include _collateral_. This is an input from a `PubKey` address(((address))) that holds a minimum amount of ada(((ADA))). If phase 2 validation(((validation))) fails, the collateral(((collateral))) is forfeited.

However, in practice, this scenario is unlikely to happen because invalid transactions typically fail earlier, preventing unnecessary validation(((validation))) if users follow the standard processes.

====== Determinism and time(((time)))

As mentioned earlier, _determinism_ is a key feature of transactions in the EUTXO model(((EUTXO model))): the outcome of a transaction(((transaction))) is determined solely by the transaction(((transaction))) itself, its inputs(((transaction, input))), and its outputs(((transaction, output))).

However, certain smart contracts(((smart contract))) must account for _time_. For example, a _vesting contract_ aims to release funds only after a specified period.

This raises a question: how can a transaction(((transaction))) that depends on time(((time))) remain deterministic? The success of the unlocking transaction(((transaction))) clearly depends on whether the appropriate amount of time(((time))) has elapsed; if enough time(((time))) has passed, the transaction(((transaction))) succeeds, and if not, it fails.

The solution lies in the concept of the _validity interval_, which is included in every transaction(((transaction))).

Since phase 2 validation(((validation))) occurs only after phase 1 has succeeded, and phase 1 checks the validity interval(((validity interval))), a script(((script))) can safely assume that the transaction(((transaction)))'s validity interval(((validity interval))) includes the current time(((time))). While the script(((script))) does not ‘know’ the exact time(((time))), the current time(((time))) is guaranteed to fall within the specified validity interval(((validity interval))).

This ensures that the script(((script)))'s execution remains completely deterministic, even though it takes time(((time))) into account.

====== A vesting example

Consider the example of creating a vesting contract(((vesting contract))) that restricts spending until after January 1, 2050.

In this case, the script(((script))) must check that the _start_ of the transaction(((transaction)))'s validity interval(((validity interval))) is after January 1, 2050.

While the script(((script))) does not know the exact current time(((time))), it does know that the current time(((time))) falls within the validity interval(((validity interval))). Therefore, if the interval starts after January 1, 2050, the current time(((time))) must also be after that date.

If the validity interval(((validity interval))) starts before January 1, 2050, the script(((script))) will fail, since the current time(((time))) _could_ be before that date. Even if the current time(((time))) is after January 1, 2050, the script(((script))) cannot verify this with certainty and will therefore reject the transaction(((transaction))).


.Vesting example
image::vesting_example.png[]

===== Composability

One of the key strengths of the EUTXO model(((EUTXO model))) is the _composability_ of smart contracts(((smart contract))).

In the account-based model(((account-based model))), while smart contracts(((smart contract))) can interact with each other, these interactions can be unpredictable and may lead to unintended outcomes.

In the EUTXO model(((EUTXO model))), each script(((script))) output is protected by its validator(((validator))). Although different outputs(((transaction, output))) can be governed by the same script(((script))), they can also have separate validators. Each validator(((validator))) independently decides whether the transaction(((transaction))) meets the conditions to spend the input it protects without depending on other validators. As a result, well-constructed scripts(((script))) can easily be combined in a transaction(((transaction))) without concerns about unforeseen interactions.

Let’s recall the <<atomic-swaps, atomic swaps(((atomic swaps)))>> example:

Suppose Alice has several NFTs she wants to sell and creates a script(((script))) output secured by the atomic-swap script(((script))) for each of them. Bob can then create a transaction(((transaction))) that spends all the outputs(((transaction, output))) containing the NFTs he wishes to purchase and generates payment outputs(((transaction, output))) for each of them.

.Bob buys two NFTs from Alice in a single transaction(((transaction)))
image::atomic_swap_combined.png[]

Combining multiple atomic swaps(((atomic swaps))) into one transaction(((transaction))) does not require explicit implementation in the atomic-swap script(((script))); it is a natural consequence of how the EUTXO model(((EUTXO model))) works.

====== The double satisfaction problem(((double satisfaction problem)))

As previously mentioned, there is a challenge with the atomic-swap script(((script))) known as the double satisfaction problem(((double satisfaction problem))).

Let’s recall the example of Alice and Bob, this time(((time))) assuming that Alice changes the price of NFT C from 300 ada(((ADA))) to 200 ada(((ADA))).

.Bob buys two NFTs from Alice, but for different prices
image::double_satisfaction_1.png[]

This looks fine, and both Alice and Bob get what they want.

Unfortunately, Bob can instead do the following and cheat Alice out of 200 ada(((ADA))):

.Bob cheats Alice by making one payment for two NFTs
image::double_satisfaction_2.png[]

So instead of creating one payment output to Alice for each NFT he buys from her, Bob only creates a single payment output, thus paying 200 ada(((ADA))) instead of 400 ada(((ADA))).

His transaction(((transaction))) (Tx 2) will validate correctly: as explained above, the scripts(((script))) guarding the NFTs will be executed sequentially:

- The script(((script))) for NFT B will check whether the transaction(((transaction))) contains a payment output to Alice worth 200 ada(((ADA))), find it, and validate the transaction(((transaction))).
- The script(((script))) for NFT C will do the same, verifying _the same_ payment output to Alice and also validating the transaction(((transaction))).

This issue arises from how validation(((validation))) works during phase 2 – all validator(((validator))) scripts(((script))) run sequentially and independently, lacking a mechanism to share information between them. Consequently, the first script(((script))) cannot ‘mark’ the payment output it finds or ‘claim it for itself.’

Note that this situation can also occur in real life. For example, Alice runs a mail order business, and Bob orders one item for 200 USD at the beginning of the month. Later that month, he orders another item for 200 USD.

Alice sends him two invoices, but Bob only pays one. At the end of the month, Alice reviews her accounts and checks whether all invoices have been paid. She examines the first invoice, sees an incoming payment of 200 USD, and marks it as paid. Later, she checks the second invoice, sees the same incoming payment of 200 USD, and marks that invoice as paid as well.

Why does this not cause problems in ‘real life’? Because Alice will likely include an order number or invoice number in her invoice, which Bob must reference in his payment. This way, Alice can identify which payment corresponds to each invoice.

Bob cannot cheat because he must include the invoice number with his payment, but he cannot include both invoices. Therefore, he cannot get away with making only one payment.

Fortunately, we can apply the same principle to fix the atomic-swap contract and secure it against the double satisfaction problem(((double satisfaction problem))).footnote:[The solution to the double satisfaction problem(((double satisfaction problem))) presented here is not the only option. For example, one could modify the atomic-swap script(((script))) to allow only one input from the corresponding script(((script))) address(((address))). However, this would hinder composability(((composability))).]

Instead of merely searching for a payment output to Alice with the correct price, the script(((script))) can look for such an output that also includes the _UTXO reference_ footnote:[On Cardano, the UTXO(((unspent transaction output (UTXO)))) reference is represented by a pair consisting of the hash of the transaction(((transaction))) that created the output and the index of that output in the list of all outputs(((transaction, output))) of that transaction(((transaction))). The first output has index #0, the second output has index #1, and so on.] of the NFT output in its datum(((datum))).
Remember that any output can carry a datum(((datum))), not just script(((script))) outputs(((transaction, output))).

UTXO(((unspent transaction output (UTXO)))) references are unique on the blockchain; no two different UTXOs can have the same reference. In our example, the output containing NFT B will have a reference distinct from the one for NFT C. To satisfy validation(((validation))) for spending the output containing NFT B, Bob must include a payment output to Alice that contains the UTXO(((unspent transaction output (UTXO)))) reference of the output for NFT B in its datum(((datum))). The same requirement applies to the output for NFT C. Since these two references differ, Bob can no longer cheat by providing only a single payment output to Alice.

.Bob buys two NFTs from Alice with no way of cheating
image::double_satisfaction_3.png[]

====== Flash loans

The composability(((composability))) of smart contracts(((smart contract))) in the EUTXO model(((EUTXO model))) often results in unexpected features ‘for free’ that would need to be explicitly implemented in other models.

As discussed earlier, one example is the ability to combine atomic swaps(((atomic swaps))) into a single transaction(((transaction))).

Another example is _flash loans_. A flash loan(((flash loan))) is a loan taken out and repaid within the same transaction(((transaction))). On Ethereum(((Ethereum))), the popular decentralized exchange (DEX) Uniswap(((Uniswap))) offers flash loans(((flash loans))) as a special feature that required explicit implementation in its smart contract code.

Our simple atomic-swap script(((script))) enables flash loans(((flash loans))) ‘out of the box’, without the need for explicit implementation.

For instance, suppose Alice wants to sell 100 ada(((ADA))) for 45 DJED(((DJED))), and Bob wants to sell 50 DJED(((DJED))) for 100 ada(((ADA))). Both Alice and Bob use the simple atomic-swap script(((script))) to list their offers on the Cardano blockchain.

.Alice and Bob offer atomic swaps(((atomic swaps)))
image::flash_loan_1.png[]

Charlie notices both offers and realizes he could make a profit by temporarily borrowing 45 DJED(((DJED))):

- Charlie takes out a loan of 45 DJED(((DJED)))
- He uses those 45 DJED(((DJED))) to buy 100 ada(((ADA))) from Alice
- He then uses the 100 ada(((ADA))) to buy 50 DJED(((DJED))) from Bob
- Finally, he repays the loan and receives a 5 DJED(((DJED))) profit.

Charlie can complete this entire process in a single transaction(((transaction))) on Cardano without needing to explicitly borrow funds.

.Charlie uses an automatic flash loan(((flash loan))) to earn 5 DJED(((DJED)))
image::flash_loan_2.png[]

During phase 2 validation(((validation))), the script(((script))) guarding Alice’s 100 ada(((ADA))) checks for a payment output to Alice of 45 DJED(((DJED))) with the correct reference, finds it, and approves the transaction(((transaction))).

Similarly, the script(((script))) guarding Bob’s 50 DJED(((DJED))) checks for a payment output to Bob of 100 ada(((ADA))) with the correct reference and allows the transaction(((transaction))).

The transaction(((transaction))) is balanced(((transaction, balanced))) (100 ada(((ADA))) + 50 DJED(((DJED))) go in, 100 ada(((ADA))) + 45 DJED(((DJED))) + 5 DJED(((DJED))) go out), so validation(((validation))) succeeds, leaving Alice, Bob, and Charlie satisfied, each receiving what they wanted.

==== Beyond validation(((validation))): other uses of smart contracts(((smart contract)))

One way to understand the transition from the UTXO(((unspent transaction output (UTXO)))) model to the EUTXO model(((EUTXO model))) is by examining addresses. In the UTXO(((unspent transaction output (UTXO)))) model, whenever a transaction(((transaction))) tries to spend a UTXO(((unspent transaction output (UTXO)))), it must be signed(((signed))) using the signing key(((signing key))) corresponding to the address(((address))). The EUTXO model(((EUTXO model))) introduces script(((script))) addresses, meaning that transactions trying to spend outputs(((transaction, output))) from script(((script))) addresses must be validated by the corresponding script(((script))).

The address(((address))) of a UTXO(((unspent transaction output (UTXO)))) determines how spending it is validated. By moving from the UTXO(((unspent transaction output (UTXO)))) model to the EUTXO model(((EUTXO model))), a new method for validating inputs(((transaction, input))) is added – by executing scripts(((script))).

On Cardano, however, addresses not only define how UTXOs are _spent_ but also determine if and how the UTXO(((unspent transaction output (UTXO)))) is _staked_.

To better understand this, we need to look closely at the ‘anatomy’ of Cardano Shelleyfootnote:[There is an older type of address(((address))) on Cardano, known as a _Byron address_, introduced during the first era of Cardano, the Byron era(((Byron, era))). Shelley addresses(((Shelley, address))) were introduced in the Shelley era(((Shelley, era))). In the Byron era(((Byron, era))), Cardano used the plain UTXO(((unspent transaction output (UTXO)))) model without staking(((staking))), so Byron addresses are not discussed in this chapter.] addresses and their relation to staking(((staking))).

===== The anatomy of a Cardano address(((address)))

Every address(((address))) contains a _spending_ or _payment_ part(((address, spending part))), which dictates the conditions under which a UTXO(((unspent transaction output (UTXO)))) at that address(((address))) can be spent:

* If the payment part(((address, payment part))) of an address(((address))) is represented by a _payment public key hash_ – the hash of a _payment verification key_ – then any transaction(((transaction))) attempting to spend a UTXO(((unspent transaction output (UTXO)))) from that address(((address))) must be signed(((signed))) by the corresponding _payment signing key_.

* Alternatively, the payment part(((address, payment part))) of an address(((address))) can be represented by the hash of a _script_, in which case the script(((script))) is executed when validating a transaction(((transaction))) attempting to spend a UTXO(((unspent transaction output (UTXO)))) at that address(((address))).

So far in this chapter, we have focused only on this mandatory payment part(((address, payment part))) of an address(((address))).

On Cardano, however, every (Shelley) address(((address))) may also include an optional _staking_ part, known as _staking credentials_. Like the payment part(((address, payment part))), the staking(((staking))) part can either be a _staking public key hash_ – the hash of a _staking verification key_ – or a _script hash_.

As a result, Cardano supports six different types of addresses:

[cols="1,1"]
|===
|Payment part |Staking part

|Payment PubKey hash
|No staking(((staking)))

|Script hash
|No staking(((staking)))

|Payment PubKey hash
|Staking PubKey hash

|Script hash
|Staking PubKey hash

|Payment PubKey hash
|Script hash

|Script hash
|Script hash
|===

While the payment part(((address, payment part))) of an address(((address))) defines the conditions under which a UTXO(((unspent transaction output (UTXO)))) at that address(((address))) can be spent, the staking(((staking))) part determines whether the ada(((ADA))) in a UTXO(((unspent transaction output (UTXO)))) is _staked_ to a stake pool and, if so, to which one. Staked ada(((ADA))) earns staking rewards(((staking, rewards))).

Beyond consuming inputs(((transaction, input))) and producing outputs(((transaction, output))), Cardano transactions can also handle _staking certificates_, _delegation certificates_, and _withdraw rewards_.

Once a staking(((staking))) certificate is registered for specific staking(((staking))) credentials and a delegation certificate is created for a stake pool, staking(((staking))) rewards accumulate and can be withdrawn later.

All staking(((staking)))-related actions must be validated, similar to UTXO(((unspent transaction output (UTXO)))) spending:

- A transaction(((transaction))) that performs a staking(((staking)))-related action for staking(((staking))) credentials given by a staking public key hash(((staking, public key hash))) must be signed(((signed))) by the corresponding staking signing key(((staking, signing key))).

- A transaction(((transaction))) that performs a staking(((staking)))-related action for staking(((staking))) credentials given by a script(((script))) hash must be validated by the corresponding script(((script))), which is evaluated during phase 2 validation(((validation))).

===== Cardano native tokens(((Cardano, native tokens)))

Finally, scripts(((script))) play a crucial role in the minting and burning of _Cardano native tokens_.

While ada(((ADA))) is the native currency of the Cardano blockchain, Cardano also supports the creation of _custom tokens_, which can be either _fungible_ (like ada(((ADA)))) or _non-fungible_ (like NFTs).

Minting and burning custom tokens(((token, custom))) must have restrictions, otherwise, they would be pointless if allowed freely. Therefore, these actions are also governed by scripts(((script))).

A Cardano native token is identified by two components: the _policy ID_ and the _token name_:

- The token name(((token name))) is an arbitrary byte string, up to 32 bytes long
- The policy ID(((policy ID))) is the hash of a script(((script))).

Whenever a transaction(((transaction))) mints or burns a token, the corresponding script(((script))) is evaluated during phase 2 validation(((validation))).

These _minting scripts_ can range from completely permissive (allowing unrestricted minting and burning) to more controlled cases requiring specific signatures or enforcing complex rules, such as ensuring the uniqueness of tokens to create NFTs.

