
:imagesdir: ../../images

=== Ouroboros Consensus

Ouroboros is a family of Proof-of-Stake protocols powering the Cardano blockchain, among others. It is backed by years of research and numerous peer-reviewed publications. #

TODO: Insert References to the papers#

In this chapter we are going to build an intuition of how Ouroboros Work, so that when you go and read the formal papers describing the algorithm, you already have a good intuition about how it works, so that the mathematics make more sense.#

Let's start with a definition:

____
"Ouroboros is the name of a family of Proof-of-Stake consensus [1] protocols which provides foundation for Cardano and other blockchains. Distributed Consensus [2] is the mechanism through which a single, linear, eventually consistent [3], chain of blocks is established among all participants of the network. [4]"
Intersect MBO
____

Such a short definition, entails 100s of human-years of engineering effort.
We will spend the rest of the chapters going on each element of the definition to make sense of it.

==== Why do we need Consensus Algorithms?

All blockchains have a consensus algorithm, Bitcoin has Proof-of-Work, Filecoin has prof-of-storage, and Cardano has Ouroboros Proof-of-work.#
But before going forward, we need to ask ourselves: Why are Consensus Algorithms necessary?

The fundamental reasons are simply facts of nature:
* the *CAP Theorem*
* The speed light is not instantaneous, so there is always *Latency*.


For example,
Let's say you want to have Financial system that settles the transactions in all of the planet and you setup a Server on every continent.

image::ouroboros_distributed_system.png

You would want to:
* Partition Tolerance, so that if there is Tsunami in the Atlantic, the system can continue to operate.
* Strong Consistency, so that the transactions, on all the continents are registered and we can avoid having *double spending* i.e. a bad actor trying to use the same money in two different transactions.
* Have low latency, so that all the transactions on each continent are registered very fast to speed up the payment system.

But as it is explained in the CAP and PCAELC theorems, _we can't have what we want, but [using a consensus algorithm] we might get what we need_.

===== The CAP and PACELC Theorems



Professor Eric A. Brewer defined the CAP theorem and paraphrasing it means:

---
When having a distributed [data store] system, you can only have two out of the three properties:

* Partition Tolerance: The system, continues to operate even in the presence of network errors.
* Availability: Every request to a server receives a response.
* Consistency: Every read receives the most recent write or an error.

---

Later Dr. Danil Abadi extended the CAP theorem with the PACELC Theorem.
Paraphrased says:

---
If there is a Partition,
  decide between Consistency or Availability.
Else
  choose between Low latency or Consistency.
---

image::ouroboros_PCAELC_Theorem.svg


In our example of a Global Financial system.
A Partition would be like there is a tsunami that severs the interoceanic cables, leaving the continents separated in regions.
If we want to maintain Consistency, then we can forbid new transaction on both sides of the Atlantic.
So that we can always respond with the most up to date information.
Or if we want to keep to keep the transactions to be registered (Availability) then the different servers records would slowly drift apart and loose Consistency.

Even if there is no tsunami.
Just the fact that speed of light takes a few seconds to go to the other side of the planet, means that if we want to have a Consistent system.
We should give up on the idea of Low Latency, to register each transaction.

But despite what the PCAELC theorem says. We *must* provide high consistency and low latency and be partition tolerant.
So what do we do?

===== Nakamoto Consensus (Longest Chain Rule)

Satoshi Nakamoto introduced a solution to the problem of decentralized consensus
by inventing the *blockchain* data structure and the *Longest Chain Rule*,
forming what is now known as _Nakamoto Consensus_.

Transactions are collected into *blocks*, each of which references the hash of the previous block,
forming a cryptographically linked chain. Participants in the network propagate new transactions
using a *gossip protocol*, so that each node has a (roughly) consistent view of pending transactions.

These pending transactions are stored in each node’s local *mempool* (short for "memory pool").
The mempool is a temporary buffer of unconfirmed transactions waiting to be included in a block.
Each node maintains its own version of the mempool, and while they are usually similar,
they can differ slightly due to network latency or policy differences (e.g., minimum fee requirements).
Miners select transactions from their mempool when building a new block,
often prioritizing those with higher transaction fees.

image::ouroboros_mempool.svg

Network participants (*miners*) [in Cardano SPOs] independently assemble candidate blocks from their mempool
and *compete* to solve a cryptographic puzzle (Proof of Work) [in Cardano Proof of Stake].
The first miner to find a valid solution broadcasts the block to the rest of the network.

Once verified, the new block is appended to each node’s local copy of the blockchain,
and the transactions it contains are removed from the mempool.
The process then repeats.

If the network becomes partitioned, or two miners [SPOs] solve the puzzle at nearly the same time,
*temporary forks* may occur. Eventually, one branch becomes longer as more blocks are added.

image::ouroboros_longest_chain.svg

All honest nodes converge on this *longest valid chain*, discarding blocks from shorter forks.
Transactions in the discarded blocks may be re-added to the mempool if they haven’t already been confirmed.

image::ouroboros_longest_chain_consensus.svg

In this point is important to mention how similar the Original Nakamoto Consensus an the Ouroboros Consensus are.
In fact Ouroboros is Nakamoto Consensus.
The main difference is how they select the Network Participant (i.e. the Miner in Bitcoin or the SPO in Cardano).

Bitcoin uses Proof-of-Work and Cardano uses Proof-of-Stake or more precisely a Verifiable Random Function.

=== How does Proof-of-Work select a validator (miner) ?

In proof of work the Network Participants (a.k.a. Miners).
*compete* with each other to find a "magic number" (a.k.a. Nonce) that make the block, fulfill a rule ("complexity").
So Proof-of-Work is like *race* where all the *miners* have to jump through hoops to be rewarded.

Proof of Work then is like hurdling race.
Where there is only one winner.



==== But what is the "race" about?

We can see a block of the Bitcoin Network as data structure with the following fields:

image::ouroboros_basic_block_structure.svg

And then the "race" is about trying to calculate the Hash Function that given the data and the Nonce,
Returns a Current Block Hash that has the desired number of trailing zeros ("0000").

But in order to calculate the Current Block Hash the only way is to try Nonce numbers at random.
like in this image we try with 0, 17... and so on

image::ouroboros_trying_with_nonce.svg

Until finally, we find the Nonce that gives a correct Current Block Hash:

image::ouroboros_valid_nonce.svg

As you can imagine this approach of random Nonce generation and testing if the hash calculated satisfies the complexity
we desire is very computational intensive.
That is the "Work" in the "Proof-of-Work"

But this approach has some disadvantages

==== Proof-of-Work disadvantages.

* Wasting Electricity
  Bitcoin is famous for wasting the same electricity as a small country.
  Going back our analogy the fact that all marathon runners have to run every race,
  With hopes of winning one reward. Wastes a lot of energy.
  
* It leads to centralization in Mining Pools.
  A mining pool is an association where miners, get together and decide to collaborate, with their computing power.
  To calculate the hash, and share the rewards.
  In our analogy is like if the Marathon runners decided to create teams, run together.
  And if one person of the team wins, it shares the rewards with its team.

* It leads to manufacturing centralization and e-waste.
  Since the equipment that mines in proof-of-work only has to do one operation (calculate a hash).
  This has created the development of specialized hardware to do it ("miners").
  However, this also generates e-waste since once the miners are obsolete,
  they can't be used to anything else.
  

And although this disadvantages make headlines today.
There was group of visionaries, leaded by Professor Aggelos Kisayas Chief Scientist at IO Research that saw them.
And started to work on an alternative to Proof-of-Work.
In the idea of Proof-of-Stake and Ouroboros in Particular.

==== Proof-of-Stake

If Proof-of-Work is a marathon, Proof-of-Stake is a *relay race*.

Only one runner, called the *slot leader*, runs each segment (block) of the race.
That runner delivers the message (a block of transactions) to the next runner,
who is randomly selected from a thousand others waiting to be chosen.

From this perspective, the benefits of Proof-of-Stake become clear:

- Only one runner means no wasted electricity.
- The hardware requirements are minimal: any generic computer capable of calculating a cryptographic hash function can participate.
- There is no incentive to form mining pools (teams), since the chance of being selected as the next slot leader is proportional to the amount of stake — i.e., one's *investment* in the network or the trust of other users that delegate their stake to the SPOs.
- This reduces incentives for centralization.
- The protocol is open: the hardware is not controlled by any one manufacturer, and even the software can be implemented by multiple independent teams.

===== How does Ouroboros (Praos) work?

Time in Cardano is divided into *epochs*, and each epoch is further subdivided into *slots*.
Currently (2025), One epoch has 432000 slots. And each slot lasts 1 second.
So each epoch is approximately 5 days.

During each slot:

- Servers (nodes) gather and broadcast transactions using a *gossip protocol*.
- These transactions accumulate in each node's local *mempool*.

Even though slots last 1 second.
Not every slot results in a block.
In fact, Cardano is parameterized so that on average one block is produced every 20 seconds.
According to a parameter called "active slot coefficient" currently set at (0.05 or 5%).

At the end of a slot, If the slot happens to be one of the 5% of active slots.
then it produces a block.

If a block is generated, a cryptographic lottery takes place.

All stake pool operators compute a Verifiable Random Function (VRF).
This VRF takes as input:
* a *random seed* that is updated each epoch.
* the SPOs private key
* and a label to distinguish repeated uses of the VRF.

The random seed is derived from data in the previous blocks.

The VRF produces a random output and a proof.
The beauty of a VRF is that others can later verify the output was computed correctly from the given inputs without being able to guess it beforehand.
Each node’s VRF output is essentially that node’s “lottery number” for the slot, and the proof is like a signed ticket.


On each slot, each SPO effectively asks (itself):

    "Am I the slot leader for this slot?"

If the result of the VRF falls below a certain threshold,
determined by the amount of stake the operator controls,
then the operator becomes the *slot leader*.

That slot leader:

- Selects transactions from the mempool.
- Constructs a new block.
- Signs the block.
- Broadcasts the signed block to the network.

Cardano accumulates rewards (from block minting and fees) and distributes them to stake pools and delegators at the end of each epoch according to an incentive formula.

Then the stake pool operators (all), in the following slot, verify the previous block’s validity
including:

* The block’s signature (to ensure it was signed by a registered pool’s key).
* verify the VRF proof included in the block, which proves the slot leader indeed had an output below the threshold.
  Using the VRF proof, any node can confirm that “Yes, the creator of this block had the right to do so for slot N.”
  This prevents malicious nodes from faking leadership.
  The Ouroboros Praos spec calls this the “proof of leadership” included in each block
  If a block’s proof is invalid or the node was not actually eligible, the block is rejected by others.
* They also validate all transactions in the block (checking signatures, UTXOs, etc.) as with any blockchain.
* Once the block passes validation, it’s appended to the node’s copy of the chain.


In Cardano, rewards are paid to stake pool operators (and delegators) at the end of each epoch, but with a delay of one full epoch after the one in which the rewards were earned.

The delay allows the network to:

Finalize the stake snapshot (used to calculate each delegators share)

Calculate the actual rewards based on the number of blocks produced, the active stake, fees collected, and the pool’s parameters (margin, fixed cost)

And the process restarts for the next Epoch.

===== Why is it called "Ouroboros"?

The name *Ouroboros* — the ancient symbol of a snake eating its own tail — reflects how each epoch feeds into the next.

In Ouroboros, each slot’s randomness (used to determine slot leaders) is derived from
the data of previous epochs. The blockchain uses its *own past* to seed its *own future*,
creating a secure, self-referential cycle.

That is how the snake eats it's own tail.




===== Different versions of Ouroboros

The version of Ouroboros we have described can be better thought as Ouroboros Praos however different versions of Ouroboros exist by relaxing different assumptions.

* Ouroboros Classic (2017): first Poo with security proof, but required synchronous communication and had a public deterministic schedule.
* Ouroboros BFT (2018): interim federated version (used during Cardano Byron reboot)
* Ouroboros Praos (2018): introduced private VRF leader lottery, semi-synchronous security
* Ouroboros Genesis (2018): improved fork-choice, allowing trustless bootstrap and dynamic availability
* Ouroboros Chronos (2019): added secure time synchronization to Ouroboros (not yet implemented)
* (There are also Ouroboros Crypsinous (privacy-preserving variant)
* and Ouroboros Leios (throughput scaling)


===== Ouroboros Classic (2017)

The first version of Ouroboros demonstrated that a proof-of-stake protocol could match the security guarantees of proof-of-work,
provided that at least 51% of the stake is controlled by honest participants.
However, this version assumed a synchronous network, where all nodes are online and messages are delivered within a known, fixed delay.
In this regard it was a leap forward but not yet practical.

==== Ouroboros BFT (2018)

     Used during Cardano Byron reboot.
     Allowed the federated blockchain.
     Where trusted parties (IOG, Emurgo and Cardano Foundation), ran their own nodes.
 

===== Ouroboros Praos (2018 – Used in Cardano today)

The problem with Ouroboros classic is that it requires a random and distributed why to select the next stake pool operator to be selected.
and when it comes to computers there is nothing absolutely random.
So Ouroboros Praos implemented the concept of the Verifiable Random Function, that took as seeds of the random generation function, things that couldn't ´t be controlled or predicted by anyone #
the block number#
the signing key of the stake pool operator that had to be submitted in advance#
the amount of stake delegated in the stakepool operator#
and the contents of the transaction in the block#
including the hash of the previous block.#
as you can see no single entity can predict or control any of those values that creates the randomness#

===== Ouroboros Genesis (2018 – Improved chain selection and bootstrap)

With Ouroboros Praos the main hurdles to have a correct poof of stake system were fulfilled now the next is to make it fast
the first hurdle is that starting a new Cardano node from the beginning was very slow, we are talking about 36 hours slow, trying to catch up with the tip of the blockchain.#
the naive solution to this is to have snapshots of the status of the blockchain at a certain point in time.
download that one big file, and assuming the file is correct, start to synchronize the copy of the blockchain from that point on.
Ouroboros Genesis does it even better, in genesis,
several points in the blockchain can be consider to be reliable, and therefore you don´t even need to download all the history, the sync with tip can start immediately!

==== Ouroboros Chronos (2020/2021 – Decentralized time synchronization)

Chronos is a more recent development in the Ouroboros family, focusing on an often-overlooked aspect: time synchronization in a distributed system. By design, Ouroboros assumes some global notion of slots (1 second intervals). In practice, nodes rely on their local system clocks to know when slots start/end. If an adversary could significantly skew clocks or if there was no agreed time, consensus could break (e.g., nodes disagreeing on slot numbers). What Chronos introduces:
A mechanism for nodes to securely synchronize their clocks using the blockchain itself as a reference. It effectively turns the blockchain into a decentralized time oracle.
Chronos removes dependence on external time sources (like NTP servers), which could be central points of failure or attack. Instead, nodes periodically run a protocol (embedded in the blockchain process) to agree on the current time, detecting and correcting any drift or malicious deviations.
This makes the system more resilient to time-based attacks (for example, an attacker can’t as easily isolate a node with a wrong clock to mess up its slot scheduling).

=== In conclusion

At this point, I hope you see how the development of the first practical proof of work consensus algorithm in Ouroboros was possible.#
how each iteration was an improvement over the limitations and assumptions of what came before. 
how the security of the algorithm is a mathematical probability given by the parameters in the blockchain.
and how by varying some of our assumptions we can create tuned versions of the protocol appropriate for certain applications.
