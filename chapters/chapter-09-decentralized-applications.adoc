
:imagesdir: ../images

:figure-numbered:

[[decentralized-applications]]
== Decentralized Applications

Decentralized Applications(((decentralized application (DApp)))) (DApps) aim to empower end-users through ensuring that the encoded digital processes and data stored are not centrally controlled (as discussed in previous chapters). So far in the previous chapters, we have covered some of the components that support decentralized applications including the blockchain network, smart contract/on-chain scripts and wallets. In this chapter we focus on those technological components that support user interaction and bridge the gap between foundational blockchain and on-chain script infrastructure and users.

=== Traditional Web Application Architecture

To be able to appreciate the novelty that decentralized applications bring, we first provide an overview of traditional web applications(((web application))). <<fig-tradweb>> depicts an abstract overview of traditional web application interaction.

[[fig-tradweb]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Traditional web architecture.
[#fig-tradweb]
image::TraditionalWebArchitecture.png[]

When browsing web sites, at an abstract level, the process can be broken down into three steps:

. Your request for a web page (depicted in Step 1 in <<fig-tradweb>>). When you use a web browser on your computer (or mobile phone) and go to a website, really what is happening is your browser makes a 'request' to the web server that hosts the web page, asking it for the content of the specific page.

. The web server which is centrally owned and controlled by some entity, receives the request and puts together its 'response' -- more specifically the web page content to return. This 'response' is sent back to your web browser, operating on your device (depicted in Step 2 of <<fig-tradweb>>).

. Once a web page has been loaded in your web browser, subsequent data and interaction can take place between the web page itself and the web server (depicted in Step 3 of <<fig-tradweb>>). This could be to retrieve, for example, the latest news articles on a news website. Web applications are typically composed of more than one web page. Usage of one web page may lead to directing a user to another web page, resulting in a request for a new web page (which would initiate the process for requesting a new web page depicted in step 1).

Some web pages have static content, i.e. their content is always the same (and perhaps hard-coded). For example, consider a web page that always displays the text 'Hello World!'. While other pages may be more dynamic, which allow for the web server to decide on the specific content to respond with. For example, consider a web page that displays the current date and time -- the content dynamically changes according to the date and time. Really, most web pages nowadays consist of some degree of static content and some amount of dynamic content. Though it is also not unheard of to have completely static web pages -- for example, many company landing pages often have a static view of what they want their clients to see as the first page of their web site.

The actual 'response' that the web server sends back to your web browser most typically consists of two parts: (a) HTML(((HTML))) code; and (b) JavaScript code (and some other media assets and styling sheets). The HTML code describes what the web page should look like.footnote:[ The content likely also makes use of CSS(((CSS))) code, but this detail can be ignored unless you want to dig deeper into web page design.] Your browser uses the HTML code it receives as a means of 'drawing' the visual aspect to the web page. Consider a web page that can be used as a calculator. The HTML would describe and provide the instructions for your browser to visualise all aspects of the calculator including the different buttons on the calculator, and the display. Yet with such a visual representation (that HTML provides) only, pressing the buttons would not have any effect. A second component is needed to provide instructions to the browser that describes the functionality of the web page -- i.e. for the calculator use-case, functionality for displaying a '1' when the '1' button is pressed, and for adding two numbers together and displaying their result when required. This functionality is encoded within the JavaScript component of a web page.

The HTML and JavaScript code described above is sent to your browser on your computer, and is executed in your browser (on your computer). Really this means that you could manipulate the HTML and JavaScript code, which means you can change what a web page you interact with looks like, and also its functionality.footnote:[ Most web browsers allow users to use 'Developer Tools' that are built into the web browsers themselves, that allow you to manipulate web pages once they are in your browser.] This code received from the web browser, which is executed in your browser, is what we call "client-side" -- i.e. code that executes in the client'sfootnote:[ It may help to consider that when using a web site you are the client, and this is why it is referred to as client-side code, since the code is executing on your laptop. Really though the terminology comes from ;'client-server' architectures (which has resemblances to the analogy provided).] browser. Since the code can be manipulated by yourself (the client), web site operators cannot just trust any interactions or code that take place on your device, and it is for this reason that some functionality is not encoded into the 'client-side' HTML and JavaScript but encoded into 'server-side(((server-side)))' code which executes on the web server owned by the particular entity the original web page was received from. For the code that is executed on the web server, the website operator has full control over that logic and as users of that website we must trust the operator. To exemplify this further consider an online shopping platform. Whilst end-users are displayed with products and prices on screen and are able to select which products they would like to purchase, the site operator cannot trust end-users to calculate the total cost due after selecting products. Since as described above, end-users would be able to manipulate the total calculation taking place within their browser. Therefore, the web site is built in such a way that code concerned with total calculation is ultimately done on the web server ('server-side'). Once a total is calculated and a client is ready to pay, clients' are typically sent to a payment page where they enter their bank card details. Again, processing of card transactions is typically done 'server-side' for the same reasons. Yet, in this scenario, clients that are making purchases need to trust the operator and the code that is handling the total calculation (and executing on the web server) to not overcharge after entering their card details. Traditional web applications and their architectures heavily support keeping site operators in a position of power, i.e. where platform providers are in full control and end-users are reliant on the platforms, and must trust that the platforms do their job properly -- and when they do not must try to seek recourse in some other manner if possible (e.g. through contacting the operator, or seeking legal recourse if necessary and possible).

[[dapp-architecture]]
=== Decentralized Application Architecture

The advent of blockchain platforms and smart contracts built on them, provided a new place where code could be executed, i.e. in smart contracts on a blockchain. Executing code in smart contracts, unlike code executed in client browsers or server-side, provides guarantees that the code cannot be manipulated or altered -- not even by the programmer that created the code! Furthermore the code executed in smart contracts is publicly available, and therefore users can look into the smart contract logic prior to interacting with them. Through the availability of smart contract code, a new architecture was possible that enabled for Decentralized Applications(((decentralized application (DApp)))) (DApps). DApps build on traditional web applications, in that they also make use of client-side and server-side code, yet smart contracts can be utilized to provide guarantees to all stakeholders. Consider the example discussed in the section above, regarding the calculation of the total due for an online shopping platform. If the calculation of the total is done on the client-side, then users could manipulate the amount due, therefore service providers calculate totals on the server-side. While this makes complete sense, server operators could manipulate the logic to calculate a higher total due -- though end-users are likely to notice this before payment. Yet in a similar vein server operators could display one amount, and process a transaction for a different amount. This is really the status quo of traditional web architecture. Using a DApp, instead such logic could be delegated into a smart contract that would provide guarantees to both the service provider as well as to end-users, since the code is transparent and publicly available for everyone to see. Furthermore, the code is immutable, it cannot be changed -- not even by the developer that wrote it. We will now provide an overview of typical DApp architecture, followed by a walkthrough on how to use a DApp, and then close off with code snippets demonstrating how a DApp can be built. <<fig-dapp>> depicts an abstract overview of typical DApp interaction.

[[fig-dapp]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Decentralized Application (DApp) architecture.
[#fig-dapp]
image::dAppArchitecture.png[]

Interaction with DApps, at an abstract level, can be broken down into three steps exactly like traditional web applications. Yet following the initial web page request (depicted in step 1) and web page response (depicted in step 2), future interaction (depicted in interactions marked as 3) between the client browser is not restricted only to communication with the centralized platform (or other centralized services), but can interact with decentralized platforms such as Cardano's blockchain and on-chain scripts running on top of it. Consider the same example discussed above. Initially, an end-user can request the web page that displays different products (and in turn their browser receiving the web page including HTML(((HTML))) and JavaScript). Thereafter, when the user wants to select a product to purchase which will require for the total to be calculated, this interaction could take place directly from the client's web browser with on-chain code deployed on the blockchain. Thereafter, payment could be made again through direct interaction between the user's web browser and on-chain scripts. Fulfilment of the order could even take place by underlying on-chain scripts -- if the service is one that can be fulfilled digitally through on-chain scripts, e.g. if a user was buying a particular token in exchange for another cryptocurrency.

While the server is responsible for delivery of the initial HTML and JavaScript sent to the client's web browser, and even most of the logic coordinating future interaction, any required guarantees can be provided based on logic encoded in on-chain script code. Really the front-end HTML code, and JavaScript code that coordinates the interaction with underlying on-chain script code can be seen as the gateway facilitating interaction with the actual logic encoded in the on-chain scripts. If it was desirable to do away with the centralized request/response delivering the initial HTML/JavaScript code, then other distributed platforms could be used to replace the centralized components such as IPFS(((IPFS))) (which will discuss in more depth later in this chapter).

To further exemplify how guarantees can be provided through on-chain scripts (in spite of initial HTML/JavaScript code being delivered by centralized infrastructure), we'll now introduce how to use a DApp, and then later how to build a DApp.

=== Prerequisites to Create a DApp

We now list a number of prerequisite steps required in order to follow upcoming sections on how to use a DApp and how to build a DApp.

==== Installing a Wallet

Prior to building a DApp, we need to ensure that we have a wallet installed in a browser that will allow for the client web-page to communicate with the blockchain directly. We'll use the Lace wallet (introduced in the <<wallets-in-the-world-of-cardano>> Chapter) in the rest of this chapter, but you may use any other wallet that supports the Cardano blockchain.


==== Configuring Wallet to Connect To Testnet

We'll configure the Wallet to connect to the Cardano test network so that we can test without having to spend real cryptocurrency. In Lace, you can do this by:

. Clicking on the currently selected Wallet (as depicted in <<fig-wallet-settings>>)
. Then selecting 'Settings'
. Then click on 'Network' to 'Switch from mainnet to testnet'
. Click on 'Preprod' which is meant for pre-production testing

[[fig-wallet-settings]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Finding Wallet Settings.
[#fig-wallet-settings]
image::wallet-to-settings.png[pdfwidth=50%]

You can check whether you are connected to a test network in Lace to see if the test network is listed at the top of the wallet screen as depicted in <<fig-wallet-preprod>>.

[[fig-wallet-preprod]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Preprod indication.
[#fig-wallet-preprod]
image::wallet-preprod.png[pdfwidth=50%]

==== Receiving Test Cryptocurrency

In order to interact with the blockchain, users must spend some cryptocurrency. Since we want to avoid spending real cryptocurrency whilst testing we've switched to the Preprod test network (as discussed above), and need to obtain some test cryptocurrency. To do so we'll request some test Ada (Cardano's cryptocurrency) from a faucet.footnote:[Faucets are the term typically used for services that send test cryptocurrency.] One such faucet can be found here: +
https://docs.cardano.org/cardano-testnets/tools/faucet[_https://docs.cardano.org/cardano-testnets/tools/faucet_]

To retrieve test Ada, configure the fields as follows:

* Environment: Preprod Testnet
* Action: Receive test ADA

Then, copy your wallet address. In Lace this can be done by clicking on 'Copy address' located at the bottom of the main screen of the wallet as depicted in <<fig-wallet-copy-address>>. Then paste the address in the address field. Ensure to click on "I'm not a robot" and press 'Request Funds'. A success message should appear shortly, and the test Ada should appear in your wallet within a few minutes.

[[fig-wallet-copy-address]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Copy wallet address.
[#fig-wallet-copy-address]
image::wallet-copy-address.png[pdfwidth=45%]

The filled in details are depicted in <<fig-faucet>>.

Note: The public address of the wallet is hidden, since all transactions are publicly available for anyone to see. You should keep this in mind when sharing your wallet addresses.



[[fig-faucet]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Requesting test Ada from a faucet.
[#fig-faucet]
image::faucet.png[]


=== Using a DApp

Now that we have some test cryptocurrency in our wallet, let's try to use a DApp. We'll use a decentralized exchange(((decentralized exchange))) (DEX) to swap some of our testnet Ada for some other token. More specifically we'll use a preprod test network version of the Minswap(((minswap))) DEX as follows:

. Go to https://testnet-preprod.minswap.org/[_https://testnet-preprod.minswap.org/_]
. Connect your wallet by clicking 'Connect Wallet', then choosing 'Lace' (or a different wallet if you are not using Lace).
. The wallet will popup asking you to confirm that you want to connect your wallet to the minswap.org site. By doing so we'll be able to use our wallet with the minswap.org site and interact directly with the blockchain. So, we'll press "Authorize". You can then choose whether you want to always allow the site to connect to your wallet, or whether it can only connect this time. Once your wallet is connected, go back to the Minswap main screen by pressing the 'X' as depicted in <<fig-minswap-close>>.

[[fig-minswap-close]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Closing Minswap's side-bar.
[#fig-minswap-close]
image::minswap-close.png[]

[start=4]
. Click on the 'Trade' link in the top left (depicted in <<fig-minswap-trade>>) so that we're sent to the 'swap' functionality.

[[fig-minswap-trade]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Click the 'Trade' link.
[#fig-minswap-trade]
image::minswap-trade.png[]

[start=5]
. The DApp is likely automatically loaded with details to swap from Ada (which you should have in your wallet) to Min (Minswap's own token). The testnet version of Minswap only supports swapping between Ada and Min. When you use the mainnet's version though you can choose to swap to other tokens as well. Enter an amount of Ada that you will swap in from your wallet, and the amount of Min that will be swapped out will be displayed (<<fig-minswap-review-trade>> depicts a swap of 123 test Ada to the relevant amount of test Min at the time of writing).

[[fig-minswap-review-trade]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Review trade details.
[#fig-minswap-review-trade]
image::minswap-review-trade.png[pdfwidth=45%]

[start=6]
. You can then confirm the swap by clicking 'Trade now'. This should initiate your wallet to pop-up prompting you to choose whether you agree to the transaction as depicted in <<fig-lace-confirm>>.

[[fig-lace-confirm]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Confirm trade in Lace.
[#fig-lace-confirm]
image::lace-confirm.png[pdfwidth=45%]

[start=7]
. Once you confirm the transaction you may be required to enter the password you set for the wallet.
. You should then see that the transaction was signed by your wallet as depicted in <<fig-lace-done>>.

[[fig-lace-done]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Transaction signed and submitted.
[#fig-lace-done]
image::lace-done.png[pdfwidth=45%]

[start=9]
. Once the transaction is confirmed on the blockchain, and the Minswap interface updates, you should see your balance of Min has increased (and Ada decreased) as depicted in <<fig-minswap-balances-updated>>.

[[fig-minswap-balances-updated]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Balances updated in Minswap.
[#fig-minswap-balances-updated]
image::minswap-balances-updated.png[pdfwidth=45%]

And that's it! You have used your first DApp (if you haven't already done so, of course). To further build on what was discussed in the previous section, it is important to highlight the different interactions that took place from your browser and what it was communicating with. First we requested the DApp by visiting the web site (i.e. https://testnet-preprod.minswap.org/[_https://testnet-preprod.minswap.org/_]), through which your browser requested the web page (i.e. HTML and JavaScript and other images and media-assets) from the centralized Minswap server. We then instructed the DApp to connect to our wallet, and confirmed in the wallet that we agree to it connecting with the DApp. Our wallet runs on our computers and is the interface that we can trust to verify interactions with the underlying blockchain. The DApp fetches swap prices to display on screen by communicating with the centralized server directly -- and though this may raise eyebrows in that the centralized server can manipulate prices, the guarantees with respect to actual swap prices used are provided through the final on-chain script call that is used to initiate the swap (discussed next). When the user agrees to the swap in the wallet popup, it is at this point that the wallet directly communicates with the on-chain script code (deployed on the blockchain), within which the swap price is guaranteed to be the current price as defined by the on-chain logic. So, the guarantee provided to the user is that the swap will be performed at the current price (defined with decentralized on-chain script code) -- irrespective of whether the centralized server reports a different price. This potential price discrepancy is why such DEXs allow for users to specify a 'slippage' amount and/or minimum/maximum prices for swaps -- so that users can express what minimum/maximum swap price they agree to in the case that there is a discrepancy between the prices reported on screen (by the centralized server) and the actual current price that the swap would use. This discrepancy emerges not only from the fact that servers may report different prices, but also given that time passes between user acceptance and the time the actual swap would take place -- and within this time it may be the case that other swaps were executed for the specific price-pair that would affect the swap price.

Having explored using a DApp, let's now delve into aspects of internal workings of a DApp by re-creating parts of a DApp.

=== Creating a DApp

We'll now create the following aspects of a DApp:

* Server-side code: A NodeJS(((NodeJS))) server that will send a page's HTML(((HTML)))/JavaScript to the end-user.
* Client-side code: This is the code that will be sent from the server (discussed above), but will execute in the client-side browser. This code will connect to the wallet and communicate with a deployed on-chain script.

We will not create on-chain script code in this section (since that is handled in the <<writing-smart-contracts>> chapter). Indeed, DApps can be created that communicate with existing deployed on-chain scripts that may not necessarily be written by the same developers/teams -- just as we demonstrate now below.

==== Creating a Server (with NodeJS)

We now discuss creating a NodeJS server that will be used to serve content to requesting users. You can use any other framework to create server-side code if you wish (such as Python, PHP, .NET, Java, or any other framework you may prefer). We'll use NodeJS' express package. Follow these steps to create the server:

. First, you need to ensure that NodeJS is installed, and that you can run 'node' and 'npm' from the command line.
. Create a new directory where your server code will be saved. We'll refer to this as the 'server' directory.
. In the server directory, run: *npm init* +
and for ease of this tutorial, you can just keep all default settings. +
 +
 This will create a package.json file that defines the settings of the NodeJS project. Verify that the 'main' setting is set to 'index.js'. This setting defines the main entry point file for code in the NodeJS project.
. Create the 'index.js' file in the server directory.
. The template code is provided below.

[source,javascript]
----
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
});

app.listen(port, () => {
    console.log(`Server is running at http://localhost:${port}`);
});
----

[start=6]
. We are making use of the 'express' package, and therefore need to install it. You can do so by running the following command: *npm install express*
. Create an HTML(((HTML))) file that the server will send to the client. We'll call this index.html. For now, just put the text 'Hello World!' in index.html and save the file.
. Thereafter you can run the server using the following command: *node index.js*
. Open a browser, and go to the url: localhost:3000 +
 You should see a page similar to <<node-hello-world>>



[[node-hello-world]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.A first web server.
[#node-hello-world]
image::node-hello-world.png[pdfwidth=45%]

[[para-csc, Creating Client-Side Code]]
==== Creating the Client-Side Code to Connect to the Wallet

Now that we have a server able to send HTML/JavaScript to end-users, let's write the client-side code to connect to a user's wallet and interact with the underlying on-chain scripts. We'll only provide the bare minimal code that is needed. Indeed, you may want to look into implementing a full HTML page (including html, head and body tags), but we'll only provide the necessities for the sake of simplicity.

First, we'll create an HTML button and JavaScript that will connect the client-side code to the wallet. The code to provide a connect button is provided below.

[source,javascript]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>

<script>
async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
        try {
            let lace = await window.cardano.lace.enable();
            const walletAddresses = await lace.getUsedAddresses();
            console.log("Connected to Lace:", walletAddresses);
        } catch (error) {
            console.error("Error connecting to Lace Wallet:", error);
        }
    } else {
        console.error("Lace Wallet not found");
    }
}
</script>
----

After reloading the webpage (i.e. refreshing the url, localhost:3000), you should see the button on screen. If the code is correct, once you press the button, the Lace wallet should pop-up requesting the user to allow for the underlying client-side code to be able to connect to the Lace wallet as depicted in <<dapp-connect-to-lace>>. Upon confirming that the DApp can connect to the wallet, we will not see any changes in the page, since we did not provide any code to do so. However, if you check the developer console in the browser you should see the output messages stating that we successfully managed to connect the wallet to the client-side JavaScript and also the addresses used.

[[dapp-connect-to-lace]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Connect the DApp to Lace.
[#dapp-connect-to-lace]
image::dapp-connect-to-lace.png[]

Now that we have connected the client-side code to the wallet, we'll write some code that will interact with an on-chain script. Just before we do this though, we'll now package some libraries that we need to use in the client-side JavaScript.

==== Packaging Libraries for use in Client-Side JavaScript

In the client-side JavaScript code, we'll use Mesh -- a library that will provide an easier-to-use interface to interact with the on-chain script code deployed on the blockchain. To do so, we'll package the Mesh library using webpack(((webpack))) and serve it to the client-side JavaScript code. Indeed, you can use a different method to package and serve the library. The code we provide here may require changes (especially when considering different versions of SDKs used, e.g. NodeJS). If the code does not work out-of-the-box you may need to investigate how to package and deploy libraries and/or fix this code as required for your environment. We will not delve into the intricacies of this code but you may want to read up on how to package and serve libraries for client-side JavaScript code.

To export the Mesh library follow these steps:

. Install webpack and webpack-cli by running:
[source]
----
npm install --save-dev webpack webpack-cli
----

[start=2]
. Install @meshsdk/core, path-browserify, stream-browserify, crypto-browserify, buffer, and process by running:
[source]
----
npm install @meshsdk/core path-browserify stream-browserify crypto-browserify buffer process
----

[start=3]
. In the NodeJS application, create the file ./mesh-entry.js with the following code:

[source,javascript]
----
import * as Mesh from '@meshsdk/core';
export {
    BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder,
    BlockfrostProvider,
} from '@meshsdk/core';
----

[start=4]
. Create the ./webpack.config.js file with the following code:

[source,javascript]
----
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: './mesh-entry.js',
  mode: 'production',
  output: {
    filename: 'mesh.bundle.js',
    path: path.resolve(__dirname, 'public/js'),
    library: 'Mesh',
    libraryTarget: 'window',
  },
  experiments: {
    topLevelAwait: true,
  },
  resolve: {
    fallback: {
      fs: false,
      path: require.resolve('path-browserify'),
      stream: require.resolve('stream-browserify'),
      crypto: require.resolve('crypto-browserify'),
      buffer: require.resolve('buffer/'),
      process: require.resolve('process'),
    },
  },
  plugins: [
    new webpack.ProvidePlugin({
      Buffer: ['buffer', 'Buffer'],
      process: 'process',
    }),
  ],
};
----

[start=5]
. Run webpack to generate the bundled Mesh library:
[source]
----
npx webpack
----

[start=6]
. If successful, the bundled client-side JavaScript code will be generated at the following path: ./public/js/mesh.bundle.js

. The NodeJS ./index.js application should be updated to allow for the bundled Mesh library to be served to clients by adding the following line:

[source,javascript]
----
app.use(express.static(__dirname + '/public'));
----

The full updated ./index.js code follows:

[source,javascript]
----
const express = require('express');

const app = express();
const port = 3000;

app.use(express.static(__dirname + '/public')); //added now

app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
});

app.listen(port, () => {
    console.log(`Server is running at http://localhost:${port}`);
});
----


==== Using the Bundled Mesh Library in the Client-Side JavaScript

Now, we'll use the bundled mesh library in the client-side JavaScript to communicate with on-chain script.

We'll expand on the HTML file described above (from the <<para-csc>> Section). Again, for simplicity sake we'll encode all HTML and JavaScript into a single file (in index.html). We'll start by adding the boilerplate functionality to use the bundled library:

. Import the bundled library:

[source,javascript]
----
<script src="js/mesh.bundle.js"></script>
----

[start=2]
. In the script tag, we'll get references to the objects and functions needed:

[source,javascript]
----
<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder,
    BlockfrostProvider,
} = window.Mesh;
----

[start=3]
. The full updated index.html should look like this:

[source,javascript]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>

<script src="js/mesh.bundle.js"></script>

<script>
const { BrowserWallet, //added now
    Transaction, //added now
    resolvePlutusScriptAddress, //added now
    applyCborEncoding, //added now
    MeshTxBuilder, //added now
    BlockfrostProvider, //added now
} = window.Mesh; //added now

async function connectWallet() {
  if (window.cardano && window.cardano.lace) {
    try {
      let lace = await window.cardano.lace.enable();
      const walletAddresses = await lace.getUsedAddresses();
      console.log("Connected to Lace:", walletAddresses);
    } catch (error) {
      console.error("Error connecting to Lace Wallet:", error);
    }
  } else {
    console.error("Lace Wallet not found");
  }
}
</script>
----

[start=4]
. To test this code, the Node server will need to be started (potentially restarted), and the page loaded by opening the url `localhost:3000` in a browser. Then check to make sure that loading of the library and loading of the Mesh library objects and functions do not raise any errors (though you might see an error relating to not being able to load favicon.ico).


==== Interacting with the Redeemer 42 On-Chain Script Code

To demonstrate DApp interaction, we'll write client-side JavaScript code to interact with the Redeemer 42 on-chain script code (discussed in the <<writing-smart-contracts>> chapter).footnote:[Also see https://github.com/LukaKurnjek/ppp-plutusV3-plinth/blob/main/off-chain/meshjs/Week02/redeemer42-ref-script.ts] You can read Section <<Simple validation scripts>> to get a better understanding of the Redeemer 42 Script (if you have not already done so). We'll send funds, deploy a reference script and then claim back the funds sent.

The Redeemer 42's reference script that the DApp will interact with has already been deployed to the preprod network. Its transaction hash is: ac43f379762d68839a75d95146c332e6025e5a305fffc071308d138849109bfc



===== Sending Funds to the Redeemer 42 On-chain Scripts

To add functionality that sends funds to the Redeemer 42 on-chain script code follow these steps:

. First, we'll add some variable definitions at the top of the script tag:

[source,javascript]
----
<script>
let wallet;
let walletAddress;

let txHashAssetUtxo;
----

[start=2]
. Then, we'll modify the `connectWallet` function to get a reference to the wallet that we can use with the `BrowserWallet` class imported as follows:

[source,javascript]
----
async function connectWallet() {
  if (window.cardano && window.cardano.lace) {
    try {
      let lace = await window.cardano.lace.enable();
      wallet = await BrowserWallet.enable('lace'); //changed now
      walletAddress = await wallet.getChangeAddress(); //added now
      console.log("Connected to Lace:", walletAddress); //changed now
    } catch (error) {
      console.error("Error connecting to Lace Wallet:", error);
    }
  } else {
    console.error("Lace Wallet not found");
  }
}
----


[start=3]
. Add into the client-side JavaScript code the following to get a reference to the deployed Redeemer 42 script:

[source,javascript]
----
const redeemer42Script = {
  code: applyCborEncoding("581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01"),
  version: "V3"
};
const redeemer42Addr = resolvePlutusScriptAddress(redeemer42Script, 0);
----

[start=4]
. Then to actually send funds we'll use the following code (that is explained below the code):

[source,javascript,linenums]
----
async function sendFunds(amount) {
    console.log(`Sending funds: ${amount}`);
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preprod")
        .sendLovelace({ address: redeemer42Addr }, amount)
        .setChangeAddress(walletAddress);

    console.log('Building transaction...');
    const txUnsigned = await tx.build();
    console.log('Transaction built... Signing transaction...');
    const txSigned = await wallet.signTx(txUnsigned);
    console.log('Transaction signed... Submitting transaction...');
    txHashAssetUtxo = await wallet.submitTx(txSigned);
    console.log(`Transaction submitted... Asset UTXO hash: ${txHashAssetUtxo}`);
}
----

Line numbers 3-6 sets the required parameters for the transaction including: passing in a reference to the wallet we're using to send funds, the network (i.e. preprod), the script address and the amount of Lovelace to send, and the change address.

In line number 9, 11 and 13, we build the transaction, sign it and submit the transaction respectively.

[start=5]
. We also add a 'Send Funds' button to call the added functionality to send 3,000,000 Lovelace (3 Ada).

For reference, the full updated index.html file follows:

[source,javascript]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>
<button id="sendFunds" onclick="sendFunds('3000000')">Send Funds</button> <!-- added now -->

<script src="js/mesh.bundle.js"></script>

<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder,
    BlockfrostProvider,
} = window.Mesh;

const redeemer42Script = { //added now
  code: applyCborEncoding("581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01"),
  version: "V3"
}
const redeemer42Addr = resolvePlutusScriptAddress(redeemer42Script, 0); //added now

let wallet; //added now
let walletAddress; //added now

let txHashAssetUtxo; //added now

async function sendFunds(amount) { //added now
    console.log(`Sending funds: ${amount}`);
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preprod")
        .sendLovelace({ address: redeemer42Addr }, amount)
        .setChangeAddress(walletAddress);

    console.log('Building transaction...');
    const txUnsigned = await tx.build();
    console.log('Transaction built... Signing transaction...');
    const txSigned = await wallet.signTx(txUnsigned);
    console.log('Transaction signed... Submitting transaction...');
    txHashAssetUtxo = await wallet.submitTx(txSigned);
    console.log(`Transaction submitted... Asset UTXO hash: ${txHashAssetUtxo}`);
}

async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
        try {
            let lace = await window.cardano.lace.enable();
            wallet = await BrowserWallet.enable('lace'); //changed now
            walletAddress = await wallet.getChangeAddress(); //added now
            console.log("Connected to Lace:", walletAddress); //changed now
        } catch (error) {
            console.error("Error connecting to Lace Wallet:", error);
        }
    } else {
        console.error("Lace Wallet not found");
    }
}
</script>
----

After running the NodeJS server and refreshing the page (i.e. refreshing localhost:3000), you should see the added button 'Send Funds':

[[fig-sendFunds]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Added 'Send Funds' button.
[#fig-sendFunds]
image::redeemer42-sendFunds.png[pdfwidth=50%]

Upon clicking 'Send Funds' the wallet should pop-up asking that you confirm to sending 3 Ada. It may take a while until the transaction is part of a block -- you can check your wallet's transaction history and also search in a Cardano preprod network block explorer for your wallet's address for a successful transaction (at the associated date/time).

===== Deploying a reference script for the Redeemer 42 example

To add functionality that deploys a reference script (discussed in the <<writing-smart-contracts>> chapter) for the Redeemer 42 example follow these steps:

. We will make use of an RPC provider, which allows for querying of parameters from the blockchain. We'll make use of the BlockfrostProvider provided by mesh SDK, but you could also look into using other providers:

[source,javascript]
----
const provider = new BlockfrostProvider('<YOUR API KEY>');
----

[start=2]
. Then we can include the burn address where to associate the reference script to:

[source,javascript]
----
const burnAddr = 'addr_test1wr4mrzsjwa6pquu0m6480mq06kpxsht80d4nfh56dcak6lsejdm28';
----

[start=3]
. We add a function that will handle deploying the reference script as follows:

[source,javascript,linenums]
----
async function deployRefScript() {
    console.log('Deploying reference script');
    const txBuilder = new MeshTxBuilder({
        fetcher: provider
    });

    console.log('Getting Wallet UTXOs...');
    const utxos = await wallet.getUtxos();
    console.log(`Retrieved [${utxos.length}] Wallet UTXOs`);
    console.log('Building reference script transaction...');
    const unsignedTx = await txBuilder
        .txOut(burnAddr, [{ unit: "lovelace", quantity: '3000000' }])
        .txOutReferenceScript(redeemer42Script.code, redeemer42Script.version)
        .changeAddress(walletAddress)
        .selectUtxosFrom(utxos)
        .complete();

    console.log('Signing transaction...');
    const signedTx = await wallet.signTx(unsignedTx);
    console.log('Transaction signed... submitting transaction...');
    txHashRefUtxo = await wallet.submitTx(signedTx);
    console.log(`Transaction submitted... Reference Script UTXO hash: ${txHashRefUtxo}`);
}
----

In Line 3-5, we create an instance of a transaction builder that we will use in a few lines.

Line 8 gets the wallet's UTXOs (unspent transactions) that could be used (for the transaction that will be submitted).

Lines 11-16 builds the transaction to deploy the reference script, and then the transaction is signed and submitted (on lines 19 and 21).

[start=4]
. Finally, we'll add a button to test out the deploy reference script functionality:

[source,javascript]
----
<button id="deployRefScript" onclick="deployRefScript()">Deploy Reference Script</button>
----


The whole code should now look something like this:

[source,javascript,linenums]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>
<button id="sendFunds" onclick="sendFunds('3000000')">Send Funds</button>
<button id="deployRefScript" onclick="deployRefScript()">Deploy Reference Script</button> <!-- added now -->

<script src="js/mesh.bundle.js"></script>

<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder,
    BlockfrostProvider,
} = window.Mesh;

const redeemer42Script = {
  code: applyCborEncoding("581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01"),
  version: "V3"
}
const redeemer42Addr = resolvePlutusScriptAddress(redeemer42Script, 0);

const provider = new BlockfrostProvider('<YOUR API KEY>'); //added now

const burnAddr = 'addr_test1wr4mrzsjwa6pquu0m6480mq06kpxsht80d4nfh56dcak6lsejdm28'; //added now

let wallet;
let walletAddress;

let txHashAssetUtxo;

async function deployRefScript() { //added now
    console.log('Deploying reference script');
    const txBuilder = new MeshTxBuilder({
        fetcher: provider
    });

    console.log('Getting Wallet UTXOs...');
    const utxos = await wallet.getUtxos();
    console.log(`Retrieved [${utxos.length}] Wallet UTXOs`);
    console.log('Building reference script transaction...');
    const unsignedTx = await txBuilder
        .txOut(burnAddr, [{ unit: "lovelace", quantity: '3000000' }])
        .txOutReferenceScript(redeemer42Script.code, redeemer42Script.version)
        .changeAddress(walletAddress)
        .selectUtxosFrom(utxos)
        .complete();

    console.log('Signing transaction...');
    const signedTx = await wallet.signTx(unsignedTx);
    console.log('Transaction signed... submitting transaction...');
    txHashRefUtxo = await wallet.submitTx(signedTx);
    console.log(`Transaction submitted... Reference Script UTXO hash: ${txHashRefUtxo}`);
}

async function sendFunds(amount) {
    console.log(`Sending funds: ${amount}`);
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preprod")
        .sendLovelace({ address: redeemer42Addr }, amount)
        .setChangeAddress(walletAddress);

    console.log('Building transaction...');
    const txUnsigned = await tx.build();
    console.log('Transaction built... Signing transaction...');
    const txSigned = await wallet.signTx(txUnsigned);
    console.log('Transaction signed... Submitting transaction...');
    txHashAssetUtxo = await wallet.submitTx(txSigned);
    console.log(`Transaction submitted... Asset UTXO hash: ${txHashAssetUtxo}`);
}

async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
        try {
            let lace = await window.cardano.lace.enable();
            wallet = await BrowserWallet.enable('lace');
            walletAddress = await wallet.getChangeAddress();
            console.log("Connected to Lace:", walletAddress);
        } catch (error) {
            console.error("Error connecting to Lace Wallet:", error);
        }
    } else {
        console.error("Lace Wallet not found");
    }
}
</script>
----

Indeed, if this DApp were to be deployed by the developer, they may facilitate the deployment of the reference script -- and not require the user to actively choose to deploy the reference script via the interface.

After re-running the NodeJS server and refreshing the page (i.e. refreshing localhost:3000), you should see the added button 'Deploy Reference Script':

[[fig-deployReference]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Added 'Deploy Reference Script' button.
[#fig-deployReference]
image::dapp-deploy-reference-script.png[pdfwidth=50%]

===== Claiming back funds from the Redeemer 42 example

To claim back funds follow these steps:

. We add a button to initiate claiming back of the funds:

[source,javascript]
----
<button id="claimFunds" onclick="claimFunds()">Claim Funds</button>
----

[start=2]
. We add a function to help retrieve back UTXOs that we'll make reference to when initiating the transaction to claim back funds, as follows:

[source,javascript]
----
async function getUtxo(scriptAddress, txHash) {
    const utxos = await provider.fetchAddressUTxOs(scriptAddress);
    if (utxos.length == 0) {
        throw 'No listing found.';
    }
    let filteredUtxo = utxos.find((utxo) => {
        return utxo.input.txHash == txHash;
    });
    return filteredUtxo;
}
----

[start=4]
. Finally, we add the functionality to initiate the transaction to claim back funds, as follows:

[source,javascript,linenums]
----
async function claimFunds() {
    console.log('Claiming funds');
    console.log(`Retrieving Asset UTXO [${txHashAssetUtxo}] from [${redeemer42Addr}]`);
    const assetUtxo = await getUtxo(redeemer42Addr, txHashAssetUtxo);
    console.log(`Retrieving Script UTXO [${txHashRefUtxo}] from [${burnAddr}]`);
    const refScriptUtxo = await getUtxo(burnAddr, txHashRefUtxo);
    const redeemer = { data: BigInt(42) };

    console.log('Find collateral UTXO');
    const walletUtxos = await wallet.getUtxos();
    const collateral = walletUtxos.find(utxo => utxo.output.amount.find(asset => asset.unit === "lovelace" && BigInt(asset.quantity) >= BigInt(5000000)));

    console.log('Building claim funds transaction...');
    const tx = new Transaction({ initiator: wallet, fetcher: provider })
        .setNetwork("preprod")
        .redeemValue({ value: assetUtxo,
                   script: refScriptUtxo,
                   datum: undefined,
                   redeemer: redeemer})
        .sendValue(walletAddress, assetUtxo)
        .setCollateral([collateral])
        .setRequiredSigners([walletAddress]);
    const txUnsigned = await tx.build();

    console.log('Signing transaction...');
    const txSigned = await wallet.signTx(txUnsigned, true);

    console.log('Transaction signed... submitting transaction...');
    const txHash = await wallet.submitTx(txSigned);
    console.log(`Transaction submitted... Claim Funds hash: ${txHash}`);
}
----

In Line 4, we retrieve back the initial asset UTXO in which we sent funds.

In Line 6, we retrieve back the reference script UTXO.

In Line 7, we define the redeemer value (42) to send to the script.

In Lines 10 and 11, we find a UTXO that can be used as collateral. Though this step may be automatically undertaken for us in non-browser environments, we need to explicitly determine the collateral to be used when using a browser interface like BrowserWallet.

In Lines 14-23, we build the transaction, then in Line 26 we sign the transaction, and submit the transaction in Line 29.

The whole updated code follows:
[source,javascript,linenums]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>
<button id="sendFunds" onclick="sendFunds('3000000')">Send Funds</button>
<button id="deployRefScript" onclick="deployRefScript()">Deploy Reference Script</button>
<button id="claimFunds" onclick="claimFunds()">Claim Funds</button> <!-- added now -->

<script src="js/mesh.bundle.js"></script>

<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder,
    BlockfrostProvider,
} = window.Mesh;

const redeemer42Script = {
  code: applyCborEncoding("581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01"),
  version: "V3"
}
const redeemer42Addr = resolvePlutusScriptAddress(redeemer42Script, 0);

const provider = new BlockfrostProvider('<ENTER API KEY>');

const burnAddr = 'addr_test1wr4mrzsjwa6pquu0m6480mq06kpxsht80d4nfh56dcak6lsejdm28';

let wallet;
let walletAddress;

let txHashAssetUtxo;

async function getUtxo(scriptAddress, txHash) { //added now
    const utxos = await provider.fetchAddressUTxOs(scriptAddress);
    if (utxos.length == 0) {
        throw 'No listing found.';
    }
    let filteredUtxo = utxos.find((utxo) => {
        return utxo.input.txHash == txHash;
    });
    return filteredUtxo;
}

async function claimFunds() { //added now
    console.log('Claiming funds');
    console.log(`Retrieving Asset UTXO [${txHashAssetUtxo}] from [${redeemer42Addr}]`);
    const assetUtxo = await getUtxo(redeemer42Addr, txHashAssetUtxo);
    console.log(`Retrieving Script UTXO [${txHashRefUtxo}] from [${burnAddr}]`);
    const refScriptUtxo = await getUtxo(burnAddr, txHashRefUtxo);
    const redeemer = { data: BigInt(42) };

    console.log('Find collateral UTXO');
    const walletUtxos = await wallet.getUtxos();
    const collateral = walletUtxos.find(utxo => utxo.output.amount.find(asset => asset.unit === "lovelace" && BigInt(asset.quantity) >= BigInt(5000000)));

    console.log('Building claim funds transaction...');
    const tx = new Transaction({ initiator: wallet, fetcher: provider })
        .setNetwork("preprod")
        .redeemValue({ value: assetUtxo,
                   script: refScriptUtxo,
                   datum: undefined,
                   redeemer: redeemer})
        .sendValue(walletAddress, assetUtxo)
        .setCollateral([collateral])
        .setRequiredSigners([walletAddress]);
    const txUnsigned = await tx.build();

    console.log('Signing transaction...');
    const txSigned = await wallet.signTx(txUnsigned, true);

    console.log('Transaction signed... submitting transaction...');
    const txHash = await wallet.submitTx(txSigned);
    console.log(`Transaction submitted... Claim Funds hash: ${txHash}`);
}

async function deployRefScript() {
    console.log('Deploying reference script');
    const txBuilder = new MeshTxBuilder({
        fetcher: provider
    });

    console.log('Getting Wallet UTXOs...');
    const utxos = await wallet.getUtxos();
    console.log(`Retrieved [${utxos.length}] Wallet UTXOs`);
    console.log('Building reference script transaction...');
    const unsignedTx = await txBuilder
        .txOut(burnAddr, [{ unit: "lovelace", quantity: '3000000' }])
        .txOutReferenceScript(redeemer42Script.code, redeemer42Script.version)
        .changeAddress(walletAddress)
        .selectUtxosFrom(utxos)
        .complete();

    console.log('Signing transaction...');
    const signedTx = await wallet.signTx(unsignedTx);
    console.log('Transaction signed... submitting transaction...');
    txHashRefUtxo = await wallet.submitTx(signedTx);
    console.log(`Transaction submitted... Reference Script UTXO hash: ${txHashRefUtxo}`);
}

async function sendFunds(amount) {
    console.log(`Sending funds: ${amount}`);
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preprod")
        .sendLovelace({ address: redeemer42Addr }, amount)
        .setChangeAddress(walletAddress);

    console.log('Building transaction...');
    const txUnsigned = await tx.build();
    console.log('Transaction built... Signing transaction...');
    const txSigned = await wallet.signTx(txUnsigned);
    console.log('Transaction signed... Submitting transaction...');
    txHashAssetUtxo = await wallet.submitTx(txSigned);
    console.log(`Transaction submitted... Asset UTXO hash: ${txHashAssetUtxo}`);
}

async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
        try {
            let lace = await window.cardano.lace.enable();
            wallet = await BrowserWallet.enable('lace');
            walletAddress = await wallet.getChangeAddress();
            console.log("Connected to Lace:", walletAddress);
        } catch (error) {
            console.error("Error connecting to Lace Wallet:", error);
        }
    } else {
        console.error("Lace Wallet not found");
    }
}
</script>
----

After re-running the NodeJS server and refreshing the page (i.e. refreshing localhost:3000), you should see the added button 'Claim Funds':

[[fig-claimFunds]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Added 'Claim Funds' button.
[#fig-claimFunds]
image::dapp-claim-funds.png[pdfwidth=50%]

The above provides the full DApp implementation. To run through the example DApp you should first ensure your wallet is connected by pressing 'Connect Wallet'.  Thereafter, pressing the 'Send Funds' button should send a transaction within which you send funds to the Redeemer 42 script. Once confirming the transaction in your wallet it is ideal to wait to see that the transaction is confirmed. Thereafter, you can press the 'Deploy Reference Script' button to the deploy the reference script -- again, after confirming the transaction in your wallet you should wait to see that the transaction is confirmed. Finally, you can claim back funds by pressing the 'Claim Funds' button -- and yet again after confirming the transaction in your wallet you should wait to see that the transaction is confirmed. In the final transaction, you should see that funds were received into your wallet (i.e. the initial funds sent into and locked in the redeemer script were sent back to you).

Indeed, the DApp is barebones, and serves the purpose to demonstrate of how we to interact from client-side JavaScript with Cardano on-chain scripts.

=== Decentralized Web Storage


The DApp architecture introduced in Section <<dapp-architecture>> relies on a traditional centralized web server to deliver the initial HTML/JS web-page content, and then provides guarantees to users through the interaction with on-chain scripts (smart contracts). Yet, relying on a centralized web server to deliver the initial HTML/JS web-content may not be suitable for certain applications and/or it may be desirable that some web content is not dependent on a centralized web server.

Different solutions have been proposed for decentralized web storage (including IPFS, Arweave, Filecoin, Storj, and others) that vary in cost, persistence, latency and reliability -- we therefore suggest that readers interested to make use of decentralized storage to explore different alternatives. Yet one common feature of decentralized web storage is that the resources (e.g. html pages, images, etc) are 'content-addressable' -- i.e. the resource's unique identifier directly represents the content. Typically, the hash of the resource's data is used as the unique identifier to refer to the specific resource. Content addressable unique identifiers/references can be thought of as providing a system that allows for resources to be retrieved based on the actual content itself, rather than where it is located (i.e. a filename on a specific server). Using such a system for web resources:

* guarantees the integrity of resources (since the hash of the content must match the unique identifier -- that can always be checked);
* minimises data storage requirements for resources with same content;
* allows for decentralizing from relying on a single specific server to host and serve the specific resource -- any peer in the network that hosts the resource can serve it.

=== DApps and UI/UX Issues

While DApps promise to decentralize many multi-party digital services, without a doubt there are still several challenges that must be overcome for their mass-adoption -- particularly for the non-tech-savvy. We now discuss some challenges (that DApps on all blockchains face) and potential future directions to overcome such challenges:

* *Wallet setup woes*: New users may find it daunting to install a wallet and store the wallet's seed phrase. Various directions to circumvent some of these issues have been proposed including "account abstraction", use of "ephemeral keys", and use of "passkeys".

* *Switching between user interfaces*: Users may find it hard to deal with switching between DApp web pages, wallet pop-ups, and block explorers. That being said, confirming actions in wallets is akin to how users confirm online purchases with internet banking apps. As wallets become more integrated into browsers and mobiles, and as wallets provide users with information that is more digestible (without having to use a block explorer), user experience should also reach similar levels to internet banking apps.

* *Gas costs*: for non-cryptocurrency related DApps, esppecially those that a user may not interact with often, users may find it troublesome to both purchase and cover required gas costs. Solutions to this may include feeless/gasless transaction models.

* *Smart contract/on-chain script code and errors may be opaque*: Even though on-chain code is available for all to see, and some may be able to viewed in an intuitive visual block format, understanding code logic is often beyond what many non-tech users are capable of. Furthermore, errors that are often displayed to users require technical knowledge to understand. Different avenues are being investigated that may eventually help non-tech users to understand both the scripts they are confirming to interact with and any errors reported.

* *Losing access to keys*: Whilst not exactly a barrier to using DApps, some users may not feel comfortable using DApps associated with a private key/seed phrase that they may lose. Different approaches are being investigated to circumvent users taking full responsibility on keeping their keys safe including: social recovery, shared wallets, and multi-sig wallets.

