:figure-numbered:

[[decentralized-applications]]
== Decentralized Applications

Decentralized Applications (DApps) aim to empower end-users through ensuring that the encoded digital processes and data stored are not centrally controlled (as discussed in previous chapters). So far in the previous chapters, we have covered some of the components that support decentralised applications including the blockchain network, smart contracts and wallets. In this chapter we focus on those technological components that support user interaction and bridge the gap between foundational blockchain and smart contract infrastructure and users.

=== Traditional Web Application Architecture

To be able to appreciate the novelty that decentralized applications bring, we first provide an overview of traditional web applications. <<fig-tradweb>> depicts an abstract overview of traditional web application interaction.

[[fig-tradweb]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Traditional web architecture.
[#fig-tradweb]
image::TraditionalWebArchitecture.png[]

When browsing web sites, at an abstract level, the process can be broken down into three steps:

. Your request for a web page (depicted in Step 1 in <<fig-tradweb>>). When you use a web browser on your computer (or mobile phone) and go to a website, really what is happening is your browser makes a 'request' to the web server that hosts the web page, asking it for the content of the specific page.

. The web server which is centrally owned and controlled by some entity, receives the request and puts together its 'response' — more specifically the web page content to return. This 'response' is sent back to your web browser, operating on your device (depicted in Step 2 of <<fig-tradweb>>).

. Once a web page has been loaded in your web browser, subsequent data and interaction can take place between the web page itself and the web server (depicted in Step 3 of <<fig-tradweb>>). This could be to retrieve, for example, the latest news articles on a news website. Web applications are typically composed of more than one web page. Usage of one web page may lead to directing a user to another web page, resulting in a request for a new web page (which would initiate the process for requesting a new web page depicted in step 1).

Some web pages have static content, i.e. their content is always the same (and perhaps hard-coded). For example, consider a web page that always displays the text 'Hello World!'. While other pages may be more dynamic, which allow for the web server to decide on the specific content to respond with. For example, consider a web page that displays the current date and time — the content dynamically changes according to the date and time. Really, most web pages nowadays consist of some degree of static content and some amount of dynamic content. Though it is also not unheard of to have completely static web pages — for example, many company landing pages often have a static view of what they want their clients to see as the first page of their web site.

The actual 'response' that the web server sends back to your web browser most typically consists of two parts: (a) HTML code; and (b) JavaScript code (and some other media assets and styling sheets). The HTML code describes what the web page should look like.footnote:[ The content likely also makes use of CSS code, but this detail can be ignored unless you want to dig deeper into web page design.] Your browser uses the HTML code it receives as a means of 'drawing' the visual aspect to the web page. Consider a web page that can be used as a calculator. The HTML would describe and provide the instructions for your browser to visualise all aspects of the calculator including the different buttons on the calculator, and the display. Yet with such a visual representation (that HTML provides) only, pressing the buttons would not have any effect. A second component is needed to provide instructions to the browser that describes the functionality of the web page — i.e. for the calculator use-case, functionality for displaying a '1' when the '1' button is pressed, and for adding two numbers together and displaying their result when required. This functionality is encoded within the JavaScript component of a web page.

The HTML and JavaScript code described above is sent to your browser on your computer, and is executed in your browser (on your computer). Really this means that you could manipulate the HTML and JavaScript code, which means you can change what a web page you interact with looks like, and also its functionality.footnote:[ Most web browsers allow users to use 'Developer Tools' that are built into the web browsers themselves, that allow you to manipulate web pages once they are in your browser.] This code received from the web browser, which is executed in your browser, is what we call “client-side” — i.e. code that executes in the client’sfootnote:[ It may help to consider that when using a web site you are the client, and this is why it is referred to as client-side code, since the code is executing on your laptop. Really though the terminology comes from ;'client-server' architectures (which has resemblances to the analogy provided).] browser. Since the code can be manipulated by yourself (the client), web site operators cannot just trust any interactions or code that take place on your device, and it is for this reason that some functionality is not encoded into the 'client-side' HTML and JavaScript but encoded into 'server-side' code which executes on the web server owned by the particular entity the original web page was received from. For the code that is executed on the web server, the website operator has full control over that logic and as users of that website we must trust the operator. To exemplify this further consider an online shopping platform. Whilst end-users are displayed with products and prices on screen and are able to select which products they would like to purchase, the site operator cannot trust end-users to calculate the total cost due after selecting products. Since as described above, end-users would be able to manipulate the total calculation taking place within their browser. Therefore, the web site is built in such a way that code concerned with total calculation is ultimately done on the web server ('server-side'). Once a total is calculated and a client is ready to pay, clients' are typically sent to a payment page where they enter their bank card details. Again, processing of card transactions is typically done 'server-side' for the same reasons. Yet, in this scenario, clients that are making purchases need to trust the operator and the code that is handling the total calculation (and executing on the web server) to not overcharge after entering their card details. Traditional web applications and their architectures heavily support keeping site operators in a position of power, i.e. where platform providers are in full control and end-users are reliant on the platforms, and must trust that the platforms do their job properly — and when they do not must try to seek recourse in some other manner if possible (e.g. through contacting the operator, or seeking legal recourse if necessary and possible).

=== Decentralized Application Architecture

The advent of blockchain platforms and smart contracts built on them, provided a new place where code could be executed, i.e. in smart contracts on a blockchain. Executing code in smart contracts, unlike code executed in client browsers or server-side, provides guarantees that the code cannot be manipulated or altered — not even by the programmer that created the code! Furthermore the code executed in smart contracts is publicly available, and therefore users can look into the smart contract logic prior to interacting with them. Through the availability of smart contract code, a new architecture was possible that enabled for Decentralized Applications (DApps). DApps build on traditional web applications, in that they also make use of client-side and server-side code, yet smart contracts can be utilized to provide guarantees to all stakeholders. Consider the example discussed in the section above, regarding the calculation of the total due for an online shopping platform. If the calculation of the total is done on the client-side, then users could manipulate the amount due, therefore service providers calculate totals on the server-side. While this makes complete sense, server operators could manipulate the logic to calculate a higher total due — though end-users are likely to notice this before payment. Yet in a similar vein server operators could display one amount, and process a transaction for a different amount. This is really the status-quo of traditional web architecture. Using a DApp, instead such logic could be delegated into a smart contract that would provide guarantees to both the service provider as well as to end-users, since the code is transparent and publicly available for everyone to see. Furthermore, the code is immutable, it cannot be changed — not even by the developer that wrote it. We will now provide an overview of typical DApp architecture, followed by a walkthrough on how to use a DApp, and then close off with code snippets demonstrating how a DApp can be built. <<fig-dapp>> depicts an abstract overview of typical DApp interaction.

[[fig-dapp]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Decentralized Application (DApp) architecture.
[#fig-dapp]
image::dAppArchitecture.png[]

Interaction with DApps, at an abstract level, can be broken down into three steps exactly like traditional web applications. Yet following the initial web page request (depicted in step 1) and web page response (depicted in step 2), future interaction (depicted in interactions marked as 3) between the client browser is not restricted only to communication with the centralised platform (or other centralised services), but can interact with decentralized platforms such as Cardano’s blockchain and smart contracts running on top of it. Consider the same example discussed above. Initially, an end-user can request the web page that displays different products (and in turn their browser receiving the web page including HTML and JavaScript). Thereafter, when the user wants to select a product to purchase which will require for the total to be calculated, this interaction could take place directly from the client’s web browser with a smart contract deployed on the blockchain. Thereafter, payment could be made again through direct interaction between the user’s web browser and smart contracts. Fulfilment of the order could even take place by underlying smart contracts — if the service is one that can be fulfilled digitally through smart contracts, e.g. if a user was buying a particular token in exchange for another cryptocurrency.

While the server is responsible for delivery of the initial HTML and JavaScript sent to the client’s web browser, and even most of the logic coordinating future interaction, any required guarantees can be provided based on logic encoded in smart contracts. Really the front-end HTML code, and JavaScript code that coordinates the interaction with underlying smart contracts can be seen as the gateway facilitating interaction with the actual logic encoded in the smart contracts. If it was desirable to do away with the centralised request/response delivering the initial HTML/JavaScript code, then other distributed platforms could be used to replace the centralised components such as IPFS (which will discuss in more depth later in this chapter).

To further exemplify how guarantees can be provided through smart contracts (in spite of initial HTML/JavaScript code being delivered by centralised infrastructure), we’ll now introduce how to use a DApp, and then later how to build a DApp.

==== Prerequisites

We now list a number of prerequisite steps required in order to follow upcoming sections on how to use a DApp and how to build a DApp.

_Installing a Wallet_

Prior to building a DApp, we need to ensure that we have a wallet installed in a browser that will allow for the client web-page to communicate with the blockchain directly. We’ll use the Lace wallet (introduce in #Chapter 6#) in the rest of this chapter, but you may use any other wallet that supports the Cardano blockchain. 


_Configuring Wallet to Connect To Testnet_

We’ll configure the Wallet to connect to the Cardano test network so that we can test without having to spend real cryptocurrency. In Lace, you can do this by:

. Clicking on the currently selected Wallet (as depicted in <<fig-wallet-settings>>)
. Then selecting 'Settings'
. Then click on 'Network' to 'Switch from mainnet to testnet'
. Click on 'Preprod' which is meant for pre-production testing

[[fig-wallet-settings]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Finding Wallet Settings.
[#fig-wallet-settings]
image::wallet-to-settings.png[pdfwidth=50%]

You can check whether you are connected to a test network in Lace to see if the test network is listed at the top of the wallet screen as depicted in <<fig-wallet-preprod>>.

[[fig-wallet-preprod]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Preprod indication.
[#fig-wallet-preprod]
image::wallet-preprod.png[pdfwidth=50%]

_Receiving Test Cryptocurrency_

In order to interact with the blockchain, users must spend some cryptocurrency. Since we want to avoid spending real cryptocurrency whilst testing we’ve switched to the Preprod test network (as discussed above), and need to obtain some test cryptocurrency. To do so we’ll request some test Ada (Cardano’s cryptocurrency) from a faucet.footnote:[Faucets are the term typically used for services that send test cryptocurrency.] One such faucet can be found here: +
https://docs.cardano.org/cardano-testnets/tools/faucet[_https://docs.cardano.org/cardano-testnets/tools/faucet_]

To retrieve test Ada, configure the fields as follows:

* Environment: Preprod Testnet
* Action: Receive test ADA

Then, copy your wallet address. In Lace this can be done by clicking on 'Copy address' located at the bottom of the main screen of the wallet as depicted in <<fig-wallet-copy-address>>. Then pase the address in the address field. Ensure to click on 'I’m not a robot' and press 'Request Funds'. A success message should appear shortly, and the test Ada should appear in your wallet within a few minutes.

[[fig-wallet-copy-address]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Copy wallet address.
[#fig-wallet-copy-address]
image::wallet-copy-address.png[pdfwidth=45%]

The filled in details are depicted in <<fig-faucet>>.

Note: The public address of the wallet is hidden, since all transactions are publicly available for anyone to see. You should keep this in mind when sharing your wallet addresses.



[[fig-faucet]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Requesting test Ada from a faucet.
[#fig-faucet]
image::faucet.png[]


==== Using a DApp

Now that we have some test cryptocurrency in our wallet, let’s try to use a DApp. We’ll use a decentralized exchange (DEX) to swap some of our testnet Ada for some other token. More specifically we’ll use a preprod test network version of the Minswap DEX as follows:

. Go to https://testnet-preprod.minswap.org/[_https://testnet-preprod.minswap.org/_]
. Connect your wallet by clicking 'Connect Wallet', then choosing 'Lace' (or a different wallet if you are not using Lace).
. The wallet will popup asking you to confirm that you want to connect your wallet to the minswap.org site. By doing so we’ll be able to use our wallet with the minswap.org site and interact directly with the blockchain. So, we’ll press “Authorize”. You can then choose whether you want to always allow the site to connect to your wallet, or whether it can only connect this time. Once your wallet is connected, go back to the Minswap main screen by pressing the 'X' as depicted in <<fig-minswap-close>>.

[[fig-minswap-close]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Closing Minswap's side-bar.
[#fig-minswap-close]
image::minswap-close.png[]

[start=4]
. Click on the 'Trade' link in the top left (depicted in <<fig-minswap-trade>>) so that we’re sent to the 'swap' functionality.

[[fig-minswap-trade]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Click the 'Trade' link.
[#fig-minswap-trade]
image::minswap-trade.png[]

[start=5]
. The DApp is likely automatically loaded with details to swap from Ada (which you should have in your wallet) to Min (Minswap’s own token). The testnet version of Minswap only supports swapping between Ada and Min. When you use the mainnet’s version though you can choose to swap to other tokens as well. Enter an amount of Ada that you will swap in from your wallet, and the amount of Min that will be swapped out will be displayed (<<fig-minswap-review-trade>> depicts a swap of 123 test Ada to the relevant amount of test Min at the time of writing).

[[fig-minswap-review-trade]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Review trade details.
[#fig-minswap-review-trade]
image::minswap-review-trade.png[pdfwidth=45%]

[start=6]
. You can then confirm the swap by clicking 'Trade now'. This should initiate your wallet to pop-up prompting you to choose whether you agree to the transaction as depicted in <<fig-lace-confirm>>.

[[fig-lace-confirm]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Confirm trade in Lace.
[#fig-lace-confirm]
image::lace-confirm.png[pdfwidth=45%]

[start=7]
. Once you confirm the transaction you may be required to enter the password you set for the wallet.
. You should then see that the transaction was signed by your wallet as depicted in <<fig-lace-done>>.

[[fig-lace-done]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Transaction signed and submitted.
[#fig-lace-done]
image::lace-done.png[pdfwidth=45%]

[start=9]
. Once the transaction is confirmed on the blockchain, and the Minswap interface updates, you should see your balance of Min has increased (and Ada decreased) as depicted in <<fig-minswap-balances-updated>>.

[[fig-minswap-balances-updated]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Balances updated in Minswap.
[#fig-minswap-balances-updated]
image::minswap-balances-updated.png[pdfwidth=45%]

And that’s it! You have used your first DApp (if you haven’t already done so, of course). To further build on what was discussed in the previous section, it is important to highlight the different interactions that took place from your browser and what it was communicating with. First we requested the DApp by visiting the web site (i.e. https://testnet-preprod.minswap.org/[_https://testnet-preprod.minswap.org/_]), through which your browser requested the web page (i.e. HTML and JavaScript and other images and media-assets) from the centralised Minswap server. We then instructed the DApp to connect to our wallet, and confirmed in the wallet that we agree to it connecting with the DApp. Our wallet runs on our computers and is the interface that we can trust to verify interactions with the underlying blockchain. The DApp fetches swap prices to display on screen by communicating with the centralised server directly — and though this may raise eyebrows in that the centralised server can manipulate prices, the guarantees with respect to actual swap prices used are provided through the final smart contract call that is used to initiate the swap (discussed next). When the user agrees to the swap in the wallet popup, it is at this point that the wallet directly communicates with the smart contract (deployed on the blockchain), within which the swap price is guaranteed to be the current price as defined by the smart contract logic. So, the guarantee provided to the user is that the swap will be performed at the current price (defined with decentralized smart contract code) — irrespective of whether the centralized server reports a different price. This potential price discrepancy is why such DEXs allow for users to specify a 'slippage' amount and/or minimum/maximum prices for swaps - so that users can express what minimum/maximum swap price they agree to in the case that there is a discrepancy between the prices reported on screen (by the centralized server) and the actual current price that the swap would use. This discrepancy emerges not only from the fact that servers may report different prices, but also given that time passes between user acceptance and the time the actual swap would take place — and within this time it may be the case that other swaps were executed for the specific price-pair that would affect the swap price.

Having explored using a DApp, let’s now delve into aspects of internal workings of a DApp by re-creating parts of a DApp.

==== Creating a DApp

We’ll now create the following aspects of a DApp:

* Server-side code: A NodeJS server that will send a page's HTML/JavaScript to the end-user.
* Client-side code: This is the code that will be sent from the server (discussed above), but will execute in the client-side browser. This code will connect to the wallet and communicate with a deployed smart contract.

We will not create smart contract code in this section (since that is handled in #Chapter 6#). Indeed, DApps can be created that communicate with existing deployed smart contracts that may not necessarily be written by the same developers/teams — just as we demonstrate now below.

_Creating a Server (with NodeJS)_

We now discuss creating a NodeJS server that will be used to serve
content to requesting users. You can use any other framework to create server-side code if you wish (such as Python, PHP, .NET, Java, or any other framework you may prefer). We’ll use NodeJS' express package. Follow these steps to create the server:

. First, you need to ensure that NodeJS is installed, and that you can run 'node' and 'npm' from the command line.
. Create a new directory where your server code will be saved. We’ll refer to this as the 'server' directory.
. In the server directory, run: *npm init* +
and for ease of this tutorial, you can just keep all default settings. +
 +
 This will create a package.json file that defines the settings of the NodeJS project. Verify that the 'main' setting is set to 'index.js'. This setting defines the main entry point file for code in the NodeJS project.
. Create the 'index.js' file in the server directory.
. The template code is provided below.
. We are making use of the 'express' package, and therefore need to install it. You can do so by running the following command: *npm install express*
. Create an HTML file that the server will send to the client. We’ll call this index.html. For now, just put the text 'Hello World!' in index.html and save the file.
. Thereafter you can run the server using the following command: *node index.js*
. Open a browser, and go to the url: localhost:3000 +
 You should see a page similar to <<node-hello-world>>

[source,javascript]
----
const express = require('express');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
});

app.listen(port, () => {
    console.log(`Server is running at http://localhost:${port}`);
});
----

[[node-hello-world]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.A first web server!.
[#node-hello-world]
image::node-hello-world.png[pdfwidth=45%]

[[para-csc, Creating Client-Side Code]]_Creating the Client-Side Code to Connect to the Wallet_

Now that we have a server able to send HTML/JavaScript to end-users, let’s write the client-side code to connect to a user’s wallet and interact with the underlying smart contracts. We’ll only provide the bare minimal code that is needed. Indeed, you may want to look into implementing a full HTML page (including html, head and body tags), but we’ll only provide the necessities for the sake of simplicity.

First, we’ll create an HTML button and JavaScript that will connect the client-side code to the wallet. The code to provide a connect button is provided below.

[source,javascript]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>

<script>
  async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
      try {
        let lace = await window.cardano.lace.enable();
        const walletAddressUsed = await lace.getUsedAddresses();
        console.log("Connected to Lace Wallet.");
        console.log("Addresses Used:", walletAddressUsed);
      } catch (error) {
        console.error("Error connecting to Lace Wallet:", error);
      }
    } else {
      console.error("Lace Wallet not found");
    }
  }
</script>
----

After reloading the webpage (i.e. refreshing the url, localhost:3000), you should see the button on screen. If the code is correct, once you press the button, the Lace wallet should pop-up requesting the user to allow for the underlying client-side code to be able to connect to the Lace wallet as depicted in <<dapp-connect-to-lace>>. Upon confirming that the DApp can connect to the wallet, we will not see any changes in the page, since we did not provide any code to do so. However, if you check the developer console in the browser you should see the output messages stating that the we successfully managed to connect the wallet to the client-side JavaScript and also the addresses used.

[[dapp-connect-to-lace]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Connect the DApp to Lace.
[#dapp-connect-to-lace]
image::dapp-connect-to-lace.png[]

Now that we have connected the client-side code to the wallet, we'll write some code that will interact with an underlying smart contract. Just before we do this though, we'll now package some libraries that we need to use in the client-side JavaScript.

_Packaging Libraries for use in Client-Side JavaScript_

In the client-side JavaScript code, we'll use Mesh - a library that will provide an easier-to-use interface to interact with the smart contracts deployed on the blockchain. To do so, we'll package the Mesh library using webpack and serve it to the client-side JavaScript code. Indeed, you can use a different method to package and serve the library. The code we provide here may require changes (especially when considering different versions of sdks used, e.g. NodeJS). If the code does not work out-of-the-box you may need to investigate how to package and deploy libraries and/or fix this code as required for your environment. We will not delve into the intricacies of this code but you may want to read up on how to package and serve libraries for client-side JavaScript code.

To export the Mesh library follow these steps:

. Install webpack and webpack-cli by running:
[source]
----
npm install --save-dev webpack webpack-cli
----

[start=2]
. Install @meshsdk/core, path-browserify, stream-browserify, crypto-browserify, buffer, and process by running:
[source]
----
npm install @meshsdk/core path-browserify stream-browserify crypto-browserify buffer process
----

[start=3]
. In the NodeJS application, create the file ./mesh-entry.js with the following code:

[source,javascript]
----
import * as Mesh from '@meshsdk/core';
export {
    BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder,
    KoiosProvider,
} from '@meshsdk/core';
----

[start=4]
. Create the ./webpack.config.js file with the following code:

[source,javascript]
----
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: './mesh-entry.js',
  mode: 'production',
  output: {
    filename: 'mesh.bundle.js',
    path: path.resolve(__dirname, 'public/js'),
    library: 'Mesh',
    libraryTarget: 'window',
  },
  experiments: {
    topLevelAwait: true,
  },
  resolve: {
    fallback: {
      fs: false,
      path: require.resolve('path-browserify'),
      stream: require.resolve('stream-browserify'),
      crypto: require.resolve('crypto-browserify'),
      buffer: require.resolve('buffer/'),
      process: require.resolve('process'),
    },
  },
  plugins: [
    new webpack.ProvidePlugin({
      Buffer: ['buffer', 'Buffer'],
      process: 'process',
    }),
  ],
};
----

[start=5]
. Run webpack to generate the bundles Mesh library:
[source]
----
npx webpack
----

[start=6]
. If successful, the bundled client-side JavaScript code will be generated at the following path: ./public/js/mesh.bundle.js

. The NodeJS ./index.js application should be updated to allow for the bundled Mesh library to be served to clients by adding the following line:

[source,javascript]
----
app.use(express.static(__dirname + '/public'));
----

The full updated ./index.js code follows:

[source,javascript]
----
const express = require('express');

const app = express();
const port = 3000;

app.use(express.static(__dirname + '/public'));

app.get('/', (req, res) => {
    res.sendFile(__dirname + '/index.html');
});

app.listen(port, () => {
    console.log(`Server is running at http://localhost:${port}`);
});
----


_Using the Bundled Mesh Library in the Client-Side JavaScript_

Now, we'll use the bundled mesh library in the client-side JavaScript to communicate with smart contracts.

We'll expand on the HTML file described above (in the section covering <<para-csc>>). Again, for simplicity sake we'll encode all HTML and JavaScript into a single file (which we called index.html). We'll start by adding the boilerplate functionality to use the bundled library:

. Import the bundled library:

[source,javascript]
----
<script src="js/mesh.bundle.js"></script>
----

[start=2]
. In the script tag, we'll get references to the objects and functions needed:

[source,javascript]
----
<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding
} = window.Mesh;
----

[start=3]
. The full updated index.html should look like this:

[source,javascript]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>

<script src="js/mesh.bundle.js"></script>

<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding
} = window.Mesh;

async function connectWallet() {
  if (window.cardano && window.cardano.lace) {
    try {
      let lace = await window.cardano.lace.enable();
      const walletAddress = await lace.getUsedAddresses();
      console.log("Connected to Lace Wallet:", walletAddress);
    } catch (error) {
      console.error("Error connecting to Lace Wallet:", error);
    }
  } else {
    console.error("Lace Wallet not found");
  }
}
</script>
----

[start=4]
. To test this code, the Node server will need to be started (potentially restarted), and the page loaded by opening the url localhost:3000 in a browser. Then check to make sure that loading of the library and loading of the Mesh library objects and functions do not raise any errors (though you might see an error relating to not being able to load favicon.ico).


==== Interacting with the Redeemer 42 Smart Contract

To demonstrate DApp interaction, we'll start by writing client-side JavaScript code to interact with the Redeemer 42 smart contract.footnote:[See https://github.com/LukaKurnjek/ppp-plutusV3-plinth/blob/main/off-chain/meshjs/Week02/redeemer42-ref-script.ts for a #hhh# example from the #aaa# which this chapter builds on.] You can read Section <<Simple validation scripts>> to get a better understanding of the Redeemer 42 Script (if you have not already done so). We'll start by sending funds to the smart contract and then #XXXX#.

_Sending Funds to the Redeemer 42 Smart Contract_

To add functionality that sends funds to the Redeemer 42 smart contract follow these steps:

. Add into the client-side JavaScript code the following to get a reference to the deployed Redeemer 42 smart contract:

[source,javascript]
----
const redeemer42Script = {
  code: applyCborEncoding("581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01"),
  version: "V3"
};
const redeemer42Addr = resolvePlutusScriptAddress(redeemer42Script, 0);
----

[start=2]
. Then to actually send funds we'll use the following code (that is explained in below the code):

[source,javascript,linenums]
----
async function sendFunds(amount) {
    const wallet = await BrowserWallet.enable('lace');
    const walletAddress = await wallet.getChangeAddress();
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preview")
        .sendLovelace({ address: redeemer42Addr }, amount)
        .setChangeAddress(walletAddress);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash;
}
----

Line number 2 connects to the wallet (if it has not already been connected to, e.g. using the connect button we already created).

Line number 3 gets the change address, #discussed in Chapter XXX#, that will be passed set for the transaction being constructed.

Line numbers 4-7 set the required parameters for the transaction including: passing in a reference to the wallet we're using to send funds, the network (i.e. #preprod#), the smart contract address (computed in the 1st step) and the amount of Lovelace (#discussed in Chapter XXX#) to send, and the change address.

In line number 9, 10 and 11, we build the transaction, sign it and submit the transaction respectively.

[start=3]
. We also add a 'Send Funds' button to call the added functionality to send 3,000,000 Lovelace (3 Ada) to the smart contract.

For reference, the full updated index.html file follows:

[source,javascript]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>
<button id="sendFunds" onclick="sendFunds('3000000')">Send Funds</button>

<script src="js/mesh.bundle.js"></script>

<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding
} = window.Mesh;

const redeemer42Script = {
  code: applyCborEncoding("581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01"),
  version: "V3"
};
const redeemer42Addr = resolvePlutusScriptAddress(redeemer42Script, 0);

async function sendFunds(amount) {
    const wallet = await BrowserWallet.enable('lace');
    const walletAddress = await wallet.getChangeAddress();
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preview")
        .sendLovelace({ address: redeemer42Addr }, amount)
        .setChangeAddress(walletAddress);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash;
}

async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
        try {
            let lace = await window.cardano.lace.enable();
            const walletAddress = await lace.getUsedAddresses();
            console.log("Connected to Lace Wallet:", walletAddress);
        } catch (error) {
            console.error("Error connecting to Lace Wallet:", error);
        }
    } else {
        console.error("Lace Wallet not found");
    }
}
</script>
----

After running the NodeJS server and refreshing the page (i.e. refreshing localhost:3000), you should see the added button 'Send Funds':

[[fig-sendFunds]]
[caption="Figure {counter:figure}. ", reftext="Figure {figure}"]
.Added 'Send Funds' button.
[#fig-sendFunds]
image::redeemer42-sendFunds.png[pdfwidth=50%]

Upon clicking 'Send Funds' the wallet should pop-up asking that you confirm sending 3 Ada to the smart contract.

_Deploying a reference script for the Redeemer 42 Smart Contract_

To add functionality that deploys a reference script for the Redeemer 42 smart contract follow these steps:

. First, we'll import the MeshTxBuilder and KoiosProvider objects from the mesh sdk bundle we created before. The added lines are denoted by the 'added now' comments:

[source,javascript]
----
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder, //added now
    KoiosProvider //added now
} = window.Mesh;
----

[start=2]
. We will make use of an RPC provider, which allows for querying of parameters for the blockchain. We'll make use of KoiosProvider provided by mesh SDK, but you could also look into using other providers:

[source,javascript]
----
const provider = new KoiosProvider('preview');
----

[start=3]
. Then we compute the burn address where we'll deploy the reference script to:

[source,javascript]
----
const burnScript = {
  code: applyCborEncoding("450101002601"),
  version: "V3"
};
const burnAddr = resolvePlutusScriptAddress(burnScript, 0);
----

[start=4]
. A function that will handle deploying the reference script follows:

[source,javascript,linenums]
----
async function deployRefScript(amount) {
    const wallet = await BrowserWallet.enable('lace');
    const walletAddress = await wallet.getChangeAddress();

    const utxos = await wallet.getUtxos();
    const txBuilder = new MeshTxBuilder({
        fetcher: provider
    });

    const unsignedTx = await txBuilder
        .txOut(burnAddr, [{ unit: "lovelace", quantity: amount }])
        .txOutReferenceScript(redeemer42Script.code, redeemer42Script.version)
        .changeAddress(walletAddress)
        .selectUtxosFrom(utxos)
        .complete();

    const signedTx = await wallet.signTx(unsignedTx);
    const txHash = await wallet.submitTx(signedTx);
    return txHash;
}
----

Lines 2 and 3 were already discussed above. Line 5 gets the wallet's UTXOs (unspent transactions) that could be used (for the transaction that will be submitted). Lines 6-8 defines a transaction builder that will help us build the transaction (to deploy the reference script). We pass in the provider that will be used to help the MeshTxBuilder request parameters and interact with the blockchain. Lines 10-15 build the transaction to deploy the reference script, and then the transaction is signed and submitted (on lines 17 and 18).

[start=5]
. Finally, we'll add a button to test out the deploy reference script functionality:

[source,javascript]
----
<button id="deployRefScript" onclick="deployRefScript('3000000')">Deploy Reference Script</button>
----


The whole code should now look something like this:

[source,javascript,linenums]
----
<button id="connectWallet" onclick="connectWallet()">Connect Wallet</button>
<button id="sendFunds" onclick="sendFunds('3000000')">Send Funds</button>
<button id="deployRefScript" onclick="deployRefScript('3000000')">Deploy Reference Script</button>

<script src="js/mesh.bundle.js"></script>

<script>
const { BrowserWallet,
    Transaction,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    MeshTxBuilder,
    KoiosProvider,
} = window.Mesh;

const redeemer42Script = {
  code: applyCborEncoding("581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01"),
  version: "V3"
};
const redeemer42Addr = resolvePlutusScriptAddress(redeemer42Script, 0);

const provider = new KoiosProvider('preview');

const burnScript = {
  code: applyCborEncoding("450101002601"),
  version: "V3"
};
const burnAddr = resolvePlutusScriptAddress(burnScript, 0);

async function deployRefScript(amount) {
    const wallet = await BrowserWallet.enable('lace');
    const walletAddress = await wallet.getChangeAddress();

    const utxos = await wallet.getUtxos();
    const txBuilder = new MeshTxBuilder({
        fetcher: provider
    });

    const unsignedTx = await txBuilder
        .txOut(burnAddr, [{ unit: "lovelace", quantity: amount }])
        .txOutReferenceScript(redeemer42Script.code, redeemer42Script.version)
        .changeAddress(walletAddress)
        .selectUtxosFrom(utxos)
        .complete();

    const signedTx = await wallet.signTx(unsignedTx);
    const txHash = await wallet.submitTx(signedTx);
    return txHash;
}

async function sendFunds(amount) {
    const wallet = await BrowserWallet.enable('lace');
    const walletAddress = await wallet.getChangeAddress();
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preview")
        .sendLovelace({ address: redeemer42Addr }, amount)
        .setChangeAddress(walletAddress);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash;
}

async function connectWallet() {
    if (window.cardano && window.cardano.lace) {
        try {
            let lace = await window.cardano.lace.enable();
            const walletAddress = lace.getUsedAddresses();
            console.log("Connected to Lace Wallet:", walletAddress);
        } catch (error) {
            console.error("Error connecting to Lace Wallet:", error);
        }
    } else {
        console.error("Lace Wallet not found");
    }
}
</script>
----




#Discuss decentralising web servers, the trade-offs and options.
Close-off with challenges and UI issues, and what the future may hold.#


#Continue with a note on on-chain/off-chain SCs parts?#

=== Onchain vs Off Chain Code
#rewrite the below in context of the above... potentially remove as a lot was covered in the beginning#
In the Cardano and Plutus context, on-chain and off-chain codes refer to two different aspects of the same smart contract system.

On-chain code refers to the part of a smart contract that runs on the blockchain itself. This code is written in Plutus Core, and it essentially implements the custom logic that controls how the contract's assets can be spent. Once a smart contract is deployed, its on-chain code becomes unchangeable—it is, in fact, a part of the blockchain.
