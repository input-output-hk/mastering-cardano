:source-highlighter: rouge
:rouge-style: gruvbox
:pdf-theme: custom-theme.yml

= Writing smart contracts

:url-repo: https://github.com/input-output-hk/mastering-cardano/chapters
:imagesdir: images

== Plutus Preface

Prof Philip Wadler, FRS

University of Edinburgh and IOG

Smart contracts for the Cardano blockchain run in a language called
Plutus. Roughly speaking, Plutus plays the role for Cardano that the
Ethereum Virtual Machine (EVM) plays for Ethereum. But where the EVM
requires a dense forty-two-page yellow paper to define, the key
concepts of Plutus can be spelled out in less than one page.

The reason for this is that Plutus is based on the lambda calculus,
first defined by the logician Alonzo Church in the 1930s, and an
elaboration of the lambda calculus called System F, first defined by
the logician Jean-Yves Girard in the 1970s. To be fair, that claim is
a bit of an oversimplification. While the core of Plutus is indeed
based on those systems and can be described quite concisely, Plutus
also contains a collection of built-in operators and rules for costing
which take longer to spell out.

The reason for designing a language with such a tiny core is tied
closely to the needs of the Cardano blockchain. Any significant
updating of Cardano, including a change to the definition of Plutus,
requires a hard fork, and it is highly desirable to avoid these. How
do you design a system that can last unchanged for the next fifty
years? Base your design on a system that is fifty years old!

Because this fifty-year old theory would now be executed directly on
the Cardano blockchain carrying billions of dollars of value, there
was a business case for formally validating that theory. IOG hired
James Chapman to validate our variant of System F in the Agda proof
assistant - James having written his dissertation on a related subject
and being one of the foremost experts. The completed proof validated
the theory. It also gave us an executable version of
Plutus. Continuous Integration ensures the production Plutus
implementation is regularly checked against the executable formal
specification. Further, the formal specification serves as the
foundation for a new effort to write a validator that issues checkable
certificates to ensure phases of the compiler optimise code
correctly. James is now head of Formal Methods for IOG.

Everything should be made as simple as possible, but not simpler.
Arguably our initial simple design is too simple. It requires
representing data types as higher-order functions, but we had reason
to believe the extra cost was negligible. Always check your
assumptions! Once the system was up and running, performance
measurements showed the cost of implementing data structures as
functions was greater than expected. So we modified the design to
support data structures directly, and the feature will appear in the
next version of Plutus.

The on-chain production evaluator for Plutus is written in Haskell,
one of the most widely-used functional programming languages. Plutus
is designed to represent the output of a compiler, and no one should
write it directly. Haskell can also be used a source-language for
creating Plutus scripts, using the Plinth language embedded into
Haskell. On Ethereum, one must learn the special-purpose language
Solidity to write smart-contracts that compile to the EVM. In contrast,
on Cardano one can use the Haskell language that was designed by an
expert team of researchers thirty years ago, and has a mature and
stable core even though it is still an actively growing research
language. The brilliant idea to apply Haskell in this way is due
to Manuel Chakravarty, a contributor to both the design and
implementation of Haskell.

In addition to Plinth (embedded in Haskell) there are a wide range of
other languages that can also be used to generate smart-contracts in
Plutus to run on Cardano. These include: Aiken (a stand-alone
language), Plutarch (also embedded in Haskell), Plu-ts (embedded in
TypeScript), OpShin (embedded in Python), Scalus (embedded in Scala),
Helios (which runs on top of JavaScript and TypeScript), and Pluto
(which closely resembles Plutus with added syntactic sugar for
convenience). Marlowe, which is not a general purpose language but
aims to make it easy to write certain kinds of financial contracts, is
also available.

Many people have contributed to the designs of Plutus and Plinth. I
won't attempt to name them all here, because with my absent-minded
professor's memory I fear I would leave someone out. I am grateful for
the opportunity I've had to work with them and with everyone at
IOG. I'm particularly grateful to Charles Hoskinson for the
opportunity to collaborate with IOG. It's been an amazing
experience - it's not often that you can suggest a practical
application of a fifty-year old theory, and have people take you
seriously!

== Smart contract programming languages

Cardano smart contract languages can be grouped into three categories:

* Native languages that run on the Cardano node
* Compiled languages that can be compiled to a native language
* Interpreted languages that are interpreted by a compiled language.

*Native languages*

The Cardano node can only process native languages. Currently, there are
two available: simple scripts and Plutus Core.

The Shelley era introduced script addresses and simple scripts, also
known as native scripts. They can be used for multi-signature addresses,
requiring multiple keys to sign a transaction to spend funds. The
Allegra era extended simple scripts by adding conditional time-based
functionality. This allows the creation of addresses with ‘time locks’,
where funds can only be withdrawn before or after a specified time. A
script can also be written to allow one group of keys to spend funds
before a certain time, and another group after. You can read more about
simple scripts in the
https://github.com/input-output-hk/cardano-node-wiki/wiki/simple-scripts[Cardano
node wiki] GitHub repository.

The Alonzo era introduced the Plutus Core scripting language, often
referred to as Plutus. Since Plutus smart contracts validate
transactions, they are also called validation scripts or validators.
Plutus is a simple, functional language that enables general-purpose
Turing-complete (see <<Glossary>>) smart contracts on Cardano. It implements Cardano’s extended UTXO
(EUTXO) model, which is as powerful in expressing smart contract logic
as Ethereum’s account-based model, allowing for arbitrary logic in smart
contracts. The EUTXO model is explained in detail in section 
<<The EUTXO model>>. A comparison of Plutus with Bitcoin Script and
Solidity languages is presented in section 
<<Plutus in comparison to Bitcoin Script and Solidity>>.

In practice, the Cardano node executes an untyped version called Untyped
Plutus Core (UPLC). The compilation pipeline and other Plutus details
are covered in section <<Plutus security>>. The security advantages
of Cardano’s EUTXO model over Ethereum’s account-based model are
discussed in section <<Cardano security>>.

*Compiled languages*

Smart contract developers do not write code directly in Plutus. Instead,
they use compiled or interpreted languages that are compiled into
Plutus. The language developed by Input | Output (IO) that compiles to
Plutus is called Plinth, previously known as PlutusTx. Plinth is a
Turing-complete subset of the Haskell programming language
(https://www.sciencedirect.com/science/article/pii/S0167642323001338#se0070[Krijnen
et al], 2023). It draws from modern language research to provide a
safe, full-stack programming environment based on Haskell, the leading
purely functional programming language. It is a general-purpose smart
contract language that focuses on security. The basics of coding smart
contracts in Plinth are explained in section <<Plutus smart contracts>>.

The logic in other compiled Cardano smart contract languages follows the
same rules defined by Plutus. Learning one compiled language also helps
understand other compiled languages with different syntaxes from Plinth.

There are also other compiled smart contract languages developed by
companies within the Cardano ecosystem. They are all domain-specific
languages
(https://en.wikipedia.org/wiki/Domain-specific_language[DSL]) as they
target the smart contract domain. Some of them, including Plinth, are
embedded DSLs
(https://en.wikipedia.org/wiki/Domain-specific_language#External_and_Embedded_Domain_Specific_Languages[eDSL])
because they are implemented as libraries in a general-purpose
programming language. Some examples include:

* https://aiken-lang.org/[Aiken]: a unique, typed, purely functional
DSL; IO plans to support its development in the future
* https://github.com/HarmonicLabs/plu-ts[Plu-ts]: a typed eDSL in
TypeScript
* https://opshin.dev/[OpShin]: a typed eDSL in Python
* https://github.com/hyperion-bt/helios[Helios]: a
Javascript/Typescript SDK and typed DSL
* https://github.com/plutonomicon/plutarch-plutus[Plutarch]: a typed
eDSL in Haskell for writing efficient Plutus validators
* https://scalus.org/[Scalus]: a typed eDSL in Scala.
* https://github.com/Plutonomicon/pluto[Pluto]: a DSL resembling UPLC
with some syntactic sugar, written in a Haskell-like syntax

You can refer to the
https://cardano-foundation.github.io/state-of-the-developer-ecosystem/2024/#what-do-you-use-or-plan-to-use-for-writing-plutus-script-validators-smart-contracts[State
of the Cardano Developer Ecosystem report] – 2024 to see how much these
languages are used in practice. As of 2024, the most commonly used ones
are Aiken and Plinth. A comparison of these languages is discussed in
section <<Plinth in comparison to Aiken>>. A brief comparison of
some of the listed languages can also be found in the following blog
posts:

* The Essential Cardano blog post about
https://www.essentialcardano.io/article/programming-languages[programming
languages]
* The Emurgo blog post about
https://www.emurgo.io/press-news/the-programming-languages-behind-cardano-on-chain-code/[the
programming languages behind Cardano on-chain code].

Languages that compile to Plutus generate scripts that have the same
logic, but might be optimized differently for factors like size or
performance. Existing community guidelines and tools can help optimize
Plutus scripts for size, CPU, and memory consumption, reducing
transaction fees. These tools can also help analyze the fees users will
encounter while interacting with a Plutus script. The official
documentation provides more information on the
https://docs.cardano.org/about-cardano/explore-more/fee-structure/[Cardano
fee structure]. Links to Cardano developer tools are provided at the
end of this section. Some examples of projects that can be built using
Plinth or other compiled Cardano smart contract languages include:

* NFT marketplaces and platforms (https://www.nmkr.io/[NMKR],
https://cardahub.io/home[CardaHub],
https://www.jpg.store/[JPGStore], https://flipr.io/[Flipr],
https://jamonbread.io/[JamOnBread])
* Decentralized exchanges (DEX) (https://muesliswap.com/[MuesliSwap],
https://minswap.org/[MinSwap], https://sundaeswaap.com/[SundaeSwap],
https://www.geniusyield.co/[GeniusYield])
* Automated lending and borrowing platforms
(https://liqwid.finance/[Liqwid], https://www.meld.com/[MELD],
https://lenfi.io/[Lenfi], https://fluidtokens.com/[FluidTokens])
* Digital identity management platforms
(https://github.com/hyperledger/identus[Identus], https://iamx.id/[IAMX],
https://www.profila.com/[Profila], https://identity.cardanofoundation.org/[Identity wallet])
* Decentralized, blockchain-powered mobile network
(https://worldmobile.io/en[WorldMobile])
* Decentralized artificial intelligence systems
(https://singularitynet.io/[SingularityNET],
https://cardanogpt.ai/[CardanoGPT])
* Decentralized autonomous organizations (DAO)
(https://indigoprotocol.io/#indigo-dao[IndigoDAO], 
https://www.clarity.vote/organizations/CharityDAO[Charity DAO], 
https://github.com/eLearningDAO[eLarning DAO])
* Decentralized synthetic assets protocol
(https://indigoprotocol.io/[IndigoProtocol])
* Decentralized prediction markets (https://foreon.network/[Foreon])
* Decentralized cloud storage systems
(https://iagon.com/storage[Iagon]).

You can also explore active projects built on Cardano on the pages
below. These pages categorize projects into areas like DEX, identity and
data, lending and borrowing, developer tools, education, artificial
intelligence (AI), decentralized finance (DeFi), infrastructure,
marketplaces, and more:

* https://www.cardanocube.com/cardano-ecosystem-interactive-map[CardanoCube
interactive map]: presents projects in a visually engaging, interactive
format. For each selected project, the page provides a description, a
price chart (if the project has a token), and links to an official
webpage, white paper, social media pages, and GitHub repository.
* https://cardanospot.io/project-library/all[CardanoSpot project
library]: offers a category filter to list projects by certain
categories. For each selected project, a description is provided along
with links to the official page and a white paper.
* https://developers.cardano.org/showcase[Cardano developers showcase]
page: tags projects by groups and adds a short description to each.

*Interpreted languages*

The third category of smart contract languages in Cardano consists of
interpreted languages that are interpreted by a compiled language.
https://marlowe.iohk.io/[Marlowe], initially developed by IO, is an
interpreted smart contract language that is not Turing-complete. It is
well-suited for designing financial contracts, such as those defined in
the https://www.actusfrf.org/[ACTUS] (Algorithmic Contract Types
Unified Standards) standard, for example. The Marlowe interpreter is
written as a Plinth smart contract. Besides the programming language,
the Marlowe project provides open-source tools to easily create, verify,
and deploy secure financial smart contracts on Cardano. You can write
smart contracts in JavaScript and Haskell or use Blockly, a visual
coding solution. All language options are available in the online
development environment –
https://playground.marlowe-lang.org/#/[Marlowe playground]. The
Marlowe language, its tools, architecture, and contract examples are
presented in section <<Marlowe smart contracts>>.

With Marlowe, it is possible to design a diversity of contracts for the
following domains:

* Bonds, forwards, options, futures, swaps, etc
* Structured financial products
* Escrows
* Auctions
* Peer-to-peer loans
* Token swaps
* Airdrops.

Sections <<Marlowe security>> and <<Marlowe best practices>>
explore the security of Marlowe in more detail.

*On-chain and off-chain code*

Sometimes, smart contract code is referred to as on-chain code because
it runs in the node during the inclusion of new transactions that aim to
spend a UTXO at a script address. Off-chain code, in contrast, runs on
the user’s or a service provider’s device and queries the blockchain, 
builds, signs and submits transactions. A web application that
connects with a wallet and interacts with one or more smart contracts is
called a decentralized application (DApp). Chapter <<Decentralized applications>> 
covers DApps in more detail. Every DApp contains some
off-chain code and interacts with one or more smart contracts that
represent the on-chain code. Off-chain code tasks can be
performed with a command line tool, such as the
https://github.com/IntersectMBO/cardano-cli/tree/main[Cardano CLI], or
with the help of libraries and builder tools that are embedded in
popular programming languages. Some of them include:

* https://blockfrost.dev/sdks[Blockfrost SDK]: enables access to the
Blockfrost API layer for Cardano. The SDK is provided in various
programming languages such as Arduino, .NET, Crystal, Elixir, Go,
Haskell, Java, JavaScript, Kotlin, PHP, Python, Ruby, Rust, Scala and
Swift.
* https://meshjs.dev/[MeshJS]: a NodeJS-based open-source library
providing numerous tools to easily build DApps on Cardano. It also
integrates the popular https://react.dev/[React] library.
* https://lucid.spacebudz.io/[Lucid]: a popular JavaScript/Typescript
library for off-chain code, which will be further maintained by the
https://anastasia-labs.github.io/lucid-evolution/[Lucid Evolution]
project funded by
https://projectcatalyst.io/funds/11/cardano-open-developers/anastasia-labs-lucid-evolution-redefining-off-chain-transactions-in-cardano[Catalyst
Fund11].
* https://atlas-app.io/[Atlas]: an all-in-one, Haskell-native
application backend for writing off-chain code for Plutus smart
contracts.

Explore some Cardano tools that can be used for building DApps at:

* The https://developers.cardano.org/tools/[Builder Tools] page on the
Cardano Developer portal. You can filter the tools by
language/technology or by domain. Every tool contains a short
description.
* The
https://www.essentialcardano.io/article/a-list-of-community-built-developer-tools-on-cardano[Cardano
community-built developer tools] list hosted on Essential Cardano.

You can also look at the State of the Cardano Developer Ecosystem report
– 2024, listing the most commonly used
https://cardano-foundation.github.io/state-of-the-developer-ecosystem/2024/#which-libraries-do-you-use-in-your-projects[Cardano
libraries].

This chapter also presents the Lucid tool and showcases how to write
off-chain code for smart contracts in sections 
<<Off-chain code with Lucid>> and <<Minting policies>>.

== Smart contract case studies

*World Mobile Token smart contracts*

The https://worldmobile.io/en[World Mobile] company offers an
interesting case study of a solution that can change the current state
of internet networks. With the help of the Cardano blockchain and smart
contracts, the company provides a sharing economy model to deliver
network infrastructure and enable connectivity in a more distributed and
decentralized manner.

The establishment of a sharing economy leads to reduced operational
costs and more efficient resource allocation. Additionally, the
token-based, decentralized nature of this sharing economy makes the
model highly scalable in terms of deployment. Instead of depending on a
centralized network operator to continuously assess the network's
capacity and demand, which is always changing, the network's expansion
is driven by the communities that require access to the internet. Smart
contracts play a key role here: they remove intermediaries and
incentivize network expansion through an automated reward system,
whereby operators are rewarded for providing good quality services.

*Network overview*

The World Mobile network consists of three layers of nodes, each with
different responsibilities:

* *Earth nodes* contain the core business logic of the World Mobile
Chain. They provide an authentication layer (decentralized identity
module), manage all blockchain transactions (blockchain module), and
include a telecommunications layer (telecommunications layer).
* https://airnode.worldmobile.io/[*Air nodes*] are located in areas
where connectivity is needed. They serve as the first point of contact
with the network for individual users or entire communities.
* *Aether nodes* interface with legacy telecommunications networks. They
handle protocol translations, media transcoding, and the routing of
traffic to these networks.

*Earth nodes core logic*

To simplify the business logic complexity within the network, Earth
nodes are responsible for calling the appropriate smart contracts. For
example, Earth nodes handle the processing of rewards for other nodes,
ensuring automated payments are made once the conditions of the smart
contracts are met. Additionally, Earth nodes process and verify
identities provided by Air nodes, responding with the user's available
account balance and a list of available services.

Earth node operators must stake a certain amount of tokens to join the
network. The minimum number of tokens required to operate an Earth node
is set at 100,000 tokens, as specified in the initial blockchain
parameters. Each Earth node earns rewards based on several factors.
Firstly, rewards are given for producing and committing blocks to the
blockchain, which includes financial settlements and metadata such as
the hash reference to call details records (CDRs). Secondly, node
operators are rewarded for providing services to users, such as routing
communication traffic (voice, SMS, etc).

Earth nodes can operate from any location globally; however, traffic
routing within the network is biased towards nearer nodes to enhance
performance and service quality.

*World Mobile token and Earth node non-fungible tokens (NFTs)*

Utilizing Cardano's native token capabilities, World Mobile introduced
the https://worldmobiletoken.com/[World Mobile Token] (WMT) as the
primary currency for transactions and reward distribution within its
ecosystem. The primary purpose of a WMT is to incentivize both token
holders and node operators. Token holders support network operations by
delegating their WMTs to node operators (stakers) who manage nodes to
support the network. There is a finite supply of two billion WMTs, with
only a portion initially circulating.

Additionally, there exists another currency within the World Mobile
ecosystem – Earth node non-fungible token (ENNFT). ENNFTs are created
using Cardano's native token functionality and are issued to Earth node
owners who locked 100,000 WMT to a smart contract before January 4,
2023. These NFTs provide monthly rewards; each month, Earth node owners
receive 1,300 WMT (1.3%) for maintaining their node.

*Cardano within the WMT sharing economy model*

In contrast to traditional network models, the operation and maintenance
of nodes within the WMT sharing economy model are shared with
communities and local businesses. This approach enhances scalability and
reduces costs by allocating resources to areas where they are most
needed. Leveraging blockchain technology and smart contracts offers
numerous advantages that align seamlessly with this distributed model:

* *Transparency*: Cardano records information that can be easily
accessible to different stakeholders to make more informed decisions
* *Privacy*: user information is stored using private/public encryption
provided by Cardano
* *Immutability*: Cardano’s EUTXO model ensures transaction immutability
and restricts spending to only unspent transaction outputs, making the
reward system more deterministic.

== Cardano addresses

A blockchain address serves as a communication link between the
blockchain and the user. With the introduction of stake pools in the
Shelley era, a Cardano address consists of two parts: the _payment_ part
and the _staking_ part.

image::sc_cardano_address.png[width=400,height=200,title="Cardano address"]

Both parts of a Cardano address are cryptographically derived from the
private key, containing the same owner information. The payment part,
which is always present, determines the conditions under which a UTXO at
the address can be spent. It is either defined by the hash of a public
key or a Plutus script. If it contains a public key hash, UTXOs can only
be spent if the transaction is signed with the corresponding private
(signing) key. If it contains a script hash, the script executes during
validation to decide whether UTXOs at the address can be spent.

The optional staking part controls delegation and staking rewards. If
defined with a public key hash, the corresponding private key owner can
spend the rewards. If defined with a script hash, the script determines
the conditions under which staking rewards can be spent.

Cardano Shelley addresses can be divided into four categories:

* Base addresses
* Pointer addresses
* Enterprise addresses
* Reward account addresses.

Only __base __and __pointer __addresses carry staking rights. The _base_
address directly specifies the staking key controlling the stake, while
a _pointer_ address indirectly specifies it. The advantage of the
_pointer_ address is that it can be considerably shorter than the hash
used in base addresses. _Enterprise_ addresses, which carry no staking
rights, are also shorter and can be used for sending and receiving
funds. _Reward account addresses_, used to distribute proof-of-stake
rewards (either directly or via delegation), are cryptographic hashes of
the public staking key. They follow the account-based model, unlike the
UTXO model. Rewards are reflected in accounts, and UTXOs are created
only when rewards are withdrawn.  +
 +
The Shelley era continued to support Byron-era _bootstrap addresses_ and
_script addresses_. The
https://docs.cardano.org/learn/cardano-addresses/[Cardano addresses]
documentation page provides more information about address categories.

=== Binary format

Under the hood, a Cardano address is a sequence of bytes that conforms
to a particular format. Users will typically interact with addresses
only after they have been encoded into sequences of human-readable
characters. https://en.bitcoin.it/wiki/Bech32[Bech32] and
https://bitcoinwiki.org/wiki/base58[Base58] are encodings used in
Cardano as opposed to standard hexadecimal notation
(https://en.wikipedia.org/wiki/Hexadecimal[Base16]). These encodings
represent the addresses users perceive, though they are distinct from
the underlying byte sequences. Shelley addresses, which include staking
addresses, use Bech32 encoding without a character length limit. In
contrast, Byron addresses are encoded in Base58, allowing for easy
differentiation from Shelley-era addresses. Below are examples of the
different address types:

image::sc_address_types.png[width=936,height=147,title="Address types, source: https://cips.cardano.org/cip/CIP-19[CIP-19]"]

In Cardano addresses, the sequence of bytes (decoded from _Bech32_ or
_Base58_) consists of two parts – a one-byte header and a payload of
several bytes. Depending on the header, the interpretation and length of
the payload varies. In the header byte, the bits from 7 to 4 indicate
the type of addresses being used; we'll call these four bits the header
type. The remaining four bits from 3 to 0 are either unused or refer to
what we call the network tag. You can see a graphical representation
below:

image::sc_address_structure.png[width=266,height=192,title="Address structure, source: https://cips.cardano.org/cip/CIP-19[CIP-19]"]

Depending on the various header types and address formats, there are
currently 11 types of addresses in Cardano which are either Shelley or
Byron addresses, including the addresses used for staking. You can see
the various address structures below:

[source,shell]
----
           TYPE  |     TAG     |   PAYMENT   |   DELEGATION   
ADDRESS = %b0000 | NETWORK-TAG | KEY-HASH    | KEY-HASH       ; type 00, Base 
                                                                Shelley address
        \ %b0001 | NETWORK-TAG | SCRIPT-HASH | KEY-HASH       ; type 01, Base 
                                                                Shelley address
        \ %b0010 | NETWORK-TAG | KEY-HASH    | SCRIPT-HASH    ; type 02, Base 
                                                                Shelley address
        \ %b0011 | NETWORK-TAG | SCRIPT-HASH | SCRIPT-HASH    ; type 03, Base 
                                                                Shelley address
        \ %b0100 | NETWORK-TAG | KEY-HASH    | POINTER        ; type 04, Pointer 
                                                                Shelley address
        \ %b0101 | NETWORK-TAG | SCRIPT-HASH | POINTER        ; type 05, Pointer 
                                                                Shelley address
        \ %b0110 | NETWORK-TAG | KEY-HASH                     ; type 06, Enterprise 
                                                                Shelley address
        \ %b0111 | NETWORK-TAG | SCRIPT-HASH                  ; type 07, Enterprise 
                                                                Shelley address
        \ %b1000 | BYRON-PAYLOAD                              ; type 08, Byron / 
                                                                Bootstrap address
        \ %b1110 | NETWORK-TAG | KEY-HASH                     ; type 14, Stake 
                                                                Shelley address
        \ %b1111 | NETWORK-TAG | SCRIPT-HASH                  ; type 15, Stake 
                                                                Shelley address

NETWORK-TAG  = %b0000 ; Testnet
             \ %b0001 ; Mainnet
----

For _Bech32_-encoded addresses (used for all Shelly addresses), the last
six characters of the data part form a checksum of the previous address
data and contain no information. This allows for quick offline validity
checks and provides an additional safety measure for wallets. For an
additional explanation of address type structures, refer to
https://cips.cardano.org/cips/cip19/#binaryformat[Cardano improvement
proposal 19 (CIP-19)], which defines the technical details of Cardano
addresses.

== Marlowe smart contracts

=== About Marlowe

Marlowe is a domain-specific language (DSL) for building financial smart
contracts. One can think of Marlowe as a robust, open-source technology
that provides a special purpose language describing asset flows on the
blockchain. As a special purpose DSL, it offers a higher-level model of
contracts in a more restricted domain than other Cardano languages
compiling directly to Plutus Core. This means that Marlowe can provide
safety guarantees, such as ensuring that no assets are held in a script
indefinitely, by the design of the language. Additionally, it offers
tools for a full analysis of potential contract faults before contract
execution.

The implementation of Marlowe on Cardano is carried out using Plinth.
Marlowe smart contracts are interpreted by a Plinth smart contract under
the hood. Marlowe enables for the implementation of specific domain
expertise to write and manage contracts conveniently, without the steep
learning curve associated with software development, blockchain, or
smart contracts. Marlowe core technology has been audited, and it
supports contracts on mainnet and pre-production testing environments.
Its Runtime enables all the necessary on- and off-chain contract
activity, including the tedious work of transaction construction. The
TypeScript SDK supports Marlowe as a component within a complete DApp.
This makes it a smart contract technology that is complementary to
Aiken, Plinth, or any other Cardano smart contract language. It
abstracts away the complexities of Cardano and provides a local,
account-based model like Ethereum.

Beyond the notable benefit of usability by non-programmers, the Marlowe
language offers many other advantages:

* Easily checks that programs have the intended properties
* Ensures high assurance that the contract consistently fulfills its
payment obligations
* Helps people write programs in the language using special-purpose
tools
* Emulates contract behavior before execution on the blockchain,
ensuring intended performance through static analysis
* Provides valuable diagnostics to potential participants before they
commit to a contract
* Formally proves properties of Marlowe contracts, delivering the
highest level of assurance regarding intended behavior through logic
tools
* Prevents certain flawed programs from being written by the design of
the language
* Mitigates some unanticipated exploits that have affected existing
blockchains.

Marlowe is modeled after special-purpose financial contract languages
popularized over the past decade by academics and enterprises, such as
LexiFi, which provides contract software for the financial sector. In
developing Marlowe, these languages have been adapted to work on
blockchain. Although it is implemented on the Cardano blockchain,
Marlowe could also be implemented on Ethereum or other blockchain
platforms, making it a ’platform-agnostic’, similar to modern
programming languages like Java and C++. Designed as an industry-scale
solution, Marlowe embodies examples from the
https://en.wikipedia.org/wiki/Algorithmic_Contract_Types_Unified_Standards[ACTUS]
taxonomy and standard for financial contracts. It can also interact with
real-world data providers through oracles, enabling contract
participants to make choices within the contract flow that determine
on-chain and off-chain outcomes, such as in a wallet.

Marlowe is based on original, peer-reviewed research conducted by the
Marlowe team, initially at the University of Kent with support from a
research grant from IO, and later as an internal engineering team within
IO. The Marlowe team at IO was also collaborating with the
https://www.uwyo.edu/wabl/index.html[Wyoming Advanced Blockchain R&D
Laboratory (WABL)] at the University of Wyoming. More information about
the research conducted for Marlowe can be found on the official
documentation page, which also lists
https://docs.marlowe.iohk.io/docs/platform-and-architecture/platform#research-based[published
research papers] related to Marlowe.

In the future, Marlowe will be administered by an independent vehicle, a
not-for-profit organization, which will ensure community representation
and stewardship. This will allow the community to actively contribute to
its roadmap and propose updates and enhancements. To further support
Marlowe’s vision, a new
https://github.com/marlowe-foundation/org/blob/main/sig-charter.md[Special
Interest Group] (SIG) has been established that is active on Discord,
focusing on Marlowe’s continued innovation and enhancement, with
builders at the heart.

In summer 2024, IO transferred the intellectual property rights for
Marlowe to the Marlowe Foundation – a non-profit organization
established to oversee the continued development of Marlowe and its
ecosystem as a community-based project. The Marlowe repositories will be
transferred to the https://github.com/marlowe-lang[marlowe-lang]
GitHub, and continued development will take place there.

=== Developer tools and services

Marlowe provides a set of open-source tools that help create, test, and
deploy secure smart contracts on Cardano. It offers intuitive solutions
to create, utilize, and monetize smart contracts with ease, catering to
developers of all expertise levels. The following developer tools and
features are available:

* *Marlowe language* – a DSL that includes a web-based platform to build
and run smart contracts
* *Marlowe Playground* – a simulator that allows testing smart contracts
before deployment to ensure intended code behavior
* *Marlowe Runner* – an easy-to-use DApp that can be used to deploy,
execute, and interact with Marlowe smart contracts
* *Marlowe Scan* – a tool for visualizing Marlowe contracts on the
Cardano blockchain
* *Marlowe Runtime* – the application backend for managing Marlowe
contracts on Cardano, which includes easy-to-use, higher-level APIs for
developers to build and deploy enterprise and Web3 DApp solutions
* *Marlowe CLI* – provides capabilities to work with Marlowe's Plutus
validators and run Marlowe contracts manually
* *Marlowe starter kit* – provides tutorials for developers to learn and
run simple Marlowe contracts on Cardano
* *Marlowe TypeScript SDK* (currently in beta) – a suite of
TypeScript/JavaScript libraries for developing web DApps on Cardano
using Marlowe technologies
* *Demeter.Run integration* – a web service that allows building Marlowe
projects without installing any software
* *Documentation website* – significantly expanded, updated, and
integrated into the updated Marlowe website.

*IMPORTANT:*
In the transition phase of Marlowe, where GitHub repositories of the
above-mentioned tools are not actively maintained by IO and the Marlowe
foundation has not received any funding from Catalyst or other sources,
some of these tools might have issues when using them with the latest
test or main network due to updates of Cardano’s ledger layer.

The
https://docs.marlowe.iohk.io/docs/platform-and-architecture/marlowe-language-guide[Marlowe
language] enables users to build contracts by combining a small number
of constructs, which can describe many different financial contracts.
Contract participants can engage in various actions: they can be asked
to deposit money or make choices between various alternatives [source:
Marlowe: implementing and analyzing financial contracts on blockchain,
Lamela et al. 2020]. Marlowe contract examples are presented in section
<<Contract examples>>.

The https://playground.marlowe-lang.org/[Marlowe Playground] is the
main entry point for learning and developing Marlowe smart contracts. It
is an online simulation that allows users to experiment with, develop,
simulate, and analyze Marlowe contracts in the web browser without
installing any software. Supported programming languages include Marlowe
itself, Haskell, JavaScript, and TypeScript. The playground also
includes Blockly – an editor for visual programming. Together, these
languages form a plug-and-play building and simulation smart contract
environment that is simple to use, visual, and modular. The playground
also allows downloading contracts as a JSON file for further use. For
more details on how to use the playground, see this
https://www.youtube.com/watch?v=EgCqG0hPmwc[video tutorial].

https://docs.marlowe.iohk.io/docs/getting-started/runner[Marlowe
Runner] is an online tool that facilitates the deployment and execution
of Marlowe contracts on the blockchain, eliminating the need for
command-line expertise. With Marlowe Runner, users can deploy contracts
created in the Marlowe playground, test them, and interact with them in
a simulated environment before mainnet deployment. For this, users need
to connect to the Runner using a Cardano wallet such as
https://www.lace.io/[Lace], https://www.namiwallet.io/[Nami] or
https://eternl.io/[Eternl]. Contracts can be uploaded to the Runner as
a JSON file, or one can manually paste the JSON structure into an editor
window. One can look at the source graph before creating a contract,
which is also available when interacting with the contract. If a Marlowe
contract uses role tokens, the funds cannot be retrieved from the
role-token contract with the Runner. In such a case, one can use the
https://docs.marlowe.iohk.io/docs/developer-tools/ts-sdk/payouts-dapp-prototype[Payout
DApp prototype]. A
https://www.youtube.com/watch?v=B5XcH0j7Y7w&list=PLNEK_Ejlx3x2ukxS8Xd0Z-cq24-1jP9G9[video
tutorial] about using Marlowe Runner can be found on the IO Academy
YouTube channel.

https://marlowescan.com/[Marlowe Scan] is a website that allows users
to query information about Marlowe contracts and view the current
contract state. The service is available for the preview and
pre-production test networks and the main network. Users can also view
the contract code, download it, and view a list of transaction IDs.

https://docs.marlowe.iohk.io/docs/developer-tools/runtime/marlowe-runtime[Marlowe
Runtime] is the application backend for managing Marlowe contracts on
Cardano. It provides easy-to-use, higher-level APIs and complete backend
services that enable developers to build and deploy enterprise and Web3
DApp solutions using Marlowe. Users don’t need to assemble the
‘plumbing’ that manually orchestrates a backend workflow for a
Marlowe-based application. Runtime takes commands relevant to the
Marlowe ledger and maps them to the Cardano ledger. It consists of a
series of services that can be divided into frontend and backend
components. Marlowe Runtime backend services are off-chain components
largely responsible for interfacing with a Cardano node. They offer
abstractions to hide many implementation details of Plutus and the
Cardano node directly. There are two ways to interface with Marlowe
Runtime:

* Using Marlowe Runtime web REST API
* Using `marlowe-runtime-cli` command line tool.

The role of Runtime is to facilitate the mapping between the Marlowe
conceptual model and the Cardano ledger model in both directions. Users
can primarily perform two types of tasks: discovering and querying
on-chain Marlowe contracts, as well as creating Marlowe transactions.
More specifically, the tasks include the following:

* Creating contracts
* Building transactions
* Submitting transactions
* Querying contract information and history
* Listing contracts
* Subscribing to live contract updates.

There are two main use cases for using Marlowe as a layer for smart
contract developers. Depending on the complexity of the smart contract
and the DApp, higher-level operations provide a simplified interface,
allowing developers to focus mainly on smart contract logic rather than
implementation details. However, more complex workflows might require
lower-level control, necessitating a deeper understanding of Plutus. For
more information, refer to the list of high- and low-level operations on
the
https://docs.marlowe.iohk.io/docs/developer-tools/overview[developer
tools] documentation page.

https://docs.marlowe.iohk.io/docs/developer-tools/marlowe-cli[Marlowe
CLI] is a command-line tool that provides access to Marlowe
capabilities on testnet and mainnet. It is specifically built to run
Marlowe contracts directly without needing a web browser or a mobile
app. Just as the `cardano-cli` tool enables plain transactions, simple
scripts, and Plutus scripts, the Marlowe CLI tool facilitates the
ability to interact with and develop Marlowe contracts. Users can
measure transaction size, submit transactions, test wallet integration,
and debug validators. The tool provides a concrete representation of
Marlowe contracts that are quite close to what is occurring on-chain.
Users can also create their own workflows that operate with Marlowe or
develop custom tool sets. This allows them to wrap the Marlowe CLI tool
similarly to how developers have wrapped the cardano-cli to create
services such as libraries, faucets, and marketplaces.

The image below offers an overview and description of the Marlowe CLI
and Marlowe Runtime tools for running and querying Marlowe contracts:

image::sc_marlowe_tools.png[width=624,height=350,title="Marlowe tools, source: https://docs.marlowe.iohk.io/docs/developer-tools/overview[Marlowe docs]"]

The https://github.com/input-output-hk/marlowe-starter-kit[Marlowe
starter kit] is a GitHub repository that contains Jupyter notebook
lessons demonstrating the use of the Marlowe CLI and Marlowe Runtime
tools through concrete examples. It can be used with Demeter Run, a
Docker deployment of Marlowe Runtime, and Nix to run the Jupyter
notebooks. The repository provides instructions for setting up various
environments. Additionally, the Jupyter notebooks offer guidance on
interacting with Marlowe smart contracts, covering different approaches
and tools.

The
https://docs.marlowe.iohk.io/docs/developer-tools/ts-sdk/ts-sdk-intro[Marlowe
TypeScript SDK] (TS-SDK) consists of JavaScript and TypeScript
libraries, available as npm packages, designed to support DApp
developers with the necessary tools to build and integrate with the
Marlowe smart contract ecosystem. There are
https://www.youtube.com/watch?v=0Qa1CsZUGnw&list=PLNEK_Ejlx3x1lRhBpL8TUdirMdBPOOvlp[short
video tutorials] on the Input Output YouTube channel that demonstrate
how to use the TS-SDK to build an example DApp. Since the tutorials were
created during the beta stage, function names may change in the official
release. The TS-SDK offers the following features:

* Smart contract toolkit
* Integration with Marlowe Playground
* Wallet connectivity
* Integration with Runtime
* Coordination between wallets and Runtime
* Prototype DApp examples.

You can read more about these features in the official TS-SDK
documentation. To interact with Marlowe contracts, the TS-SDK needs a
Runtime instance. TS-SDK GitHub repository provides the
https://github.com/input-output-hk/marlowe-ts-sdk/?tab=readme-ov-file#cip-30-and-browser[following
table] showing the compatibility between the SDK and the Runtime
versions. The SDK also provides a wrapper around the
https://github.com/spacebudz/lucid[Lucid Library]. This allows using
the SDK in a Node.js environment.

The https://demeter.run/[Demeter.Run] platform, developed and
maintained by the https://txpipe.io/[TxPipe] company, offers a variety
of tools and development environments targeting the Cardano ecosystem.
Their price model depends on the usage of their services, and users also
have the option to get some working time for free. You can read more
about the platform in section <<Setting up a Plinth development environment>>.

The https://docs.marlowe.iohk.io/docs/introduction[Marlowe
documentation] provides extensive explanations, links to learning
resources, and access to tutorials and community resources from the top
bar.

=== Marlowe Runtime architecture

Below is the Marlowe Runtime architecture:

image::sc_marlowe_runtime_architecture.png[width=605,height=364,title="Marlowe runtime architecture, source: https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe-runtime/doc/ReadMe.md#architecture[Marlowe GitHub]"]

The Marlowe Runtime backend consists of a chain-indexing and query
service (marlowe-chain-indexer / marlowe-chain-sync), a
contract-indexing and query service for Marlowe contracts
(marlowe-indexer / marlowe-sync), and a transaction-creation service for
Marlowe contracts (marlowe-tx). These backend services work together,
relying upon
https://github.com/input-output-hk/cardano-node/[cardano-node]
for blockchain connectivity and PostgreSQL for persistent storage.
Access to the backend services is provided via a command-line client
(marlowe-runtime-cli), or a REST/WebSocket server (web-server) that uses
JSON payloads. Web applications can integrate with a
https://cips.cardano.org/cips/cip30/[CIP-30 light wallet] for
transaction signing, whereas enterprise applications can integrate with
https://github.com/cardano-foundation/cardano-wallet[cardano-wallet], 
https://github.com/IntersectMBO/cardano-cli[cardano-cli], 
or https://github.com/vacuumlabs/cardano-hw-cli/tree/develop[cardano-hw-cli]
for the same purpose.

The backend services use typed protocols over TCP sockets, with separate
ports for control, query, and synchronization. Each service handles
rollbacks using intersection points that reference specific slots/blocks
on the blockchain. Most of the data flow is stream-oriented, and the
services prioritize statelessness. The information flow within the
backend maximizes the node as the single source of truth, minimizing the
danger of downstream components receiving inconsistent information. The
Haskell types in the client API for Runtime Clients are independent of
various Cardano packages for ledger, node, and Plutus, resulting in a
Haskell client for Runtime having minimal dependencies in its `.cabal`
file.

Please note that the Marlowe Runtime architecture may evolve. Refer to
the
https://docs.marlowe.iohk.io/docs/platform-and-architecture/architecture[Marlowe
documentation] for the latest version.

=== Contract examples

Marlowe is designed to create the following building blocks of financial
contracts:

* Payments to and deposits from participants
* Choices by participants
* Real-world information.

It is a small language with a handful of different constructs that, for
each contract, describe behavior involving a fixed, finite set of roles
or accounts. When a contract is run, the roles it involves are fulfilled
by participants, which are identities on the blockchain. An on-chain
token represents each role. Roles can be transferred during contract
execution, meaning they can be traded. Users can also use external
accounts represented by their Cardano addresses instead of roles. In
this case, role tokens are not created. In a Marlowe contract, internal
accounts correspond to roles or external accounts, with internal
accounts controlled by the smart contract. Typically, all participants
should make a deposit, sending funds from their wallets to the Marlowe
contract, which retains the funds and associates them with the relevant
internal accounts. Depending on the contract’s terms, funds can be
transferred between these internal accounts and back to external
accounts. No funds are permanently locked in a Marlowe contract; when
the contract concludes, any remaining funds in internal accounts can be
withdrawn by their owners.

Contracts are built by putting together a small number of constructs
that, in combination, describe and model many different kinds of
financial contracts. Some examples include:

* A running contract that can make a payment to a role or a public key
* A contract that can wait for an action by one of the roles, such as a
deposit of currency
* A choice from a set of options.

Crucially, a contract cannot wait indefinitely for an action: if no
action has been initiated by a set time (the timeout), the contract will
continue with an alternative behavior. For example, it may refund any
funds in the contract as a remedial action. Marlowe contracts can branch
based on alternatives and have a finite lifetime, after which any
remaining funds are returned to the participants. This feature means
that funds cannot be locked forever in a contract. Depending on the
contract’s current state, it can choose between two alternative future
courses of action, which are also contracts. When no further actions are
required, the contract closes, and any remaining funds are refunded.
Marlowe is embedded in Haskell and is modeled as a collection of
algebraic data types, with contracts defined by the _Contract_ type:

[source,haskell]
----
data Contract = Close
              | Pay Party Payee Token Value Contract
              | If Observation Contract Contract
              | When [Case] Timeout Contract
              | Let ValueId Value Contract
              | Assert Observation Contract
----

Marlowe has _six_ ways of building contracts. Five of these methods –
`Pay`, `Let`, `If`, `When`, and `Assert` – build a complex contract from simpler
contracts, and the sixth method, `Close`, is a simple contract. At each
step of execution, besides returning a new state and continuation
contract, it is possible that effects – payments – and warnings can also
be generated. A description of each of the methods that the Contract
data type defines can be found in the
https://docs.marlowe.iohk.io/docs/platform-and-architecture/marlowe-language-guide#about-a-marlowe-contract[Marlowe
language guide] hosted on the official documentation page.

The Haskell source code for the data types that Marlowe code uses can be
found in the
https://github.com/input-output-hk/marlowe-cardano[marlowe-cardano]
GitHub repository. If you are writing Marlowe version 1 scripts, the
module you need to import in a Haskell project to be able to write
Marlowe code is `Language.Marlowe.Extended.V1`
(https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe/src/Language/Marlowe/Extended/V1.hs[source
code]). Some important Haskell data types that this module exports are
contained in the `Language.Marlowe.Core.V1.Semantics.Types` module
(https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe/src/Language/Marlowe/Core/V1/Semantics/Types.hs[source
code]). You can look up these modules if you view the documentation for
Marlowe dependencies. The
https://github.com/input-output-hk/marlowe-dependency-docs[marlowe-dependency-docs]
GitHub repository contains instructions for setting up your own
documentation server.

Let’s now look at an example of a Marlowe contract involving three
parties – Alice, Bob, and Charlie. In this contract, Alice and Bob
deposit 10 lovelaces. Then, Charlie decides whether Alice or Bob
receives the total amount. If any of the three parties fails to
participate, the contract ensures that all deposited funds are
reimbursed. You can see a demonstration of this contract’s design using
Blockly in the Marlowe Playground in the following
https://youtu.be/fldaBHmYfqk[Plutus Pioneer program] video.

Below, you can see the contract code in the Marlowe language:

[source,shell]
----
When
    [Case
        (Deposit
            (Role "Alice")
            (Role "Alice")
            (Token "" "")
            (Constant 10)
        )
        (When
            [Case
                (Deposit
                    (Role "Bob")
                    (Role "Bob")
                    (Token "" "")
                    (Constant 10)
                )
                (When
                    [Case
                        (Choice
                            (ChoiceId
                                "Winner"
                                (Role "Charlie")
                            )
                            [Bound 1 2]
                        )
                        (If
                            (ValueEQ
                                (ChoiceValue
                                    (ChoiceId
                                        "Winner"
                                        (Role "Charlie")
                                    ))
                                (Constant 1)
                            )
                            (Pay
                                (Role "Bob")
                                (Account (Role "Alice"))
                                (Token "" "")
                                (Constant 10)
                                Close 
                            )
                            (Pay
                                (Role "Alice")
                                (Account (Role "Bob"))
                                (Token "" "")
                                (Constant 10)
                                Close 
                            )
                        )]
                    1682551111000 Close 
                )]
            1682552111000 Close 
        )]
    1682553111000 Close
----

Next is a flowchart generated with the Marlowe Runner that indicates
possible actions and outcomes of the above contract. The highlighted
block is the start of the contract, and the greyed-out blocks show
possible execution paths:

image::sc_marlowe_contract_tree.png[width=624,height=134,title="Marlowe contract tree"]

Below, you can see the image of the contract implemented in the Blockly
tool:

image::sc_marlowe_contract_choice.png[width=493,height=807,title="Marlowe choice contract"]

The *When* constructor, in the beginning, waits for an external action
that we specify in square brackets. If this external action does not
happen, we will close the contract. We do this by specifying a timeout
in POSIX time (measured as milliseconds after UNIX epoch –
00:00:00 https://en.wikipedia.org/wiki/Coordinated_Universal_Time[UTC] on
January, 1, 1970) after the closing square bracket of the *When*
constructor and add the *Close* constructor at the end. If the
external action does not happen before this timeout, the contract
terminates. Our external action will be a deposit by Alice, and we say
that the deposit should happen until a certain time. We use the *Case*
constructor for that, which contains two pairs of regular brackets.
The first one defines the case of what has to happen for the contract to
progress, and the second one defines the logic that follows if the case
action is met. In the first bracket, we specify that Alice should
deposit 10 ada. We do this by using the *Deposit* constructor. First,
we specify to which account the deposit should go. We can specify this
with the *Role* constructor followed by the role name, which, in our
case, is Alice. Second, we specify who is depositing into the previously
mentioned account. We can again use the *Role* constructor and Alice's
name. We could also use the *Address* constructor, where we would have
to input Alice’s Cardano address. Then, we have to specify what kind of
currency we are depositing. For this, we use the *Token* constructor
and add the currency symbol and the token name. For the ada currency, we
can use two empty strings. At the end, we specify the amount of the
currency we want to deposit. For this, we can use the *Constant*
constructor followed by a number.

After defining the first part of the case-statement, the next step is to
outline the logic for when the condition is met. This begins with a new
when-statement, in which Bob will deposit 10 ada, and a new timeout is
set. The code for Bob’s deposit mirrors Alice’s, but the role name
changes from Alice to Bob. After that, we again define the logic that
follows if Bob makes his deposit. We use a when-statement that says
Charlie has to make a choice. We set a timeout for the statement in case
Charlie does not make his choice and then the contract gets terminated.
We use a case-statement for Charlie to make a choice, and in the code,
we apply the *Choice* constructor for that decision. This constructor
takes two arguments. First, it takes the information about the choice
name and the person making the choice. The *ChoiceId* constructor
defines this, specifying the person with the role statement. The second
argument is a list of integers that defines Charlie’s possible choices.
Since Charlie decides whether the funds go to Alice or Bob, the list
contains only two numbers.

The logic that follows after that is a conditional statement, which uses
the *If* constructor. First, it takes the condition statement and then
the two possible cases depending on the condition. For the condition
statement, we use the *ValueEQ* constructor. It takes the value that
Charlie chose and compares it to a number. We retrieve the value from
Charlie's choice by using the *ChoiceValue* constructor and input the
*ChoiceId* statement that we previously used. The value to which we
compare it is 1, for which we again use the *Constant* constructor.
The first case that follows the conditional statement is when the choice
equals 1, which means that the funds from Bob will go to Alice. To
transfer the funds from Bob’s internal account to Alice’s internal
account, we use the *Pay* constructor. We first specify the party that
sends the money, for which we can use the role-statement. After that, we
have to specify the account with the *Account* constructor, which can
again take a role-statement. Because we chose the *Account*
constructor, the transfer occurs between internal accounts. There is
also a *Party* constructor that can be used in this field, which takes
an *Address* constructor and sends the money to an external address.
Next, we need to specify the currency and the amount we want to send. At
the end, we write the *Close* constructor, which means that the funds
from the internal accounts will be sent back to the external account of
those parties. The second pay-statement is the same, but the roles of
Alice and Bob are reversed, as Charlie will send the funds to Bob if he
makes choice 2.

Let us look at another, more complex example that uses the same Marlowe
constructors. The contract will be an escrow that regulates a funds
transfer between a buyer and a seller. If there is a disagreement
between them, a mediator will decide whether the funds are refunded or
paid to the seller. Below, you can see the Marlowe contract code:

[source,shell]
----
When [
  (Case
 	(Deposit (Role "Seller") (Role "Buyer")
    	(Token "" "")
    	(ConstantParam "Price"))
 	(When [
       	(Case
          	(Choice
             	(ChoiceId "Everything is alright" (Role "Buyer")) [
             	(Bound 0 0)]) Close)
       	,
       	(Case
          	(Choice
             	(ChoiceId "Report problem" (Role "Buyer")) [
             	(Bound 1 1)])
          	(Pay (Role "Seller")
             	(Account (Role "Buyer"))
             	(Token "" "")
             	(ConstantParam "Price")
             	(When [
                   	(Case
                      	(Choice
                         	(ChoiceId "Confirm problem" (Role "Seller")) [
                         	(Bound 1 1)]) Close)
                   	,
                   	(Case
                      	(Choice
                         	(ChoiceId "Dispute problem" (Role "Seller")) [
                         	(Bound 0 0)])
                      	(When [
                            	(Case
                               	(Choice
                                  	(ChoiceId "Dismiss claim" (Role "Mediator")) [
                                  	(Bound 0 0)])
                               	(Pay (Role "Buyer")
                                  	(Party (Role "Seller"))
                                  	(Token "" "")
                                  	(ConstantParam "Price") Close))
                            	,
                            	(Case
                               	(Choice
                                  	(ChoiceId "Confirm problem" (Role "Mediator"))           
                                        [(Bound 1 1)]) Close)]
                       		 (TimeParam "Mediation deadline")
                       		 Close)
                   		 )]
               		 (TimeParam "Complaint response deadline")
               		 Close))
       		 )]
   		 (TimeParam "Complaint deadline")
   		 Close)
   	 )]
    (TimeParam "Payment deadline")
    Close
----

The next image shows the contract implemented using the Blockly tool:

image::sc_marlowe_contract_escrow.png[width=400,height=1130,title="Marlowe escrow contract"]

First, the buyer must deposit the funds into the seller’s internal
account, with the amount defined by the _Price_ parameter. The next
when-statement presents two options. In the first case, the buyer
confirms everything is fine, and the contract closes. This is handled
using a choice-statement, where the buyer has only one option. In the
second case, the buyer reports a problem, and the funds are returned to
the buyer’s internal account. Two further possibilities arise: if the
seller agrees with the problem, the contract closes, and the buyer’s
funds are transferred back to their external account. If the seller
disputes the issue, and no action is taken by the timeout, the contract
closes, and the buyer is refunded. If disputed, another when-statement
allows the mediator to either dismiss the claim, transferring the funds
to the seller’s internal account before closing the contract, or confirm
the issue, in which case the buyer is refunded, and the contract closes.
If the mediator does not act by their deadline, the contract closes, and
the buyer is refunded. All deadlines are set as time parameters before
the contract is submitted on-chain.

Another feature Marlowe contracts enable is peer-to-peer trustless
lending. A borrower can obtain loans directly from individual lenders,
bypassing traditional financial institutions. An example of a
zero-coupon bond contract, which functions as a peer-to-peer lending
agreement, can be found on the
https://github.com/input-output-hk/marlowe-starter-kit[Marlowe starter
kit] GitHub page. In this case, the loan is not collateralized, meaning
the lender risks losing the funds if the borrower fails to repay, as the
smart contract can not enforce repayment. There are a couple of options
to mitigate this risk:

* Back the smart contract with a traditional legal contract
* In some B2B environments, bilateral or multilateral umbrella legal
agreements cover instruments like this
* Combine with a reputation system, as is commonly done in micro-lending
* Add a guarantor to the contract
* Link the contract to a margin account
* Bundle the contract with other instruments to create a structured
product that mitigates the default risk.

Regardless of the Marlowe contract a user interacts with, if role tokens
are involved, they can be traded, effectively transferring the token
ownership to another person. A Marlowe contract can facilitate these
token trades, and ownership of role tokens can also be traded for
certain time periods. More contract examples can be found in the Marlowe
Playground or the
https://github.com/input-output-hk/real-world-marlowe[Real world
Marlowe] GitHub repository, which also showcases the off-chain code for
interacting with contracts. Additionally, a
https://github.com/input-output-hk/marlowe-cardano/tree/main/marlowe-actus[Marlowe
ACTUS implementation] is available for the ACTUS financial standard.

Marlowe DApps can be discovered by searching the keyword ‘Marlowe’ in
various https://projectcatalyst.io/search?q=marlowe[Project Catalyst] proposals.
The Marlowe team at IO has also developed the following Marlowe DApps:

* https://github.com/input-output-hk/marlowe-payouts[Marlowe Payouts]
– helps users discover available payouts from Marlowe contracts on the
Cardano blockchain, simplifying the tracking and withdrawal process
* https://github.com/input-output-hk/marlowe-token-plans[Token Plan
Prototype] – allows token providers to create token plans, where they
deposit ada, and release funds over time to a claimer, based on a
time-based scheme
* https://github.com/input-output-hk/marlowe-order-book-swap[Order Book
Swap Prototype] – a decentralized platform for users to list tokens for
swap, specifying the desired return. Interested parties can accept
offers, resulting in a token swap.

=== Integrating with Plinth

Marlowe contracts can be integrated with Plinth smart contracts or other
compiled languages, such as Aiken, for example. This section focuses on
integration with Plinth. One example is the open roles Plinth smart
contract, which enables interaction with a Marlowe contract where
participants’ Cardano addresses are unknown at deployment. When using
open roles, the Marlowe contract sends role tokens to the
https://github.com/input-output-hk/marlowe-plutus/blob/581e95bb9c93a16dc5c9a3181e90abed4639f728/marlowe-plutus/src/Language/Marlowe/Plutus/OpenRoles.hs[open
roles] Plinth validator script that holds them until an address is
specified later. This enables the contract to be verified on-chain
before users interact with it. When the user initiates an action, like a
deposit or choice, the smart contract assigns them the appropriate role
and distributes the role token from the validator script. The developer
simply needs to specify the *OpenRoles* type when setting contract
participants, while Marlowe Runtime manages the rest. The
https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe-runtime/doc/open-roles.md[Open
roles in Marlowe] GitHub documentation page explains this process in
more detail.

Marlowe and Plinth validators can interact as follows:

* PlutusTx validators can run in the same transaction as Marlowe
transactions
* The transaction script context contains sufficient information for a
Plinth validator to inspect the Marlowe transaction’s redeemer,
incoming, and outgoing datum
* The Marlowe validator will allow the Plinth transaction to run, as
long as the Marlowe validator is not making a payment
* The presence of a datum in the UTXO holding the role token by the
Plinth script does not interfere with Marlowe validation
* The Marlowe validators do not need to be modified to run alongside a
Plinth script that holds the role token.

=== Future of Marlowe

The Marlowe foundation will continue supporting Marlowe by consolidating
and extending it for Cardano DApp builders. This includes providing
oracles and micropayments, optimizing execution, and supporting runtime
monetization. Marlowe offers a lower barrier to entry for DApp
development. The new Marlowe DApp starter kit (DSK), which will be
maintained by the Marlowe foundation, will highlight these advancements
and streamline onboarding for small and medium-sized businesses,
developers, infrastructure providers, and stake pool operators.

Once the intellectual property rights for Marlowe are moved from IO to
the Marlowe foundation, the Marlowe repositories will be moved to an
independent GitHub organization, and community activities will be
coordinated through the Marlowe special interest group, supported by a
new, members-based, non-profit organization. The Marlowe foundation
created the https://cardano.ideascale.com/c/idea/122392/[Marlowe 2025]
Catalyst application and plans to seek additional funding from Catalyst
and other sources.

image::sc_marlowe_2025_plan.png[width=457,height=328,title="Marlowe 2025 plan"]

The Marlowe 2025 application targets DApp developers and aims to further
Marlowe’s development to help businesses leverage emerging market
opportunities, making advanced features more accessible and relevant to
a broader audience. Marlowe can be particularly attractive to businesses
looking to use Cardano because it reduces the risks and costs of initial
blockchain onboarding. The application aims to unlock Marlowe’s
potential by implementing critical updates to its validator and tech
stack, transforming the Marlowe Runtime, protocols, and contracts into
competitive products. These updates will create new business
opportunities by making Marlowe tools essential for small and medium
businesses, developers, infrastructure providers, and SPOs. The Marlowe
2025 application targets the following areas:

*Marlowe DApp starter kit*

The Marlowe DApp starter kit (DSK) will consolidate the documentation,
examples, and tutorials into an end-to-end guide for designing,
implementing, deploying, and maintaining DApps that leverage Marlowe
tools and capabilities. The DSK will include comprehensive support
materials, such as tutorials, readily available software packages, and
pre-built binaries to ensure ease of implementation. The initial DSK
will be delivered early in the project, with incremental enhancements
added as new technologies are developed.

*Validator enhancements*

Targeted changes will be implemented to the current validator to
significantly reduce on-chain execution costs for specific contracts and
Marlowe idioms. By addressing inefficiencies in the existing execution
flow, the changes aim to optimize a set of key contracts with business
value potential. This process will not only improve efficiency but also
expand capabilities, including the integration of off-chain micropayment
channels into the framework. These changes will also be incorporated
across the whole Marlowe tool-set. The selected contracts, chosen for
their real-world application potential, will be demonstrated through
DApp prototypes, fully documented and accessible via the marlowe-ts-sdk
for developers to build upon.

*Configurable runtime fee mechanism*

To encourage infrastructure providers and SPOs to adopt Marlowe, a
configurable fee mechanism will be introduced within the Marlowe
Runtime. This backend enhancement will support the safe execution of
Marlowe contracts via web applications, supported by a new transaction
validation layer in the TypeScript client library. This layer will
ensure secure interactions, even with untrusted backends, facilitating a
wider distribution and adoption of Marlowe technology.

*Marlowe oracle protocol*

The Marlowe oracle protocol will be formalized and expanded with a
detailed CIP specification, building on the oracle scanner MVP. This
protocol employs a unique on-chain request-response mechanism, offering
distinct advantages over traditional feed-based systems by enabling
extensive data set coverage. We will collaborate with existing oracle
providers on the Cardano network to ensure seamless integration. The
protocol will also be made interoperable with other languages such as
Aiken or Plinth, allowing scripts to efficiently manage oracle data.
This enhancement will not only ensure compatibility with current
technologies but also open up numerous new applications on Cardano.

*Outreach*

The Marlowe 2025 project aims to enhance community engagement through a
series of live online presentations, leveraging the previous experience
from participating in local and international Cardano summits, meetups,
and workshops. These efforts aim not only to educate, but also to foster
community collaboration to further drive the technology evolution and
refinement.

The Marlowe 2025 proposal marks the first step in launching Marlowe as
an independent project. The Marlowe foundation will make further bids to
Catalyst and other funding bodies, engaging with the community through
the special Interest group and potentially collaborating with other
partners. A key focus will be the development of Marlowe V2 – a separate
conceptual track aimed at fundamental language modifications. This track
will be organized through the creation of Marlowe improvement proposals
(MIPs), in collaboration with the wider community.

=== Impact of Marlowe

Marlowe has the potential to evolve into a smart contract technology
complementary to Plinth and Aiken.

Marlowe significantly reduces the barriers to entry for new businesses
and developers interested in exploring blockchain solutions by
simplifying the onboarding process. The technology not only mitigates
the complexities of the UTXO model through a user-friendly yet robust
programming language, but also drastically lowers costs, reduces risks,
and shortens prototyping time for traditional Web2 businesses looking to
integrate blockchain functionality. The introduction of marlowe-ts-sdk
and the Marlowe Runtime, which integrates with familiar REST APIs, make
it straightforward to build end-to-end DApps incorporating Marlowe on-
and off-chain together with traditional web frameworks.

The Marlowe 2025 proposal is designed to sustain and enhance this
project. To accelerate adoption, Marlowe will be enriched with efficient
real-world functionality and innovative features such as off-chain
micropayment channels. The technology's success relies on a thriving
ecosystem around it; therefore, Marlowe improvements in oracle data
availability and infrastructure robustness are critical. By simplifying
the initial onboarding process to a single npm install command, a surge
in Marlowe's usage is anticipated. In doing this, it will benefit a
range of different stakeholders in different ways.

*Stakeholder beneficiaries*

Marlowe is essential for the Cardano infrastructure. The addition of
oracles and micro-payments in the Marlowe product will benefit
infrastructure providers by simplifying or expanding their services.
Cardano DApp developers will similarly gain the ability to incorporate
Marlowe features into their development solutions.

The Marlowe DSK is designed for small and medium-sized enterprises and
developers, enabling quick and effective onboarding. By focusing on
developers and lowering barriers throughout the development cycle – from
design to deployment – the DSK will streamline access to Marlowe. The
inclusion of features like micropayments and oracles will also attract
potential users in the decentralized finance (DeFi) space. The
simplifications and end-to-end support provided by the DSK will help
users quickly learn about Marlowe’s applications and facilitate smoother
onboarding.

The proposal is designed to foster a positive feedback loop within the
Cardano ecosystem, enhancing the symbiotic relationship between Marlowe
technology and its infrastructure. The planned enhancements will not
only benefit developers and businesses, but will also create incentives
for infrastructure providers (possibly SPOs) and oracle services to
engage more deeply with Cardano. This collaborative growth, supported by
the Marlowe special interest group and existing forums, will help forge
a vibrant and sustainable ecosystem, positioning Marlowe as a
cornerstone of the Cardano economy.

== Plutus smart contracts

=== Overview and learning resources

Before reading section _Plutus smart contracts_, one should have a basic understanding of
blockchain principles and Cardano’s extended UTXO (EUTXO) accounting
model. You can learn this in the first four chapters of this book. If
you are already familiar with blockchain technology, refer to the
Cardano-specific content in those chapters. The EUTXO model is presented
in section <<The EUTXO model>>. One should also be familiar with
the types of smart contract languages offered by Cardano, covered in
section <<Smart contract programming languages>>, which lists each type and provides resources for DApp
development tools. Additionally, understanding Cardano addresses and
their binary format, as explained in section <<Cardano addresses>>, is important.

Section _Plutus smart contracts_ presents the rules for the Plutus language by showcasing how
to write, interact with, and test Plinth smart contracts (formerly
called PlutusTx) that is a compiled language. Because Plutus rules apply
to other compiled languages like Aiken, Plu-Ts or OpShin, learning the
basics of Plinth helps developers read and write code in other Cardano
smart contract languages that compile to Plutus.

Plinth is embedded in the Haskell programming language. For mere details
on Haskell, refer to section <<Features and benefits of Haskell>>. IO
offers a free self-paced beginner-friendly
https://github.com/input-output-hk/haskell-course/[Haskell course]
hosted on GitHub that teaches the necessary skills for programmers to
read and write Plinth scripts. The official
https://www.haskell.org/documentation/[Haskell documentation] site
provides more learning resources. Plinth code examples presented in this
section are based on PlutusV2. PlutusV3 became available after the Chang
hard fork. From the
https://docs.cardano.org/about-cardano/evolution/upgrades/chang/[Cardano
docs] page, we get a short description of what PlutusV3 brings to
Cardano:

With the introduction of PlutusV3, Plutus scripts are available for use
as part of the governance system, enabling sophisticated voting
possibilities like supporting DAOs, for example. Chang also brings
advanced Plutus cryptographic primitives, other new primitives, and
performance enhancements to the platform. These additions provide
developers with a richer smart contract creation toolkit, enhancing both
developer and user experiences, and unlocking new possibilities for
decentralized applications (DApps) on Cardano.

Section <<PlutusV3 features>> dives deeper into PlutusV3
advantages and presents some basic code examples to highlight the
differences to PlutusV2. Cardano’s hard fork combinator technology,
presented in section <<Cardano node layers>>, subsection
*Consensus and storage layer*, allows the Cardano node to process
PlutusV2 scripts after the Chang hard fork made PlutusV3 scripts
available.

Section _Plutus smart contracts_ covers the following topics:

* Plutus in comparison to Bitcoin Script and Solidity
* Plinth in comparison to Aiken
* Setting up a Plinth development environment
* Simple validation scripts
* Script context explained
* Time-dependent and parameterized validators
* Off-chain code with Lucid
* Minting policies
* Testing Plinth scripts
* Staking and Plinth
* PlutusV3 features.

Plinth code examples are taken from the
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[4th
iteration of the Plutus Pioneer program]. This iteration also contains
a simple, stablecoin DApp that is covered in week 9 lectures. Some
lectures contain weekly homework assignments, the solutions to which can
be found on the
https://github.com/input-output-hk/plutus-pioneer-program/tree/solutions-fourth-iteration[solutions-fourth-iteration]
branch. The IO education team also translated the Plinth code examples
from the 4th program into Aiken code. Those code examples are published
on the
https://github.com/input-output-hk/plutus-pioneer-program/tree/aiken-fourth-iteration[aiken-fourth-iteration]
branch. Further learning resources and smart contract examples in
Plinth, Aiken and other smart contract languages can be found at:

* https://www.gomaestro.org/smart-contracts[Cardano’s
smart contract marketplace] – hosted by Maestro. This DApp platform
provides powerful APIs and developer tools to build and scale DApps with
ease.
* Gimbalabs https://plutuspbl.io/[Plutus project-based learning] –
provides _Course Repositories_ that redirect to Plutus example projects.
More resources are available on their
https://www.youtube.com/@gimbalabs/playlists[YouTube channel].
* Project pages listed in the education sections of
https://www.cardanocube.com/cardano-ecosystem-interactive-map[Cardano’s
interactive map]. One can explore projects in other groups and view
their GitHub repositories.

Aiken specific learning resources are presented at the end of section
8.5.3 _Plinth in comparison to Aiken_. Commercial training for
developers interested in building on Cardano is offered by
https://education.emurgo.io/about-us/[Emurgo Academy]. At the time of writing,
the offered courses include:

* Cardano solutions architect
* Cardano developer professional
* Haskell developer professional
* Foundations of blockchain with Cardano overview
* Blockchain business consultant.

The Emurgo https://education.emurgo.io/cardano-courses/[Cardano
courses] page provides an up-to-date list, and the Cardano foundation
also offers a free https://academy.cardanofoundation.org/[online
course] on the basics of blockchain and Cardano.

=== Plutus in comparison to Bitcoin Script and Solidity

This section compares the basic characteristics of smart contracts in
Bitcoin, Ethereum, and Cardano, highlighting the new concepts each
introduced in the cryptocurrency space.

A Bitcoin Script is a simple stack-based smart contract language, whose
most complex control structure is a conditional. It is written in a
Forth-like non Turing-complete language and is essentially linear, which
means it can branch, but the language does not offer looping constructs
or recursion. All Bitcoin scripts terminate, and it is possible to give
an accurate estimate of the time taken to execute a script. Bitcoin
scripts have the following developer limitations (taken from _Functional
Blockchain Contracts_, _Chakravarty et al. 2019_):

[arabic]
. The Bitcoin Script language constraints programs to be of a limited
size and provides barely any control structures (essentially only
conditional statements). The primitive operations that can be used in
Bitcoin Script are also very limited (for example, the division
operation was originally included but was subsequently disabled).
. The computational context available to a Bitcoin Script program is
very constrained. For example, it cannot inspect a transaction that is
currently being validated, but can access the hash of the transaction.
. There is no ‘official’ high-level language compiling to Bitcoin
Script, although several proposals have been put forward by a variety of
groups __(__eg, _Massimo Bartoletti and Roberto Zunino. 2018. BitML: A
Calculus for Bitcoin Smart Contract)_.

Ethereum provides a Turing-complete language for the Ethereum virtual
machine (EVM), which is the runtime environment for transaction
execution in Ethereum. It also provides Solidity, a custom higher-level
programming language that compiles into EVM code. Solidity is an
object-oriented, statically typed programming language designed for
developing smart contracts. It supports inheritance, libraries, and
complex user-defined types. Gas fees must be paid for every smart
contract transaction on Ethereum. A Solidity smart contract is able to
see and access information from the entire global state of the
blockchain. That is the opposite extreme of Bitcoin, where the script
has very little context. This enables Ethereum smart contracts to be
more powerful, but it can also make it difficult to predict their
behavior, leading to potential security issues. During the interval
between a user constructing a transaction and its incorporation into the
blockchain, concurrent events may also occur. Ethereum employs an
account-based model, where each user has an account with a balance. When
funds are transferred between accounts, the balances are updated
accordingly. In Ethereum, it is possible that a user has to pay gas fees
for a transaction that interacts with a smart contract, although it can
eventually fail with an error.

Cardano uses the EUTXO model and Plutus Core as its native smart
contract language. Developers can write smart contracts in Plinth or in
other high level languages that compile to Plutus Core (see section
<<Smart contract programming languages>>). Section <<Plutus security>> 
covers the security aspect of both languages in more detail. A Plutus 
smart contract provides a more flexible view than a Bitcoin Script but 
does not have a global view as a Solidity smart contract. Plutus scripts 
cannot see the whole state of the blockchain but can see the whole 
transaction that is being validated.

This means the Plutus contract can see the transaction context that
carries transaction inputs and outputs. Every UTXO has an arbitrary
piece of data attached to it – the datum, which defines a state of the
UTXO. When a transaction intends to spend a UTXO sitting at a smart
contract, the smart contract code can access the information contained
in the datum. Finally, the smart contract also sees a piece of arbitrary
input data provided by the user submitting the transaction. This data is
the redeemer. A Plutus smart contract can use all these three pieces of
information to decide whether it is ok to consume an UTXO or not. It is
also possible to use the wallet to check whether a transaction will be
validated before on-chain execution. If the transaction is valid, it
will be processed on the network, provided that all UTXO inputs are
present and the processing time falls within the transaction’s validity
interval. In case these conditions are not met, the transaction will
fail without charging any fees to the user, unlike in Ethereum, where
users must pay gas fees for transactions that can ultimately fail. If
the inputs are present when the transaction is submitted, it will be
validated and produce the expected outcome as predicted off-chain. Both
Ethereum’s accounting model and Cardano’s EUTXO model are equally
powerful in expressing smart contract logic.

Further comparison between Cardano and Ethereum regarding security is
outlined in section <<Cardano security>>. You can find research
articles about the technical implementation of Plutus in the
https://iohk.io/en/research/library/[IO library]. A good entry point
is the research paper
https://iohk.io/en/research/library/papers/functional-blockchain-contracts/[Functional
Blockchain Contracts], 2019 by Chakravarty et al. The official
https://docs.cardano.org/developer-resources/smart-contracts/plutus/[Plutus
documentation] provides short explainers and various learning
resources. The official https://github.com/IntersectMBO/plutus[Plutus]
GitHub repository also provides links to specifications and design
documents, academic papers and talks.

=== Plinth in comparison to Aiken

Plinth enables developers to write and compile their on-chain code to
Plutus for use in DApps, which Cardano nodes execute during user
interactions. Plinth provides a compiler plugin for GHC (the Glasgow
Haskell Compiler) that compiles to Plutus. More details about the
Plinth-to-Plutus compilation pipeline are outlined in section <<Plutus security>>.

Plinth lets developers build secure applications, forge new assets, and
create smart contracts in a predictable, deterministic environment with
the highest level of assurance. Furthermore, developers don’t have to
run a full Cardano node to test their work. Section <<Testing Plinth scripts>> 
presents how to test a compiled Plinth script without having to run a node. The
https://github.com/IntersectMBO/plutus[Plutus] repository includes the
Plinth compiler (previously called PlutusTx), enabling developers to
write Haskell code that can be compiled to Plutus. The repository also
includes the combined
https://intersectmbo.github.io/plutus/haddock/latest[documentation],
generated using Haddock, for all public Plutus code libraries. The
official https://plutus.cardano.intersectmbo.org/docs/[Plutus user
guide] provides developer-related information on Plutus and Plinth.

https://aiken-lang.org/[Aiken] is another popular Cardano smart
contract language that complines to Plutus Core. Written in Rust, it
compiles directly to UPLC, which Cardano nodes execute. This process is
illustrated on the diagram below:

image::sc_aiken_compilation.png[width=590,height=390,title="Aiken code transformation, source: https://cardanofoundation.org/blog/aiken-the-future-of-smart-contracts[CF blog]"]

Aiken was developed by the https://txpipe.io/[TxPipe] company with
help of the https://cardanofoundation.org/[Cardano Foundation], taking
inspiration from many modern languages such as Gleam, Rust, and Elm,
which are known for friendly error messages and an overall excellent
developer experience. It is a purely functional language with strong
static typing and inference and offers a more accessible and familiar
syntax to developers, that makes it easy to learn and reduces the
learning curve associated with Haskell-based Plinth. Aiken enables
cost-efficient smart contract development and comes with a modern
development environment that has a package manager, helpful error
diagnostics, a language-server protocol (LSP) with auto-formatting, and
popular editor integration (VSCode, NeoVim, Emacs). The language is well
documented and offers a built-in testing framework that ensures proper
and robust smart contract execution with property-based testing. Aiken’s
testing framework uses the same underlying virtual machine as in real
smart contract execution, ensuring that memory consumption and contract
behavior during testing are identical to those on the main network.

Plinth has a more expressive type system than Aiken. However, it cannot
utilize the full range of Haskell’s type system features, such as type
classes and
https://blog.ocharles.org.uk/guest-posts/2014-12-18-rank-n-types.html[rank-N
polymorphism]. This comes at a cost because Plinth compiles and encodes
data types using a
https://en.wikipedia.org/wiki/Mogensen–Scott_encoding[Scott-Encoding]
approach
(https://well-typed.com/blog/2022/08/plutus-cores/#in-haskell.-scott-encoding[Haskell
example]), which creates an upfront cost that causes the difference in
execution costs between Haskell and other frameworks like Aiken. Aiken
compiles all its custom data types into the builtin Plutus type _Data_.
We will look at it in section <<Simple validation scripts>>. Both
languages are purely functional, which makes it easier for an auditor to
assess the behavior of such smart contracts. Plinth also works well with
proof-assistant tools such as
https://wiki.portal.chalmers.se/agda/pmwiki.php[Agda], making it a
good choice for projects that require a high level of security. Since
Agda isn’t Haskell specific, it could also be used with Aiken. However,
the gap to bridge between Aiken and Agda is larger than that between
Plinth and Agda. Because both languages compile to Plutus, the logic of
writing smart contracts is the same, but the workflow and syntax are
different. Learning one language will help a developer understand any
other Cardano smart contract language that compiles to Plutus.

To learn the Aiken smart contract language, one can check out the
https://aiken-lang.org/language-tour/primitive-types[Language tour] on
the official documentation, which also provides a walkthrough of
creating a https://aiken-lang.org/example--hello-world/basics[Hello World
project], covering the following topics:

* pre-requisites
* scaffolding
* using the standard library
* the first validator
* adding traces
* writing a test
* Lucid and PyCardano off-chain code.

The https://github.com/aiken-lang/awesome-aiken[Awesome Aiken] repository
provides many links to Aiken libraries, DApps, tutorials and video
lessons. One can also see https://piefayth.github.io/blog/pages/aiken1/[Aiken for amateurs]
tutorial that is at the time of writing not included in the Awesome
Aiken repository.

=== Setting up a Plinth development environment

For your development environment, you can use one of the following
options:

* Run a local Docker container inside VSCode
* Use an online platform such as https://demeter.run/[Demeter.run]
* Run a Nix shell that contains all the dependencies
* Install system dependencies manually.

The __plinth-dev-env __GitHub repository provides instructions for
setting up the development environment for the first three options. And
up-to-date link to this repository is available in the _resources_
folder of the
https://github.com/input-output-hk/mastering-cardano[mastering-cardano]
GitHub repository. It aims to provide up-to-date instructions for the
latest stable Plinth development environment. The smart contract code
presented throughout chapter <<Writing smart contracts>> uses features 
introduced in the Vasil hard fork, which enabled Plutus V2. The development 
environment you might use to run and test the code presented in section 
<<Plutus smart contracts>> needs to support the Vasil features and Plutus V2
scripts.

The https://demeter.run/[Demeter.Run] online platform offers various
tools and development environments for the Cardano ecosystem. One can
set up development environments for smart contract languages such as
Plinth and Aiken, and also programming languages like Rust or Python
that come with useful Cardano tools and libraries written in those
languages. The platform offers backend hosting for DApps and allows
integration testing within its environments. It manages monitoring,
security, and version upgrades. Depending on development needs, the
platform provides various starter kits, including example code
repositories from the community for learning or project initiation. Its
pricing model is based on service usage, with users also able to access
some free working time. Other platforms, such as
https://www.gomaestro.org/[GoMaestro], offer additional development
opportunities for Cardano. Explore _Developer Tools_ and
_Infrastructure_ sections on the
https://www.cardanocube.com/cardano-ecosystem-interactive-map[Cardano
developer map] for more options.

To query various Plutus types, one can use the official
https://plutus.cardano.intersectmbo.org/haddock/latest/[Plutus haddock
documentation], which presents types in Haskell syntax. Press CTRL + S
to search for a keyword, such as a specific data type or function name.
After locating the desired item, click the _Source_ icon next to its
name to open the corresponding Haskell source code. The software
packages for the libraries hosted on the Plutus haddock documentation
are contained in the
https://github.com/IntersectMBO/cardano-haskell-packages[Haskell
packages for Cardano] repository. It contains all Haskell packages used
by Cardano that are not hosted on
https://hackage.haskell.org/[Hackage] – the central archive for
Haskell packages. Other compiled languages provide their own libraries
that implement Plutus types. One example is the official
https://aiken-lang.github.io/stdlib/[standard library] for the Aiken
language.

Plinth data types cannot be explored in standard GHCi REPL because the
GHC compiler pipeline first compiles Plinth code to an intermediate
language called Haskell Core. The Plutus compiler then takes this
Haskell Core and compiles it to the Plutus script language. This means
that GHC is unaware of Plinth data types. Additionally, the Plinth
libraries are not hosted on Hackage, which means the only way to query
Plinth types from a REPL is to build it with a Cabal file that imports
those libraries. There are some intermediate steps in the compilation
pipeline which will be in detail explained in section <<Plutus security>>.

=== Simple validation scripts

A validation script or validator is the smart contract program that
checks whether funds at a script address are allowed to be spent by a
given transaction. The script uses three parameters: the datum, the
redeemer, and the transaction context:

* The datum is an arbitrary piece of data associated with a UTXO
alongside the amount of ada and native tokens.
* The redeemer is an arbitrary piece of data provided when creating a
transaction, used to unlock funds at a UTXO, similar to a private key in
the conventional UTXO model.
* The transaction context provides information about the submitted
transaction, including its inputs and outputs.

In contrast to Ethereum, the script cannot see the entire state of the
blockchain; instead, it can view the entire transaction being validated.

Depending on the types of these three parameters, there are two possible
implementations of Plinth validation scripts.

* In the low-level implementation, these parameters are represented
using the same data type.
* In the high-level implementation, one can use custom Haskell data
types for the datum and redeemer, while the transaction context uses a
predefined type.

Both implementations can be used in the smart contract code. The main
difference lies in code performance, with the low-level implementation
offering better performance. Low-level validation scripts are referred
to as untyped validation scripts, while high-level scripts are known as
typed validation scripts.

This book focuses on the data types defined for Plutus V2 scripts. The
data type for the low-level validation script implementation is called
[purple]#BuiltinData#. It contains two conversion functions, [blue]#builtinDataToData#
and [blue]#dataToBuiltinData#, which can convert back and forth to the
[purple]#Data# type. The [purple]#Data# type has its constructor exposed, as
illustrated in the image below:

[source,haskell]
----
data Data  
    = Constr Integer [Data]
    | Map [(Data, Data)]
    | List [Data]
    | I Integer
    | B BS.ByteString
    deriving stock (Show, Read, Eq, Ord, Generic, Data.Data.Data)
    deriving anyclass (Hashable, NFData, NoThunks)
----

It is a recursive data type that contains integers and byte strings,
which can be packed into common lists and maps associated with an
integer. Let’s examine a simple untyped validator script that always
succeeds:

[source,haskell]
----
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE TemplateHaskell     #-}
 
module Gift where
 
import qualified Plutus.V2.Ledger.Api as PlutusV2
import           PlutusTx             (BuiltinData, compile)
import           Prelude              (IO)
import           Utilities            (writeValidatorToFile)
 
------------------------------------------------------------------------------
--------------------------- ON-CHAIN CODE / VALIDATOR ------------------------
 
-- This validator always succeeds
--                    Datum         Redeemer     ScriptContext
mkGiftValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkGiftValidator _ _ _ = ()
{-# INLINABLE mkGiftValidator #-}
 
validator :: PlutusV2.Validator
validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile
                                      	[|| mkGiftValidator ||])


------------------------------------------------------------------------------
-------------------------------- HELPER FUNCTIONS ----------------------------
 
saveVal :: IO ()
saveVal = writeValidatorToFile "./gift.plutus" validator
----

First, we add various language extensions required by the code. Notably,
the [purple]#NoImplicitPrelude# extension prevents the standard `Prelude` module
from being imported. The `PlutusTx` module defines a custom prelude where
all functions use strict evaluation rather than the lazy one. This also
applies to all other functions defined in any module used for Plinth
coding. Then, we import the `Plutus` module that defines functions for
working with Plutus V2 scripts and two functions from the PlutusTx
module. Finally, we import the IO type from the standard `Prelude` module
and a function from a user-defined `Utilities` module, which will be
shown later. After that follows the on-chain code.

We name the validator function [blue]#mkGiftValidator#. It takes three
arguments in the following order: the datum, the redeemer, and the
script context. All of these arguments are [purple]#BuiltinData# types. It returns
an empty tuple, called unit. This type has a single value and can be
compared to the Void type used in other programming languages like Java
or C++. In the body of the function, all input values are ignored, and
the unit value is always returned. As mentioned earlier, the validator
checks a given transaction, so it might be expected to return a Boolean
value, which is true when using the high-level implementation. In the
low-level implementation, the unit is returned when validation succeeds,
and an error is raised if it fails. The next example will cover this
case. It is now clear why this module is called `Gift` – anyone can
claim funds from this address, since the validation will always succeed.

Next, we define the [blue]#validator# parameter, which is the [purple]#PlutusV2.Validator#
type. To get it, we need to compile the validator function to Plutus
script. The [blue]#PlutusTx.compile# function takes a syntax tree of a
function as input, which we can get if we put the Oxford brackets 
`[|| mkGiftValidator ||]` around the validator function. The [blue]#compile#
function produces another syntax tree written in the Plutus language.
Then the `$$` symbol, called splice, takes a syntax tree and splices it
back to Haskell source code, which is needed to be added to the
[blue]#mkValidatorScript# function. The splice operator and the Oxford
brackets can be used because we added the [purple]#TemplateHaskell# language
pragma, which enables this language extension.

It is important to note that normally in Oxford brackets, you cannot
reference anything defined outside of them. This can become an issue
when validator functions are long expressions, or when library functions
are called within their body. A workaround is to make the function
inlinable. By adding the [purple]#INLINABLE# pragma statement after the function
definition, the GHC compiler replaces the function call in the Oxford
brackets with the actual function body.

This completes the on-chain code. Next is a helper function that allows
writing the validator variable to a file. For this, we use the
[blue]#writeValidatorToFile# helper function defined in the `Utilities` 
module. The code for this module is shown below:

[source,haskell]
----
{-# LANGUAGE LambdaCase #-}

module Utilities.Serialise
  ( validatorToScript
  , writeValidatorToFile
  ) where

import           Cardano.Api           (Error (displayError), PlutusScript,
                                        PlutusScriptV2, writeFileTextEnvelope)
import           Cardano.Api.Shelley   (PlutusScript (..))
import           Codec.Serialise       (Serialise, serialise)
import qualified Data.ByteString.Lazy  as BSL
import qualified Data.ByteString.Short as BSS
import qualified Plutus.V2.Ledger.Api  as PlutusV2

serializableToScript :: Serialise a => a -> PlutusScript PlutusScriptV2
serializableToScript = PlutusScriptSerialised . BSS.toShort . BSL.toStrict 
                       . serialise 

-- Serialize validator
validatorToScript :: PlutusV2.Validator -> PlutusScript PlutusScriptV2
validatorToScript = serializableToScript

-- Create file with Plutus script
writeScriptToFile :: FilePath -> PlutusScript PlutusScriptV2 -> IO ()
writeScriptToFile filePath script =
  writeFileTextEnvelope filePath Nothing script >>= \case
    Left err -> print $ displayError err
    Right () -> putStrLn $ "Serialized script to: " ++ filePath

-- Create file with compiled Plutus validator
writeValidatorToFile :: FilePath -> PlutusV2.Validator -> IO ()
writeValidatorToFile filePath = writeScriptToFile filePath . validatorToScript
----

If we execute the [blue]#writeValidatorToFile# function from the `Gift` module,
the content is written to the `gift.plutus` file:

[source,shell]
----
{
	"type": "PlutusScriptV2",
	"description": "",
	"cborHex": "49480100002221200101"
}
----

The output is a JSON representation containing validator information. It
indicates that the smart contract is a Plutus version 2 script, and the
serialized contract can be found in the cborHex field. Since our
contract is simple, the cborHex value is short. For more complex
contracts, this value would increase in length. This information can
then be used in off-chain code when attaching the validator to a
transaction. Let’s now explore an example where the validation logic
always fails, regardless of the input. This module is called `Burn`, as
no funds can be reclaimed from the contract once sent.

[source,haskell]
----
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
 
module Burn where
 
import qualified Plutus.V2.Ledger.Api as PlutusV2
import           PlutusTx             (BuiltinData, compile)
import           PlutusTx.Prelude     (traceError)
 
------------------------------------------------------------------------------
------------------------------ ON-CHAIN / VALIDATOR --------------------------


-- This validator always fails
--                    Datum         Redeemer     ScriptContext
mkBurnValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkBurnValidator _ _ _ = traceError "it burns!!!"
{-# INLINABLE mkBurnValidator #-}
 
validator :: PlutusV2.Validator
validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile
                                      	[|| mkBurnValidator ||])
----

To implement the `Burn` module, we need one additional import compared to
the `Gift` module: the [blue]#traceError# function from the `PlutusTx.Prelude` 
module. This function accepts a [purple]#BuiltinString#, a wrapper around the [purple]#Text#
type, so we also need to add the [purple]#OverloadedStrings# language extension.
In the [blue]#mkBurnValidator# function, the datum, redeemer, and script
context are ignored, and an error with a message is raised, ensuring the
validation fails regardless of the inputs. Alternatively, we could use
the [blue]#error# function, which raises an error without a message.

Below is an example of the redeemer in the validation logic. The
validation passes if the redeemer is an integer with the value 42;
otherwise, it fails:

[source,haskell]
----
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}
 
module FortyTwo where
 
import qualified Plutus.V2.Ledger.Api as PlutusV2
import           PlutusTx             (BuiltinData, compile)
import           PlutusTx.Builtins    as Builtins (mkI)
import           PlutusTx.Prelude     (otherwise, traceError, (==))
 
------------------------------------------------------------------------------
------------------------------ ON-CHAIN / VALIDATOR --------------------------
 
-- This validator succeeds only if the redeemer is 42
--                  Datum         Redeemer     ScriptContext
mk42Validator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mk42Validator _ r _
    | r == Builtins.mkI 42 = ()
    | otherwise            = traceError "expected 42"
{-# INLINABLE mk42Validator #-}
 
validator :: PlutusV2.Validator
validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile 
                                          [|| mk42Validator ||])
----

In the example above, we compare the redeemer to the [purple]#BuiltinData# type 
`I 42`, created using the [blue]#Builtins.mkI# function. If the actual redeemer is
an integer number with value 42, the function returns unit, otherwise,
it raises an error. Let’s examine the same example but written as a
typed validator:

[source,haskell]
----
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}
 
module FortyTwoTyped where
 
import qualified Plutus.V2.Ledger.Api as PlutusV2
import           PlutusTx             (compile)
import           PlutusTx.Prelude     (Bool, Eq ((==)), Integer, traceIfFalse,
                                       ($))
import           Prelude              (IO)
import           Utilities            (wrap)
 
------------------------------------------------------------------------------
------------------------------ ON-CHAIN / VALIDATOR --------------------------
 
-- This validator succeeds only if the redeemer is 42
--              Datum  Redeemer        ScriptContext
mk42Validator :: () -> Integer -> PlutusV2.ScriptContext -> Bool
mk42Validator _ r _ = traceIfFalse "expected 42" $ r == 42
{-# INLINABLE mk42Validator #-}
 
validator :: PlutusV2.Validator
validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile
                                      	[|| wrap mk42Validator ||])
----

We can use the unit type for the datum since the latter is not used. For
the redeemer, we use the [purple]#Integer# type. The script context has to be of
type [purple]#ScriptContext#. This setup allows for a direct comparison of the
redeemer to the number 42. We also use the [blue]#traceIfFalse# function that
raises an error if the condition passed to it is false. Because the
[blue]#PlutusTx.compile# function still expects a function that accepts three
parameters of type [purple]#BuiltinData# and returns unit, we need to apply the
[blue]#wrap# function to the validator function before compiling it. Below
you can see the function definition:

[source,haskell]
----
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE RankNTypes        #-}
 
module Utilities.PlutusTx
  ( wrap
  ) where
 
import           Plutus.V2.Ledger.Api (ScriptContext, UnsafeFromData,
                                       unsafeFromBuiltinData)
import           PlutusTx.Prelude     (Bool, BuiltinData, check, ($))
 
{-# INLINABLE wrap #-}
wrap :: forall a b.
        ( UnsafeFromData a
        , UnsafeFromData b
        )
      => (a -> b -> ScriptContext -> Bool)
      -> (BuiltinData -> BuiltinData -> BuiltinData -> ())
wrap f a b ctx =
  check $ f
      (unsafeFromBuiltinData a)
      (unsafeFromBuiltinData b)
      (unsafeFromBuiltinData ctx)
----

Here, the wrap function accepts the type signature of a typed validator
function and returns the type signature of an untyped validator
function. To convert a function that takes variables of custom types
into one that accepts variables of the [purple]#BuiltinData# type, we use the
conversion function [blue]#unsafeFromBuiltinData#. For this function to be
applicable to the types a and b, both types need to have an instance of
the [purple]#UnsafeFromData# type class.

[source,shell]
----
Prelude> import Plutus.V2.Ledger.Api
Prelude Plutus.V2.Ledger.Api> :i UnsafeFromData
type UnsafeFromData :: * -> Constraint  
class UnsafeFromData a where
  unsafeFromBuiltinData :: BuiltinData -> a
...
Instance UnsafeFromData ScriptContext 
  -- Defined in `Plutus.V2.Ledger.Contexts`
...
----

If we look at this type class, it has the single method called
[blue]#unsafeFromBuiltinData# that we can use to convert the [purple]#BuiltinData#
type to a custom Haskell type. It's unsafe because the [purple]#BuiltinData# type
might fail to convert to the given custom Haskell type. The unit,
integer, and script context data types have instances of the
[purple]#UnsafeFromData# type class.

As mentioned before, the untyped version has a performance advantage. If
we compare the cborHex strings for the typed and untyped script
versions, the string for the typed version is much longer.

The final example shows how to use a custom defined type in the on-chain
code. For specific business problems, code will have very specific data
structures, often in the form of record types. Ideally, these can be
used for the datum and the redeemer. One way to achieve this in
validator functions is by writing an instance of the [purple]#UnsafeFromData# type
class for these types. But because there is template Haskell support for
doing this, you can choose another way. Below is an example where we
define a custom data type for our redeemer:

[source,haskell]
----
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}
 
module CustomTypes where
 
import qualified Plutus.V2.Ledger.Api as PlutusV2
import           PlutusTx             (BuiltinData, compile, 
                                       unstableMakeIsData)
import           PlutusTx.Prelude     (Bool, Eq ((==)), Integer, traceIfFalse,
                                       ($))
import           Prelude              (IO)
import           Utilities            (wrap) 
 
------------------------------------------------------------------------------
------------------------------ ON-CHAIN / VALIDATOR --------------------------
 
-- We can create custom data types for our datum and redeemer like this:
newtype MySillyRedeemer = MkMySillyRedeemer Integer
PlutusTx.unstableMakeIsData ''MySillyRedeemer 
-- Use TH to create an instance for IsData.
 
-- This validator succeeds only if the redeemer is `MkMySillyRedeemer 42`
--              Datum     Redeemer            ScriptContext
mkCTValidator :: () -> MySillyRedeemer -> PlutusV2.ScriptContext -> Bool
mkCTValidator _ (MkMySillyRedeemer r) _ = traceIfFalse "expected 42" $ r == 42
{-# INLINABLE mkCTValidator #-}
 
wrappedMkVal :: BuiltinData -> BuiltinData -> BuiltinData -> ()
wrappedMkVal = wrap mkCTValidator
{-# INLINABLE wrappedMkVal #-}
 
validator :: PlutusV2.Validator
validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile 
                                          [|| wrappedMkVal ||])
----

Here, we define a new type in the code called [purple]#MySillyRedeemer#, which is
simply a wrapper for an integer. We use this type as the redeemer and
validate that the integer it holds is equal to 42. We can use the
[blue]#PlutusTx.unstableMakeIsData# function to define an [purple]#UnsafeFromData#
instance for our type. There is also a stable version of this function,
which gives more control over the deserialization process but requires
additional details to be provided. In template Haskell, you need to add
two single quotes in front of the type’s name to use it as an input
variable. This line of code also creates [blue]#toData# and [blue]#fromData# instances.
We can now pattern match our redeemer value in the [blue]#mkCTValidator# 
validator function. Finally, in the separate [blue]#wrappedMkVal#
function, we apply our [blue]#wrap# function before computing the validator.

We note if a transaction tries to spend multiple UTXOs at a script
address, the spending script is run for every UTXO individually. The
redeemer and the datum are also individually assigned for every UTXO in
that transaction. The redeemer is defined when we construct the spending
the transaction that consumes one or more UTXOs at a script address, and
the datum is defined when we construct the producing transaction that
creates one or more UTXOs at a script address. We will see examples of
how to construct producing and spending transactions in section 
<<Off-chain code with Lucid>>.

=== Script context explained

In the previous example, the script context was not used in the
validation logic. However, in most validator scripts, the [purple]#ScriptContext#
data type is necessary. Since we are working with PlutusV2 scripts the 
<<Plutus smart contracts>> section, we will focus on data types used in 
PlutusV2 scripts and highlight differences to PlutusV3 data types. 
Below is the PlutusV2 [purple]#ScriptContext# data type:

[source,haskell]
----
data ScriptContext = ScriptContext
    { scriptContextTxInfo  :: TxInfo 
    , scriptContextPurpose :: ScriptPurpose 
    }
    deriving stock (Generic, Haskell.Show)
----

As previously mentioned, in Plinth, the validation script has access to
the datum, redeemer, and the transaction (script) context, which
provides information about the inputs and outputs of the transaction
being validated. The image above shows the Haskell implementation of
this data type.

[purple]#ScriptContext# is a record syntax type with two fields: one containing
transaction information and the other representing the script’s purpose.
The script purpose is assigned individually for every action in a
transaction. This means if a transaction tries to mint a native asset
and spend two UTXOs at a script address, there are three script purposes
that this transaction carries: one for minting and two for spending. The
transaction info is only one for a single transaction, and all scripts
and policies that are triggered by this transaction can access it. In
the PlutusV3 script context, the datum and redeemer are moved inside the
script context. The redeemer can be accessed directly from the script
context type, and the datum of a UTXO that we want to spend can be
accessed from the [purple]#ScriptInfo# field.

[source,haskell]
----
data ScriptContext = ScriptContext
    { scriptContextTxInfo     :: TxInfo
    , scriptContextRedeemer   :: V2.Redeemer
    , scriptContextScriptInfo :: ScriptInfo
    }
    deriving stock (Generic, Haskell.Eq, Haskell.Show)
    deriving anyclass (HasBlueprintDefinition)
----

The [purple]#ScriptPurpose# data type for PlutusV2 indicates the purpose of the
Plinth script, and there are four possible values for this data type.

[source,haskell]
----
data ScriptPurpose
    = Minting CurrencySymbol
    | Spending TxOutRef
    | Rewarding StakingCredential
    | Certifying DCert
    deriving stock (Generic, Haskell.Show, Haskell.Eq)
    deriving Pretty via (PrettyShow ScriptPurpose)
----

Minting is used when minting (creating) or burning (destroying) native
tokens. Spending is used to spend funds sitting at a script address.
Rewarding is used for withdrawing staking rewards. Certifying is for
issuing certificates. The PlutusV3 script purpose is called [purple]#ScriptInfo#
and is illustrated below. Compared to the PlutusV2 script purpose, it
contains in addition constructors for a voting script and a proposing
script. Also for spending it contains a maybe datum which is present in
we attached a datum or its hash to the UTXO. In PlutusV3, you are
allowed to spend a UTXO sitting at a script address in case it does not
contain a datum. In PlutusV2 this is not possible and an empty datum
needs to be attached to the UTXO if the datum is not being used by the
smart contract code.

[source,haskell]
----
data ScriptInfo
    = MintingScript V2.CurrencySymbol
    | SpendingScript V3.TxOutRef (Haskell.Maybe V2.Datum)
    | RewardingScript V2.Credential
    | CertifyingScript
        Haskell.Integer
        TxCert
    | VotingScript Voter
    | ProposingScript
        Haskell.Integer
        ProposalProcedure
    deriving stock (Generic, Haskell.Show, Haskell.Eq)
    deriving anyclass (HasBlueprintDefinition)
    deriving (Pretty) via (PrettyShow ScriptInfo)
----

In this section, we will focus on the spending purpose, so we look at
the transaction output reference [purple]#TxOutRef# data type that is contained in
the spending constructor:

[source,haskell]
----
data TxOutRef = TxOutRef {
    txOutRefId  :: TxId, 
    txOutRefIdx :: Integer 
    }
    deriving stock (Show, Eq, Ord, Generic)
    deriving anyclass (NFData)
----

It defines a UTXO reference that is composed of the transaction ID,
which is an SHA-256 hash, and the transaction index, which is an integer
number. The [purple]#TxId# data type is a wrapper around the type
[purple]#BuiltinByteString#. Each UTXO a transaction creates gets a transaction
index assigned starting with 0 and increasing by 1. Because transaction
IDs are unique, a UTXO defined by the transaction ID and the output
index is also unique and can exist only once. Transaction hashes are
unique because a new transaction hash includes the hash of the
transaction that created the UTXO being consumed. Every transaction is
consuming at least one UTXO as it needs to pay some fees. By a simple
induction argument, it follows that two identical transaction hashes can
never exist.

Let’s now look at the transaction information – [purple]#TxInfo# – data type that
constitutes the second half of information contained in the script
context:

[source,haskell]
----
data TxInfo = TxInfo
    { txInfoInputs          :: [TxInInfo] 
    , txInfoReferenceInputs :: [TxInInfo] 
    , txInfoOutputs         :: [TxOut] 
    , txInfoFee             :: Value 
    , txInfoMint            :: Value 
    , txInfoDCert           :: [DCert] 
    , txInfoWdrl            :: Map StakingCredential Integer 
    , txInfoValidRange      :: POSIXTimeRange 
    , txInfoSignatories     :: [PubKeyHash] 
    , txInfoRedeemers       :: Map ScriptPurpose Redeemer 
    , txInfoData            :: Map DatumHash Datum 
    , txInfoId              :: TxId  
    } deriving stock (Generic, Haskell.Show)
----

In the beginning, it contains a list of transaction inputs and reference
inputs. Reference inputs are inputs accessible by the script context but
not consumed by the transaction. They are only referenced, hence the
name. A transaction may need access to a UTXO without consuming it
because the UTXO can contain important information in the datum that
scripts can access. This information can be arbitrary data contained in
the datum or an attached reference script, which is a serialized smart
contract compiled to Plutus. The advantage of reference scripts is that
instead of appending a script to a transaction that wants to spend funds
at the script address, we simply reference this script from the UTXO
that carries it. This lowers the transaction size and reduces the
transaction cost. A code example of this is presented in section 
<<Off-chain code with Lucid>>. Another advantage of reference inputs is
that several transactions in the same block can use the same UTXO as a
reference input, since it is not being consumed by any of those
transactions. Transaction inputs and reference inputs are lists of type
transaction input info [purple]#TxInInfo# that defines the input of a pending
transaction.

[source,haskell]
----
data TxInInfo = TxInInfo
    { txInInfoOutRef   :: TxOutRef
    , txInInfoResolved :: TxOut
    } deriving stock (Generic, Haskell.Show, Haskell.Eq)
----

It is defined by a transaction output reference and resolved transaction
input information, which is defined by the transaction output [purple]#TxOut# data
type.

[source,haskell]
----
data TxOut = TxOut {
    txOutAddress         :: Address,
    txOutValue           :: Value,
    txOutDatum           :: OutputDatum,
    txOutReferenceScript :: Maybe ScriptHash
    }
    deriving stock (Show, Eq, Generic)
----

The resolved input information defines the address where the UTXO
resides, the value it contains, the output datum attached to the UTXO,
and a possible script hash also associated with the UTXO. Below is the
address data type:

[source,haskell]
----
data Address = Address
    { addressCredential        :: Credential
    , addressStakingCredential :: Maybe StakingCredential
    }
    deriving stock (Eq, Ord, Show, Generic, Typeable)
    deriving anyclass (NFData, HasBlueprintDefinition)
----

As explained in section <<Cardano addresses>>, an address is composed
of two parts: the payment part and the optional staking part. The
payment part, defined with the [purple]#Credential# data type, contains either a
public key hash or a script hash:

[source,haskell]
----
data Credential
    = PubKeyCredential PubKeyHash
    | ScriptCredential ScriptHash
      deriving stock (Eq, Ord, Show, Generic, Typeable)
      deriving anyclass (NFData, HasBlueprintDefinition)
----

The hashes are both of type [purple]#BuiltinByteString#. The staking part is
defined with the [purple]#StakingCredential# data type that can be either a
staking hash or a staking pointer.

[source,haskell]
----
data StakingCredential
    = StakingHash Credential
    | StakingPtr
        Integer -- ^ the slot number
        Integer -- ^ the transaction index (within the block)
        Integer -- ^ the certificate index (within the transaction)
    deriving stock (Eq, Ord, Show, Generic, Typeable)
    deriving anyclass (NFData, HasBlueprintDefinition)
----

Next is the [purple]#Value# type that defines an amount of ada and/or native
tokens:

[source,haskell]
----
newtype Value = Value { getValue :: Map.Map CurrencySymbol (Map.Map TokenName Integer) }
    deriving stock (Generic, Typeable, Haskell.Show)
    deriving newtype (PlutusTx.ToData, PlutusTx.FromData, PlutusTx.UnsafeFromData)
    deriving Pretty via (PrettyShow Value)
----

Every native token is defined with a currency symbol and a token name.
They are both of type [purple]#BuiltinByteString#. The currency symbol is computed
as the hash of the minting policy, and the token name can be an
arbitrary string (but should not be longer than 32 bytes). The ada token
is defined by an empty byte string both for currency symbol and token
name, which means you cannot mint ada. Next, we examine the [purple]#OutputDatum#
data type:

[source,haskell]
----
data OutputDatum 
    = NoOutputDatum 
    | OutputDatumHash DatumHash 
    | OutputDatum Datum
    deriving stock (Show, Eq, Generic)
    deriving anyclass (NFData)
----

UTXO can either contain no datum, a datum hash or a datum. A datum hash
contains a string of type [purple]#BuiltinByteString# and the datum type is a
wrapper around the [purple]#BuiltinData# type. The last constructor for the [purple]#TxOut#
data type contains a [purple]#Maybe ScriptHash#, which is also a wrapper around a
[purple]#BuiltinByteString#. If we return to the [purple]#TxInfo# data type, the next
components are the constructors for fees and minting, both of which are
of type [purple]#Value#. Then follows the constructor that handles certificates,
which is defined by a list of the [purple]#DCert# data type:

[source,haskell]
----
data DCert
    = DCertDelegRegKey StakingCredential
    | DCertDelegDeRegKey StakingCredential
    | DCertDelegDelegate
        StakingCredential -- delegator
        PubKeyHash        -- delegatee
    | -- A digest of the PoolParams
      DCertPoolRegister
        PubKeyHash        -- poolId
        PubKeyHash        -- pool VFR
    | -- The retirement certificate and the Epoch in which the retirement will take place
      DCertPoolRetire PubKeyHash Integer 
    | -- A really terse Digest
      DCertGenesis
    | -- Another really terse Digest
      DCertMir
      deriving stock (Eq, Ord, Show, Generic, Typeable)
      deriving anyclass (NFData, HasBlueprintDefinition)
      deriving Pretty via (PrettyShow DCert)
----

The [purple]#DCert# data type has seven constructors representing the following
certificates:

[arabic]
. Registering a staking credential
. Deregistering a staking credential
. Delegating to a stake pool
. Registering a stake pool
. Retiring a stake pool
. Genesis key delegation certificate
. Paying https://projectcatalyst.io/[Catalyst] winners from the
treasury.

In PlutusV3, the names and structures change. The constructor becomes
[blue]#txInfoTxCerts#, and the type becomes [purple]#TxCert#. The constructors and
structure of [purple]#TxCert# also differ in comparison to Plutus V2. After
certificates comes the constructor that manages withdrawals of staking
rewards. This is covered in section <<Staking and Plinth>>. Next
follows the transaction validity range, which is defined with the data
type [purple]#POSIXTimeRange#:

[source,haskell]
----
type POSIXTimeRange = Interval POSIXTime
----

The [purple]#POSIXTimeRange# data type contains an [purple]#Interval# type, parameterized with
the [purple]#POSIXTime# type. [purple]#POSIXTime# is a wrapper for an integer, representing
the number of milliseconds that have passed since January 1, 1970, at 00:00. 

[source,haskell]
----
newtype POSIXTime = POSIXTime {getPOSIXTime :: Integer}
    deriving stock (Haskell.Eq, Haskell.Ord, Haskell.Show, Generic, Typeable)
    deriving anyclass (NFData, HasBlueprintDefinition)
    deriving newtype
      ( AdditiveSemigroup
      , AdditiveMonoid
      , AdditiveGroup
      , Eq
      , Ord
      , Enum
      , PlutusTx.ToData
      , PlutusTx.FromData
      , PlutusTx.UnsafeFromData
      , Haskell.Num
      , Haskell.Enum
      , Haskell.Real
      , Haskell.Integral
      )
----

The [purple]#Interval# type holds data about the lower and upper bounds of
the validity interval for the specified transaction.

[source,haskell]
----
data Interval a = Interval 
    { ivFrom :: LowerBound a, 
      ivTo :: UpperBound a 
    }  
    deriving stock (Haskell.Show, Generic)
    deriving anyclass (NFData)
----

The lower and upper bound types are structured in the same way. They
hold the [purple]#Extended# and [purple]#Closure# types:

[source,haskell]
----
data LowerBound a = LowerBound (Extended a) Closure
    deriving stock (Haskell.Show, Generic)
    deriving anyclass (NFData)
----

The [purple]#Closure# type is just a wrapper for a Boolean which indicates whether
the boundary is included in the interval or not. The extended type has
three possible constructor values, which represent negative infinity,
positive infinity, or a finite bound parameterized, in our case, by a
[purple]#POSIXTime# type. The module `Plutus.V2.Ledger.Interval` defines the
following helper functions that work with time intervals:

* [blue]#member#: checks whether a value is in an interval
* [blue]#interval#: takes two parameters as input and constructs an interval
with included boundaries
* [blue]#from#: takes a value and returns an interval that includes all values
greater than or equal to the given value
* [blue]#to#: takes a value and returns an interval that includes all values
that are smaller than or equal to the given value
* [blue]#always#: an interval that covers every possible time
* [blue]#never#: an interval that is empty
* [blue]#singleton#: takes a value and returns an interval that only contains
the single value
* [blue]#hull#: takes two intervals as input and returns the smallest interval
containing both intervals
* [blue]#intersection#: takes two intervals as input and returns the largest
interval contained in both of the intervals, if it exists
* [blue]#overlap#: checks whether two intervals have a value in common and
returns a Boolean
* [blue]#contains#: checks whether the second interval is contained in the
first one, and returns a Boolean
* [blue]#isEmpty#: checks whether an interval is empty and returns a Boolean
* [blue]#before#: checks whether a given time is before the given interval and
returns a Boolean
* [blue]#after#: checks whether a given time is after the given interval and
returns a Boolean.

After the validity range in the [purple]#TxInfo# data type, the transaction
information continues with the following elements:

[arabic]
. List of public key hashes: these represent the public keys that signed
the transaction
. Map of redeemers: mapped to different script purposes, this object
holds the redeemers associated with the various actions in the
transaction
. Map of datums: this object maps datum hashes to their corresponding
actual datum values; if a UTXO at a script address has only a datum
hash, the actual datum must be attached to the spending transaction and
can be accessed through this field
. Transaction hash: the unique identifier for the transaction itself.

All of this information in the [purple]#TxInfo# data type is accessible by a
validation script. In Plutus V3 the transaction information type in
addition to the changed certification part, four additional constructors
are added. The PlutusV3 [purple]#TxInfo# data type is illustrated below.

[source,haskell]
----
data TxInfo = TxInfo
  { txInfoInputs                :: [TxInInfo]
  , txInfoReferenceInputs       :: [TxInInfo]
  , txInfoOutputs               :: [V2.TxOut]
  , txInfoFee                   :: V2.Lovelace
  , txInfoMint                  :: V2.Value
  , txInfoTxCerts               :: [TxCert]
  , txInfoWdrl                  :: Map V2.Credential V2.Lovelace
  , txInfoValidRange            :: V2.POSIXTimeRange
  , txInfoSignatories           :: [V2.PubKeyHash]
  , txInfoRedeemers             :: Map ScriptPurpose V2.Redeemer
  , txInfoData                  :: Map V2.DatumHash V2.Datum
  , txInfoId                    :: V3.TxId
  , txInfoVotes                 :: Map Voter (Map GovernanceActionId Vote)
  , txInfoProposalProcedures    :: [ProposalProcedure]
  , txInfoCurrentTreasuryAmount :: Haskell.Maybe V2.Lovelace
  , txInfoTreasuryDonation      :: Haskell.Maybe V2.Lovelace
  }
  deriving stock (Generic, Haskell.Show, Haskell.Eq)
  deriving anyclass (HasBlueprintDefinition)
----

The four additional constructors focus on voting, proposals, and
interactions with the Cardano treasury. Learn more about governance
features, including the topics of voting and proposal submission in
chapter <<Cardano governance>>.

=== Time-dependent and parameterized validators

This section demonstrates a smart contract representing a vesting
schema. In this scenario, a person sends a gift of ada to the smart
contract, and the beneficiary can reclaim this gift after a set deadline
has passed. Here is a code example:

[source,haskell]
----
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
 
module Vesting where
 
import           Data.Maybe                (fromJust)
import           Plutus.V1.Ledger.Interval (contains)
import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, 
                                            PubKeyHash,
                                            ScriptContext 
                                            (scriptContextTxInfo),
                                            TxInfo (txInfoValidRange),
                                            Validator, from, 
                                            mkValidatorScript)
import           Plutus.V2.Ledger.Contexts (txSignedBy)
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&))
import           Prelude                   (IO, String)
import           Utilities                 (Network, posixTimeFromIso8601,
                                            printDataToJSON,
                                            validatorAddressBech32, wrap,
                                            writeValidatorToFile)
 
------------------------------------------------------------------------------
------------------------------ ON-CHAIN / VALIDATOR --------------------------
 
data VestingDatum = VestingDatum
    { beneficiary :: PubKeyHash
    , deadline    :: POSIXTime
    }
 
unstableMakeIsData ''VestingDatum
 
{-# INLINABLE mkVestingValidator #-}
mkVestingValidator :: VestingDatum -> () -> ScriptContext -> Bool
mkVestingValidator dat () ctx = traceIfFalse "beneficiary's signature missing" 
                                             signedByBeneficiary &&
                                traceIfFalse "deadline not reached" 
                                             deadlineReached
  where
    info :: TxInfo
    info = scriptContextTxInfo ctx
 
    signedByBeneficiary :: Bool
    signedByBeneficiary = txSignedBy info $ beneficiary dat
 
    deadlineReached :: Bool
    deadlineReached = contains (from $ deadline dat) $ txInfoValidRange info
 
{-# INLINABLE  mkWrappedVestingValidator #-}
mkWrappedVestingValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedVestingValidator = wrap mkVestingValidator
 
validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedVestingValidator ||])
 
------------------------------------------------------------------------------
-------------------------------- HELPER FUNCTIONS ----------------------------
 
saveVal :: IO ()
saveVal = writeValidatorToFile "./assets/vesting.plutus" validator
 
printVestingDatumJSON :: PubKeyHash -> String -> IO ()
printVestingDatumJSON pkh time = printDataToJSON $ VestingDatum
    { beneficiary = pkh
    , deadline    = fromJust $ posixTimeFromIso8601 time
    }
----

The validator uses a typed version with a custom data type for the
datum, called [purple]#VestingDatum#. It includes two fields: [blue]#beneficiary#, of type
[purple]#PubKeyHash#, and [blue]#deadline#, of type [purple]#POSIXTime#. The validation logic
indicates that the funds can be unlocked only when the deadline has been
reached and the transaction is signed by the beneficiary. The validation
code includes helper variables [blue]#signedByBeneficiary# and [blue]#deadlineReached#,
which are of type [purple]#Bool#. In the first variable, we use the helper
function [blue]#txSignedBy# that takes a transaction info and a public key
hash and checks whether this transaction has been signed with this
public key hash. In the second variable, we access the transaction
validity range and check whether it is contained inside the interval
starting with the deadline and going to infinity. Then, we wrap the
validator function and compile it to a [purple]#Validator# type. In the helper
functions section, we have the [blue]#saveVal# function that writes the
validator to a `.plutus` file. There is also a [blue]#printVestingDatumJSON#
function that takes a public key hash and a string, which contains the
time in ISO 8601 format and prints the datum in JSON format to the
terminal. If we run this function and input a date and time together
with a public key hash, we get the following example output:

[source,shell]
----
Prelude> import Vesting
Prelude Vesting> :set -XOverloadedStrings
Prelude Vesting> import Plutus.V2.Ledger.Api
Prelude Vesting Plutus.V1.Ledger.Api> 
pkh1 = "cff6e39ec5b3cf84b1078976c98706b73774d2c5523af4daaf7c5109"
Prelude Vesting Plutus.V1.Ledger.Api>
printVestingDatumJSON pkh1 "2023-03-11T13:12:11.123Z"
{
	"constructor": 0,
	"fields": [
    		{
        	      "bytes": "cff6e39ec5b3cf84b1078976c98706b73774d2c5523af4daaf7c5109"
    		},
    		{
        	      "int": 1678540331123
    		}
	]
}
----

This datum can then be stored in a JSON file and later used in off-chain
code. In the examples we have seen so far, we had one specific validator
that was a Haskell value of type [purple]#Validator#. If there is any variability
in the contract, we model that by using the datum as in the vesting
example, where the datum contained the beneficiary and the deadline. An
alternative approach is parameterized contracts, where variability is
integrated into the contract by adding a parameter variable to the
validator function. The code below shows this, containing a modified
version of the previous code example:

[source,haskell]
----
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NoImplicitPrelude     #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
 
module ParameterizedVesting where
 
import           Plutus.V1.Ledger.Interval (contains)
import           Plutus.V2.Ledger.Api      (BuiltinData, POSIXTime, 
                                            PubKeyHash,
                                            ScriptContext 
                                            (scriptContextTxInfo),
                                            TxInfo (txInfoValidRange),
                                            Validator, from, 
                                            mkValidatorScript)
import           Plutus.V2.Ledger.Contexts (txSignedBy)
import           PlutusTx                  (applyCode, compile, liftCode,
                                            makeLift)
import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (&&), 
                                            (.))
import           Prelude                   (IO)
import           Utilities                 (wrapValidator, 
                                            writeValidatorToFile)
 
------------------------------------------------------------------------------
---------------------------- ON-CHAIN / VALIDATOR ----------------------------
 
data VestingParams = VestingParams
    { beneficiary :: PubKeyHash
    , deadline    :: POSIXTime
    }
makeLift ''VestingParams
 
{-# INLINABLE mkParameterizedVestingValidator #-}
mkParameterizedVestingValidator :: VestingParams -> () -> () -> 
                                   ScriptContext -> Bool
mkParameterizedVestingValidator params () () ctx =
    traceIfFalse "beneficiary's signature missing" signedByBeneficiary &&
    traceIfFalse "deadline not reached" deadlineReached
  where
    info :: TxInfo
    info = scriptContextTxInfo ctx
 
    signedByBeneficiary :: Bool
    signedByBeneficiary = txSignedBy info $ beneficiary params
 
    deadlineReached :: Bool
    deadlineReached = contains (from $ deadline params) $ 
                               txInfoValidRange info
 
{-# INLINABLE  mkWrappedParameterizedVestingValidator #-}
mkWrappedParameterizedVestingValidator :: VestingParams -> BuiltinData -> 
                                          BuiltinData -> BuiltinData -> ()
mkWrappedParameterizedVestingValidator = wrapValidator . 
                                         mkParameterizedVestingValidator
 
validator :: VestingParams -> Validator
validator params = mkValidatorScript ($$(compile [||
                                  	  mkWrappedParameterizedVestingValidator    
                                      ||]) `applyCode` liftCode params)  
 
------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS -------------------------------
 
saveVal :: VestingParams -> IO ()
saveVal = writeValidatorToFile "./assets/parameterized-vesting.plutus" .
                      	       validator
----

First, we create the [purple]#VestingParams# type, which was previously called
[purple]#VestingDatum#. It holds the beneficiary’s public key hash and the
deadline after which the beneficiary can claim the funds. We do not need
the [blue]#unstableMakeIsData# instance. The type signature of the validator
function changes such that it takes the additional vesting parameter.
Additionally, the datums type changes to unit. We note that a validator
function can take any number of parameters. Our example uses only one
parameter. Then, for the input arguments of the validator function, we
add the parameter [blue]#params# and change the [blue]#dat# parameter to unit. We
also need to update the type signature of the
[blue]#mkWrappedParameterizedVestingValidator# function. We then write the
body of the function with point free style using only the dot `.` operator
that we have to import. For the [blue]#validator#, we expect a function
instead of a single value, so we update its type signature accordingly,
which now represents a family of validators. Now, in the body of the
validator, we cannot simply pass the input parameter to the
[blue]#mkWrappedParameterizedVestingValidator# function. Because we are using
template Haskell, all the data that template Haskell splices must be
known at compile time because this step runs before our program is even
compiled. However, the parameter we are passing to the validator
function is only known at runtime. So, template Haskell does not know
what code to generate and splice into the source code. What we can do is
apply the compiled validator function to the compiled input parameter
because the compiled validator function in Plinth script is still a
function. We do this with the help of the [blue]#applyCode# function, which
allows us to pass a parameter to a script function. But we still need to
know the value of the input parameter at compile time, which is not
possible. Note that the input parameter is not some arbitrary Haskell
function, it is static data, which you can pass at runtime to a script
function if you create an instance of the type class [purple]#Lift#. Then, we only
need to apply the function [blue]#liftCode# to the data to compile the input
parameter at runtime. Let us take a look at the [purple]#Lift# class:

[source,haskell]
----
class Lift uni a where
    -- | Get a Plutus IR term corresponding to the given value.
    lift :: a -> RTCompile uni fun (Term TyName Name uni fun ())
----

It contains only the [blue]#lift# method, but we will not use that directly.
There are a lot of instances for this type class for all possible data
types such as [purple]#BuiltinData#, [purple]#Data#, [purple]#Integer# and 
[purple]#Bool#. However, this is not used for functions, as they cannot be 
used to compile Haskell to Plutus validators. The `PlutusTx` module defines 
this type class, and the [blue]#liftCode# function:

[source,haskell]
----
liftCode
    :: ( Lift.Lift uni a, PLC.GEq uni, ThrowableBuiltins uni fun, PLC.Typecheckable uni fun
       , Default (PLC.CostingPart uni fun)
       , Default (PIR.BuiltinsInfo uni fun)
       , Default (PIR.RewriteRules uni fun)
       , Hashable fun
       )
    => PLC.Version -> a -> CompiledCodeIn uni fun a
----

The input variable of type a must-have an instance of the [purple]#Lift# type
class. Because we are using a custom defined type in our on-chain code,
we can use a template Haskell mechanism to define an instance for our
type. We do this with the following code:

[source,shell]
----
makeLift ''VestingParams
----

This line only compiles if the [purple]#MultiParamTypeClasses# and
[purple]#ScopedTypeVariables# language extensions are enabled.

We have now presented the procedure on writing parameterized contracts.
If there would be more than one parameter, we would need to use the
[blue]#applyCode# function multiple times for each of the lifted parameters one
after the other. An example is included in section <<Minting policies>>.

=== Off-chain code with Lucid

The blockchain is passive – it only acts when a user interacts with it.
The code that queries the blockchain, builds, and submits transactions
is called off-chain code. Off-chain code does not need to have the same
performance and security standards as on-chain code. Further comparison
between on-chain and off-chain code will be made in section 
<<Onchain vs off chain Code>>. In this section, we will showcase how to
write off-chain code for the on-chain code example presented in the
previous section.

After the Alonzo era, when smart contracts became available on Cardano,
the https://github.com/IntersectMBO/plutus-apps[Plutus application platform] 
provided a way to write off-chain code.
Developed by IO and implemented as a set of Haskell libraries, it
allowed users to write and submit transactions using the Contract monad.
A single Haskell file could contain on-chain and off-chain code.
Currently, the platform is in maintenance mode and no longer under
active development.

Another way for constructing off-chain transactions is by using the
https://github.com/input-output-hk/cardano-cli[Cardano CLI]. Examples
of using the Cardano CLI are included in the Plutus Pioneer program’s
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[4th
iteration] GitHub repository, specifically in the code examples and
lectures from the third and fourth weeks. The bash scripts were tested
with version 1.35.5 of the Cardano node and Cardano CLI.

There are several community-built tools for writing off-chain code in
various programming languages. Some of them are listed at the end of
section <<Smart contract programming languages>>, where
off-chain code is briefly covered. For those using Plinth and interested
in writing off-chain code in Haskell, the https://atlas-app.io/[Atlas]
application backend, developed by GeniusYield, provides a solution. It
allows code-sharing between the on-chain and off-chain components while
enabling the creation of a backend for decentralized applications.

This section explores the https://lucid.spacebudz.io/[Lucid] tool,
developed by Spacebuzd. It can be used as a NodeJS package to construct
and submit transactions interacting with a smart contract using
JavaScript or TypeScript. We make an important distinction between
off-chain and on-chain code at this point. Because Cardano uses the hard fork
combinator technology, all Plutus script versions are supported by the
blockchain (read more in section <<Cardano node layers>>). Once you have writen on-chain
code that works, it will work indefinitely. That is not the case for
off-chain code. 

Some of the off-chain code example presented in this section may
not work in the Conway era because Lucid version 0.9.1, used in this
section, does not correctly calculate the minimum ada for instance when attaching a
reference script to a transaction. Off-chain code built for a specific
Cardano era and a Lucid library version, or any other off-chain library, may not
work in future eras if blockchain parameters change. As the time of writing,
Lucid version 0.10.7 also lacks a fix, but the main branch of the
https://github.com/spacebudz/lucid[Lucid repository] does 
https://github.com/spacebudz/lucid/pull/254[include one]. You can 
check the Lucid page at https://deno.land/x/lucid[Deno land] if there 
is a newer version published at the time of reading. In case it is not, 
you can clone the repository locally and reference the `mod.ts` file 
directly in the code.

[source,typescript]
----
import {
    Data,
    Lucid,
    Blockfrost,
    getAddressDetails,
    SpendingValidator,
    TxHash,
    Datum,
    UTxO,
    Address,
    AddressDetails,
} from "./<path>/<to>/<local>/lucid/mod.ts"
----

If you use the latest Lucid updates, you should also use an up-to-date
Deno version. The Deno version in the Docker container for the Plinth
development environment (discussed in section <<Setting up a Plinth development environment>>) will not compile
code with the latest Lucid updates. It’s important to note that the Lucid 
project is not very actively maintained, and further development is
occurring under the https://github.com/Anastasia-Labs/lucid-evolution[Lucid Evolution] 
project by AnastasiaLabs, funded in
https://projectcatalyst.io/funds/11/cardano-open-developers/anastasia-labs-lucid-evolution-redefining-off-chain-transactions-in-cardano[Catalyst
Fund11]. Once Lucid Evolution is available and actively maintained,
developers will simply need to upgrade to the latest version and re-test
their DApp’s off-chain code.

For our example, we will write off-chain code with Lucid 0.9.1 that interacts 
with the vesting smart contract presented in section 
<<Time-dependent and parameterized validators>>. Our code will reside in 
TypeScript files to leverage some of the type system’s features. We will run 
our code using https://deno.com/[Deno], which is a runtime for JavaScript and
TypeScript. To use Deno, you can find definitions and short code
examples for Lucid name spaces, classes, variables, functions,
interfaces and type aliases https://deno.land/x/lucid@0.9.1/mod.ts[on
this page]. We will use Lucid version 0.9.1 and call the code file
`lucid-vesting.ts`.

[source,typescript]
----
import {
    Data,
    Lucid,
    Blockfrost,
    getAddressDetails,
    SpendingValidator,
    TxHash,
    Datum,
    UTxO,
    Address,
    AddressDetails,
} from "https://deno.land/x/lucid@0.9.1/mod.ts"
// create a seed.ts file with your seed
import { secretSeed } from "./seed.ts"
 
// set blockfrost endpoint
const lucid = await Lucid.new(
  new Blockfrost(
    "https://cardano-preview.blockfrost.io/api/v0",
    "insert your own api key here"
  ),
  "Preview"
);
 
// load local stored seed as a wallet into lucid
lucid.selectWalletFromSeed(secretSeed);
const addr: Address = await lucid.wallet.address();
console.log(addr);
----

First, we import the necessary components. The `seed.ts` file should
contain the seed for your Cardano wallet, with all the words separated
by spaces, as shown in the following example:

[source,shell]
----
export const secretSeed = "seed_word1 seed_word2 ... seed_wordN";
----

Next, we initiate Lucid as a constant using the [blue]#new# method, which
requires a provider and a network. The provider enables fetching and
submitting data to the blockchain. We specify the network (mainnet,
pre-production, or preview) and use https://blockfrost.io/[Blockfrost]
as the provider to run a full node for us. Users can get an API key from
the Blockfrost web page for free. Lucid can then request data from the
blockchain in various formats. You can also connect Lucid to a provider
that you host yourself. In the above code example, we chose the preview
network. If you want to test the code from this section, your wallet
needs to have some test ada on the preview network. If a different
network is selected, update the URL and the last string in the code
block that initiates Lucid. Next, we tell Lucid how to connect to a
wallet, which can be done in multiple ways as outlined in the
documentation. We select the wallet via a seed phrase imported earlier
and log the address of our wallet. To get the address, run the following
command from the VSCode terminal, which you can set up using
instructions from section <<Setting up a Plinth development environment>>:

[source,shell]
----
/<path>/<to>/<file># deno run -A lucid-vesting.ts
addr_test1vr8ldcu7ckeulp93q7yhdjv8q6mnwaxjc4fr4ax64a79zzgm5xd7e
----

The wallet address is then displayed in the terminal. If multiple
accounts reside in the wallet, you can specify one by adding the
[blue]#accountIndex# when selecting the address. Only one account can be
selected at a time; however, you can select different accounts
sequentially and store their addresses in different variables. The last
selected account is the one that Lucid keeps track of. Below is an
example code:

[source,typescript]
----
lucid.selectWalletFromSeed(secretSeed, { accountIndex: 0 });
const addr0: Address = await lucid.wallet.address();
console.log("Address for account 0: " + addr0);
lucid.selectWalletFromSeed(secretSeed, { accountIndex: 1 });
const addr1: Address = await lucid.wallet.address();
console.log("Address for account 1: " + addr1);
----

Next, let’s look at some variables we define in our TypeScript code: 

[source,typescript]
----
// Define the vesting Plutus script
const vestingScript: SpendingValidator = {
    type: "PlutusV2",
    script: "590b30590b2d01000032323233223232332…",
};
const vestingAddress: Address = lucid.utils.validatorToAddress(vestingScript);
 
// Create the vesting datum type
const VestingDatum = Data.Object({
    beneficiary: Data.String,
    deadline: Data.BigInt,
});
type VestingDatum = Data.Static<typeof VestingDatum>;
 
// Set the vesting deadline
const deadlineDate: Date = new Date("2023-03-19T00:00:00Z")
const deadlinePosIx = BigInt(deadlineDate.getTime());
 
// Set the vesting beneficiary to our own key.
const details: AddressDetails = getAddressDetails(addr);
const beneficiaryPKH: string = details.paymentCredential.hash
 
// Creating a datum with a beneficiary and deadline
const datum: VestingDatum = {
    beneficiary: beneficiaryPKH,
    deadline: deadlinePosIx,
};
----

First, we define the vesting script that will be of type
[purple]#SpendingValidator# (we can copy the CBORHEX from our `vesting.plutus` file created
in section <<Time-dependent and parameterized validators>>). Note
that the code snippet shows only part of the serialized script, since it
is very long. Then, we compute the vesting address from the script and
define the vesting datum type. To play around with the types, we start a
Deno REPL:

[source,shell]
----
# deno repl
> import * as L from "https://deno.land/x/lucid@0.9.1/mod.ts"
> L.data
----

The last command provides a list of possible types for constructing the
datum. Next, we define the datum type and compute the deadline variable,
using a date that has already passed. We convert the ISO UTC time to
POSIX time, compute the address details, and define the beneficiary’s
payment public key hash. Finally, we specify the datum for the contract
and attempt to construct and sign the transaction.

[source,typescript]
----
// An asynchronous function that sends an amount of Lovelace to the script 
// with the above datum.
async function vestFunds(amount: bigint): Promise<TxHash> {
    const dtm: Datum = Data.to<VestingDatum>(datum,VestingDatum);
    const tx = await lucid
      .newTx()
      .payToContract(vestingAddress, { inline: dtm }, { lovelace: amount })
      .complete();
    const signedTx = await tx.sign().complete();
    const txHash = await signedTx.submit();
    return txHash
}
 
console.log(await vestFunds(100000000n));
----

The classes used to manage a transaction are called [purple]#Tx#, [purple]#TxComplete#, and
[purple]#TxSigned#. To construct a transaction, we use the [blue]#newTx# function, which
returns a variable of type [purple]#Tx#. Then, we use the [blue]#payToContract# and
[blue]#complete# functions of the [purple]#Tx# class. In the first function, we input the
address to which we are sending the funds, the amount, and the inline
datum. The second function returns a variable of type [purple]#TxComplete#. After
that, we can use the functions sign and complete from the [purple]#TxComplete#
class. The last one returns a variable of type [purple]#TxSigned#. We now use the
function [blue]#submit# from the [purple]#TxSigned# class to submit the transaction, which
returns a transaction hash that we return at the end of the [blue]#vestFunds#
function. Next we look at the function that claims the vested funds.

[source,typescript]
----
async function claimVestedFunds(): Promise<TxHash> {
    const dtm: Datum = Data.to<VestingDatum>(datum,VestingDatum);
    const utxoAtScript: UTxO[] = await lucid.utxosAt(vestingAddress);
    const ourUTxO: UTxO[] = utxoAtScript.filter((utxo) => utxo.datum == dtm);
   
    if (ourUTxO && ourUTxO.length > 0) {
        const tx = await lucid
            .newTx()
            .collectFrom(ourUTxO, Data.void())
            .addSignerKey(beneficiaryPKH)
            .attachSpendingValidator(vestingScript)
            .validFrom(Date.now()-100000)
            .complete();
 
        const signedTx = await tx.sign().complete();
        const txHash = await signedTx.submit();
        return txHash
    }
    else return "No UTxO's found that can be claimed"
}
 
console.log(await claimVestedFunds());
----

First, we define the datum. Then, we look up which UTXOs reside at our
script address using https://blockfrost.io/[Blockfrost] as initialized
in Lucid. After that, we filter out the UTXOs that contain our datum.
Then, we check that the filtered UTXOs exist and are not empty. If they
do, we construct the transaction by specifying which UTXOs to spend and
adding an empty redeemer. Then, we add the public key hash of the
beneficiary to sign the transaction. After that, we attach the validator
script and define the validity interval. To ensure the transaction is
valid, the submission time must fall within the specified validity
interval. We set this interval to 100,000 milliseconds before the
current time and extend it until infinity. Finally, we sign and submit
the transaction. The function returns the transaction hash if a UTXO
with our datum is found, or a message indicating that no UTXO with the
specified datum could be claimed at the vesting address. We can run the
entire code from our `lucid-vesting.ts` file in the VSCode terminal.

[source,shell]
----
/<path>/<to>/<file># deno run -A lucid-vesting.ts
----

After completing the transactions, the transaction hashes output to the
console can be used to check transaction details on the
http://cardanoscan.io/[cardanoscan.io] webpage. In the next
section, which covers minting policies, there will also be an example of
off-chain code demonstrating the use of a parameterized validator,
including how parameters are applied to it.

Validation scripts can also be added to a spending transaction via a
reference UTXO. To construct a transaction that uses a reference script,
the script must first be deployed. Deploying a UTXO with an attached
script may incur an additional cost, but this step is only needed once.
Afterward, the UTXO can be referenced repeatedly until it no longer
exists. If the UTXO is created at a script address where funds are
burned, it becomes unspendable and permanently accessible. Let’s look at
an example where we create such a UTXO and attach the vesting script
from the previous example.

[source,typescript]
----
import {
    Data,
    Lucid,
    Blockfrost,
} from "https://deno.land/x/lucid@0.9.1/mod.ts"
// create a seed.ts file with your seed
import { secretSeed } from "./seed.ts"

// set blockfrost endpoint and select wallet
const lucid = await Lucid.new(
  new Blockfrost(
    "https://cardano-preview.blockfrost.io/api/v0",
    "insert your own api key here"
  ),
  "Preview"
);
lucid.selectWalletFromSeed(secretSeed);

// define burn and vesting script  
const burnScript = {
    type: "PlutusV2",
    script: "581f581d01000022232632498cd5ce24810b6974206275726e732121210…"
};
const burnAddress = lucid.utils.validatorToAddress(burnScript);
const vestingScript = {
    type: "PlutusV2",
    script: "590b30590b2d01000032323233223232332232323232323232332232332…",
};

// functions for signing and submitting a transaction
async function submitCardanoTx(signedTx) {
    const tid = await signedTx.submit();
    console.log("Cardano tx submitted: " + tid);
}
async function signAndSubmitCardanoTx(tx) {
    try {
        const signedTx = await tx.sign().complete();
        await submitCardanoTx(signedTx);
    } catch (err) {
        alert(`Cardano transaction:\ninfo: ${err.info}\nmessage: 
            ${err.message}`);
        throw (err);
    }
}

// function for deploying a refernce script
async function deploy() {
    const tx = await lucid
        .newTx()
        .payToContract(burnAddress, { inline: Data.void(), 
                       scriptRef: vestingScript }, {})
        .complete();
    signAndSubmitCardanoTx(tx);
}

await onDeploy(); 
----

We import the necessary libraries, initialize Lucid with our own
Blockfrost API key on the preview network, and select our wallet. Then,
we define the burn and vesting serialized scripts. Only part of the
serialized script is shown in the code, as including the entire script
would be too lengthy. Next, we define two helper functions to sign and
submit a transaction. The [blue]#deploy# function deploys the vesting script to
the previously computed burn address. In the [blue]#payToContract# function, we
inline a void datum and attach the vesting script. The field specifying
how much ada to send is left empty, allowing Lucid to calculate the
minimum required amount for the UTXO. Then, we sign and submit the
transaction, save this code to the `deploy.ts` file, and run it with Deno.
The [blue]#submitCardanoTx# function will print a transaction hash, which we
need to save for referencing the vesting script later.

[source,shell]
----
/<path>/<to>/file# deno run -A deploy.ts
ecddb39e726a0b4d718de3190e3e7e02ac7901ee4eb1ff8c2e77bc6d38864909
----

After deploying the script, we can modify the previous off-chain code
located in the `lucid-vesting.ts` file. Below is the modified part of the
code:

[source,typescript]
----
async function getReferenceUTxO() {
  const utxos = await lucid.utxosByOutRef([{
      txHash:
        "ecddb39e726a0b4d718de3190e3e7e02ac7901ee4eb1ff8c2e77bc6d38864909",
      outputIndex: 0
  }]);
  return utxos[0];
}
const referenceUTxO = await getReferenceUTxO();


async function claimVestedFunds(): Promise<TxHash> {
  const dtm: Datum = Data.to<VestingDatum>(datum,VestingDatum);
  const utxoAtScript: UTxO[] = await lucid.utxosAt(vestingAddress);
  const ourUTxO: UTxO[] = utxoAtScript.filter((utxo) => utxo.datum == dtm);


  if (ourUTxO && ourUTxO.length > 0) {
    const tx = await lucid
      .newTx()
      .collectFrom(ourUTxO, Data.void())
      .addSignerKey(beneficiaryPKH)
      .readFrom([referenceUTxO])
      .validFrom(Date.now()-100000)
      .complete();


    const signedTx = await tx.sign().complete();
    const txHash = await signedTx.submit();
    return txHash
  }
  else return "No UTxO's found that can be claimed"
}
----

We added the function [blue]#getReferenceUTxO# that returns the UTXO to which we
have attached our vesting script. We hard-coded the transaction hash
that was printed by the `deploy.ts` script and fixed the output index to
0. If you are not sure if the UTXO carrying the reference script was
assigned output index 0 in the transaction where the script was
deployed, you can print the reference UTXO to the console and verify
that a reference script is attached. In the [blue]#claimVestedFunds# function,
we change the line where the vesting script is attached. Instead of
using the [blue]#attachSpendingValidator# function from the previous code, we
now use the [blue]#readFrom# function, which takes the previously defined
reference UTXO as input. This makes the transaction smaller and reduces
the cost in ada. Another option for using reference scripts is through
the Cardano CLI tool, with a
https://github.com/perturbing/vasil-tests/blob/main/referencing-scripts-cip-33.md[tutorial
available here].

=== Minting policies

In Plutus, a minting policy defines the conditions under which native
tokens can be minted. Each UTXO has an address, a value, and potentially
a datum. In previous examples, the value was always ada. To include
native tokens in a UTXO, they must be explicitly created.

Let’s look again at the Haskell definition of the [purple]#Value# type. This type
is defined in the module `Plutus.V1.Ledger.Value`. Even if we are using
Plutus V2 scripts, this module has not changed, and we can still use V1
version for it.

[source,haskell]
----
newtype Value = Value 
    { getValue :: Map.Map CurrencySymbol (Map.Map TokenName Integer) 
    }
    deriving stock (Generic, Typeable, Haskell.Show)
    deriving newtype (PlutusTx.ToData, PlutusTx.FromData, PlutusTx.UnsafeFromData)
    deriving Pretty via (PrettyShow Value)
----

The Value type is a map object that connects a currency symbol to
another map, which uses token names as its keys. Both token names and
currency symbols are wrappers for the type [purple]#BuiltinByteString#,
representing a byte string. These two byte strings define a native token
or coin, while the integer represents the token’s amount. Additionally,
there is another type called [purple]#AssetClass#.

[source,haskell]
----
newtype AssetClass = AssetClass 
    { unAssetClass :: (CurrencySymbol, TokenName) 
    }
    deriving stock (Generic, Data, Typeable)
    deriving newtype
      ( Haskell.Eq
      , Haskell.Ord
      , Haskell.Show
      , Eq
      , Ord
      , PlutusTx.ToData
      , PlutusTx.FromData
      , PlutusTx.UnsafeFromData
      )
    deriving anyclass (NFData, HasBlueprintDefinition)
    deriving (Pretty) via (PrettyShow (CurrencySymbol, TokenName))
----

It combines the currency symbol and token name to define an asset class,
which can represent a native token or ada. The currency symbol and token
name for ada are simply wrappers around an empty byte string. Because
the value type is a map, it can contain different tokens and amounts,
including ada. To construct a value, we can use the function [blue]#assetClass#,
which takes a currency symbol and token name, and returns a variable of
type asset class. We can then use the function [blue]#assetClassValue#, which
takes an asset class and integer, and returns a variable of type value.
With the [blue]#assetClassValueOf# function, we can check how many tokens of a
specific asset class are contained in a value type variable. Below, you
can see the type signatures of these functions.

[source,shell]
----
assetClass :: CurrencySymbol -> TokenName -> AssetClass
assetClassValue :: AssetClass -> Integer -> Value
assetClassValueOf :: Value -> AssetClass -> Integer
----

To construct a value variable and check the amount of tokens in it for a
specific asset class, we can do so as follows from Prelude:

[source,shell]
----
Prelude> import Plutus.V1.Ledger.Value
Prelude Plutus.V1.Ledger.Value> :set -XOverloadedStrings
Prelude Plutus.V1.Ledger.Value> myAssetClass = assetClass "a507ff33"
"MyToken"
Prelude Plutus.V1.Ledger.Value> myTokenValue = assetClassValue
myAssetClass 77
----

To construct an asset class for ada, we can use the [blue]#adaSymbol# and
[blue]#adaToken# variables provided by the `Plutus.V1.Ledger.Value` module.

[source,shell]
----
Prelude Plutus.V1.Ledger.Value> ada = assetClass adaSymbol adaToken
Prelude Plutus.V1.Ledger.Value> adaValue = assetClassValue ada 100000000
----

We can also combine different variables of type value with the semigroup
operator `<>` as the value type has an instance of the semigroup type
class. Using the [blue]#assetClassValueOf# function, we can get the quantity of
a given asset class contained in a value.

[source,shell]
----
Prelude Plutus.V1.Ledger.Value> combined = myTokenValue <> adaValue
Value (Map [(,Map [("",100000000)]),(a507ff33,Map [("MyToken",77)])])
Prelude Plutus.V1.Ledger.Value> assetClassValueOf combined myAssetClass
77
----

We can also extract information from a value type variable as a list of
triples using the [blue]#flattenValue# function, which takes a value type and
returns a list of triples.

[source,shell]
----
Prelude Plutus.V1.Ledger.Value> :t flattenValue
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
Prelude Plutus.V1.Ledger.Value> flattenValue combined
{empty}[(,"",100000000),(a507ff33,"MyToken",77)]
----

So far, we have focused on the spending constructor of the [purple]#ScriptPurpose#
type variable within the [purple]#ScriptContext# data type, which takes a
transaction reference as input. In the [purple]#TxInfo# data type, we can specify
a value type for the [blue]#txInfoMint# variable. Minting policies are triggered
if this field contains a non-zero value. Each currency symbol defined in
this value activates the corresponding minting policy, linking them
through the policy’s hash.

A minting policy requires only two inputs: the redeemer and the script
context. This is because datums exist at existing UTXOs usually residing
at script addresses, and minting scripts do not consume these UTXOs;
they only produce new ones. In a minting transaction, the script purpose
is set to minting.

A single transaction may trigger several different minting policies if
multiple native tokens with distinct currency symbols are minted. Each
policy receives its own redeemer and transaction context as input. All
minting policies within a transaction must pass for the transaction to
succeed; otherwise, it fails.

Now, let’s examine an example of a minting policy where only the owner
of a specific public key, who signs the transaction, is permitted to
mint or burn tokens. This key could represent a project or company
acting like a central bank in traditional finance, responsible for
minting and burning fiat currencies. Our minting policy will be
parameterized, accepting an additional public key hash as a parameter.

[source,haskell]
----
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
 
module Signed where
 
import           Plutus.V2.Ledger.Api      (BuiltinData, CurrencySymbol,
                                            MintingPolicy, PubKeyHash,
                                            ScriptContext 
                                              (scriptContextTxInfo),
                                            mkMintingPolicyScript)
import           Plutus.V2.Ledger.Contexts (txSignedBy)
import qualified PlutusTx
import           PlutusTx.Prelude          (Bool, traceIfFalse, ($), (.))
import           Prelude                   (IO, Show (show))
import           Text.Printf               (printf)
import           Utilities                 (currencySymbol, wrapPolicy,
                                            writeCodeToFile, 
                                            writePolicyToFile)
 
{-# INLINABLE mkSignedPolicy #-}
mkSignedPolicy :: PubKeyHash -> () -> ScriptContext -> Bool
mkSignedPolicy pkh () ctx = traceIfFalse "missing signature" $
                            txSignedBy (scriptContextTxInfo ctx) pkh
 
{-# INLINABLE mkWrappedSignedPolicy #-}
mkWrappedSignedPolicy :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedSignedPolicy pkh = wrapPolicy (mkSignedPolicy $
                                        PlutusTx.unsafeFromBuiltinData pkh)
 
signedCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData ->
                                 	 BuiltinData -> ())
signedCode = $$(PlutusTx.compile [|| mkWrappedSignedPolicy ||])
 
signedPolicy :: PubKeyHash -> MintingPolicy
signedPolicy pkh = mkMintingPolicyScript $ signedCode
                   `PlutusTx.applyCode` PlutusTx.liftCode
                   (PlutusTx.toBuiltinData pkh)
 
------------------------------------------------------------------------------
–------------------------------ HELPER FUNCTIONS -----------------------------
 
saveSignedCode :: IO ()
saveSignedCode = writeCodeToFile "assets/signed.plutus" signedCode
 
saveSignedPolicy :: PubKeyHash -> IO ()
saveSignedPolicy pkh = writePolicyToFile (printf "assets/signed-%s.plutus" $
                                      	show pkh) $ signedPolicy pkh
 
signedCurrencySymbol :: PubKeyHash -> CurrencySymbol
signedCurrencySymbol = currencySymbol . signedPolicy
----

We define our minting policy with the [blue]#mkSignedPolicy# function that takes
a public key hash as an additional parameter to the redeemer and script
context. In this example, our parameter does not keep its type when
compiled. In the compiled validator, we chose to change the additional
parameter’s type to [purple]#BuiltinData#. To accomplish this, we first use the
[blue]#unsafeFromBuiltinData# function that converts the [purple]#BuiltinData# to the
actual type. Then, the [blue]#signedPolicy# function takes a parameter of type
[purple]#PubKeyHash#, and we convert it to [purple]#BuiltinData# using the [blue]#toBuiltinData#
function. The helper function [blue]#saveSignedPolicy# allows us to write the
minting policy to a Plinth script file for a given public key hash. With
the [blue]#signedCurrencySymbol# function, we can also compute the currency
symbol of the minting script given a concrete public key hash. The
[blue]#writeCodeToFile# helper function can take arbitrary compiled code and
serialize it to disk. The [blue]#saveSignedCode# function, which uses this
helper function, writes the Plinth script to the `signed.plutus` file
where the parameter, the public key hash, has not been applied yet. It
saves it to the `signed.plutus` file. The helper functions, imported
from the `Utilities` module, can be found in the _code/Utilities_
folder of the Plutus Pioneer program’s
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[4th
iteration] GitHub repository. Now we showcase how to use off-chain code
with Lucid to apply the public key hash parameter:

[source,typescript]
----
import {
    Lucid,
    Blockfrost,
    Address,
    MintingPolicy,
    PolicyId,
    Unit,
    fromText,
    Data,
    getAddressDetails,
    applyParamsToScript
} from "https://deno.land/x/lucid@0.9.1/mod.ts"
import { blockfrostKey, secretSeed } from "./secret.ts"
 
function readAmount(): bigint {
    const input = prompt("amount: ");
    return input ? BigInt(Number.parseInt(input)) : 1000000n;
}
 
// set blockfrost endpoint
const lucid = await Lucid.new(
    new Blockfrost(
        "https://cardano-preview.blockfrost.io/api/v0",
        blockfrostKey
    ),
    "Preview"
);
 
// load local stored seed as a wallet into lucid
lucid.selectWalletFromSeed(secretSeed);
const addr: Address = await lucid.wallet.address();
console.log("own address: " + addr);
 
const pkh: string = getAddressDetails(addr).paymentCredential?.hash || "";
console.log("own pubkey hash: " + pkh); 
----

First, we import all necessary Lucid classes, functions, types, our
Blockfrost API key, and the secret seed of our wallet. Then, we define
the function that reads an integer amount from the user. If no input is
provided, it defaults the amount to 1,000,000. After that, we initialize
Lucid with Blockfrost using the pre-production network. Next, we select
a wallet, retrieve the address from it, and log it. Finally, we compute
the public key hash and also log it. This script will enable the owner
of the secret seed to mint and burn tokens. Then comes the code for
constructing the minting transaction with the parameterized script:

[source,typescript]
----
const Params = Data.Tuple([Data.String]);
type Params = Data.Static<typeof Params>;
 
const signedPolicy: MintingPolicy = {
    type: "PlutusV2",
    script: applyParamsToScript<Params>(
        "59081a590817010000323232332232323232323232323233223233223232323232…",
        [pkh],
        Params)
};
 
const policyId: PolicyId = lucid.utils.mintingPolicyToId(signedPolicy);
console.log("minting policy: " + policyId);
 
const unit: Unit = policyId + fromText("PPP Signed");
const amount: bigint = readAmount();
 
const tx = await lucid
    .newTx()
    .mintAssets({[unit]: amount}, Data.void())
    .attachMintingPolicy(signedPolicy)
    .addSignerKey(pkh)
    .complete();
 
const signedTx = await tx.sign().complete();
const txHash = await signedTx.submit();
console.log("tid: " + txHash);
----

We first define our [purple]#Params# type, which is a tuple with one list
parameter. You can have more than multiple parameters in this list,
which we will see in the case of NFTs. For this example, our list will
contain only one parameter that is of type string, which represents the
public key hash. To create our minting policy, we take the CBOR HEX from
the `signed.plutus` file and use the function [blue]#applyParamsToScript# to
apply our public key hash to this script. Next, we compute the policy ID
and log it. We compute our asset class that we call Unit. It is computed
from the concatenation of the policy ID and the name we give to our
tokens that we want to mint. In principle, the token name can be an
arbitrary byte string that is limited to 32 bytes. If a human-readable
name is set, wallets also display it in that form. Then, we define a
number of tokens we want to mint and construct a transaction using the
[blue]#mintAssets# function that takes an asset class and the number of tokens
we want to mint. It also takes a redeemer, which, in our case, is of
type void. Then, we attach the minting policy and add the signature of
our address that corresponds to our public key hash. Finally, we sign
and submit the transaction and log the transaction hash. We can now mint
our tokens by running this code, which we saved to the `lucid-signed.ts`
file with the following command:

[source,shell]
----
deno run -A lucid-signed.ts
----

Next, we input the number of tokens to mint. After a short period, the
tokens named PPP Signed will appear in the wallet. If the number is
negative, it signifies burning tokens, and in that case, the wallet must
already contain the tokens to be burned. Although every transaction
submitted in Lucid is signed with the signing key from the wallet, the
signature must be explicitly added to the transaction using the
[blue]#addSignerKey# function for the minting policy to accept it. This was an
example of minting fungible tokens.

Plutus also allows the minting of non-fungible tokens (NFTs), which are
unique tokens that can only be minted once. The key to writing such a
policy script is referencing something unique on the Cardano blockchain,
and for that, we use UTXOs. UTXOs can exist only once, and once consumed
as input to a transaction, they can never exist again. UTXOs are defined
by transaction hashes and output indices, which are unique. The reason
why every transaction has a unique hash was explained in section 
<<Script context explained>>.

When minting an NFT, the idea is to include a specific parameter in the
minting policy – namely, the UTXO transaction hash and ID – and have the
policy check that the transaction performing the minting consumes that
specific UTXO. Let’s look at an example of such a minting script.

[source,haskell]
----
{-# LANGUAGE DataKinds         #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell   #-}
 
module NFT where
 
import qualified Data.ByteString.Char8      as BS8
import           Plutus.V1.Ledger.Value     (flattenValue)
import           Plutus.V2.Ledger.Api       (BuiltinData, CurrencySymbol,
                                             MintingPolicy,
                                             ScriptContext 
                                               (scriptContextTxInfo),
                                             TokenName (unTokenName),
                                             TxId (TxId, getTxId),
                                             TxInInfo (txInInfoOutRef),
                                             TxInfo (txInfoInputs, 
                                                     txInfoMint),
                                             TxOutRef (TxOutRef, txOutRefId,
                                                       txOutRefIdx),
                                             mkMintingPolicyScript)
import qualified PlutusTx
import           PlutusTx.Builtins.Internal (BuiltinByteString
                                         	  (BuiltinByteString))
import           PlutusTx.Prelude           (Bool (False), Eq ((==)), any,
                                             traceIfFalse, ($), (&&))
import           Prelude                    (IO, Show (show), String)
import           Text.Printf                (printf)
import           Utilities                  (bytesToHex, currencySymbol,
                                             wrapPolicy, writeCodeToFile,
                                             writePolicyToFile)
 
{-# INLINABLE mkNFTPolicy #-}
mkNFTPolicy :: TxOutRef -> TokenName -> () -> ScriptContext -> Bool
mkNFTPolicy oref tn () ctx = traceIfFalse "UTxO not consumed"   hasUTxO &&
                             traceIfFalse "wrong amount minted" 
                                          checkMintedAmount
  where
    info :: TxInfo
    info = scriptContextTxInfo ctx
 
    hasUTxO :: Bool
    hasUTxO = any (\i -> txInInfoOutRef i == oref) $ txInfoInputs info
 
    checkMintedAmount :: Bool
    checkMintedAmount = case flattenValue (txInfoMint info) of
        [(_, tn'', amt)] -> tn'' == tn && amt == 1
        _                -> False
----

Our script will be parameterized by two inputs: the transaction output
reference ([purple]#TxOutRef#) of the UTXO we are spending and the token name. The
condition we check is that the minting transaction consumes the TxOutRef
passed to the script. The [blue]#any# function is used, which takes a
Boolean-returning function and applies it to a list, returning true if
at least one element satisfies the condition. We also ensure that only
one token with the specified name is minted by using the [blue]#flattenValue#
function, which converts a value type into a list of triples. These
checks ensure only one coin is minted with the currency symbol tied to a
specific parameterized script. Finally, let us look at how to convert
the validator function to an untyped version and compile it.

[source,haskell]
----
{-# INLINABLE mkWrappedNFTPolicy #-}
mkWrappedNFTPolicy :: BuiltinData -> BuiltinData -> BuiltinData ->
                      BuiltinData -> BuiltinData -> ()
mkWrappedNFTPolicy tid ix tn' = wrapPolicy $ mkNFTPolicy oref tn
  where
    oref :: TxOutRef
    oref = TxOutRef
        (TxId $ PlutusTx.unsafeFromBuiltinData tid)
        (PlutusTx.unsafeFromBuiltinData ix)
 
    tn :: TokenName
    tn = PlutusTx.unsafeFromBuiltinData tn'
 
nftCode :: PlutusTx.CompiledCode (BuiltinData -> BuiltinData -> BuiltinData ->
                                  BuiltinData -> BuiltinData -> ())
nftCode = $$(PlutusTx.compile [|| mkWrappedNFTPolicy ||])
 
nftPolicy :: TxOutRef -> TokenName -> MintingPolicy
nftPolicy oref tn = mkMintingPolicyScript $ nftCode
        `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $
                                                getTxId $ txOutRefId oref)
        `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData $
                                      	      txOutRefIdx oref)
        `PlutusTx.applyCode` PlutusTx.liftCode (PlutusTx.toBuiltinData tn)
----

There are now three input parameters for our script: the transaction
hash (also called transaction ID), the transaction index, and the token
name. These need to be converted from [purple]#BuiltinData# to their custom data
types. After converting, we combine the transaction ID and index into a
transaction output reference, which is then passed as an input to the
[blue]#mkNFTPolicy# validator function. Next, we compile the wrapped validator
function and define the [blue]#nftPolicy# function, which creates a minting
policy using two specific input parameters. Finally, we explore a helper
function that serializes the compiled minting policy to disk.

[source,haskell]
----
------------------------------------------------------------------------------
-------------------------------- HELPER FUNCTIONS ----------------------------
 
saveNFTCode :: IO ()
saveNFTCode = writeCodeToFile "assets/nft.plutus" nftCode
 
saveNFTPolicy :: TxOutRef -> TokenName -> IO ()
saveNFTPolicy oref tn = writePolicyToFile
    (printf "assets/nft-%s#%d-%s.plutus"
        (show $ txOutRefId oref)
        (txOutRefIdx oref) $
        tn') $
    nftPolicy oref tn
  where
    tn' :: String
    tn' = case unTokenName tn of
        (BuiltinByteString bs) -> BS8.unpack $ bytesToHex bs
 
nftCurrencySymbol :: TxOutRef -> TokenName -> CurrencySymbol
nftCurrencySymbol oref tn = currencySymbol $ nftPolicy oref tn
----

The [blue]#saveNFTCode# function writes the unparameterized Plinth script to
file `nft.plutus`. This is useful because we get an unparameterized
script that can be used in a DApp by multiple users. The [blue]#saveNFTPolicy#
function takes a transaction output reference and a token name and
writes the parameterized minting policy to a Plutus script and saves it
to disk. This is useful if we want to create only one NFT and already
know the UTXO that we will spend. The [blue]#nftCurrencySymbol# function
computes the currency symbol of the script that is parameterized with
two concrete parameters. Let’s look at the off-chain code:

[source,typescript]
----
import {
    Lucid,
    Blockfrost,
    Address,
    MintingPolicy,
    PolicyId,
    Unit,
    fromText,
    Data,
    applyParamsToScript
} from "https://deno.land/x/lucid@0.9.1/mod.ts"
import { blockfrostKey, secretSeed } from "./secret.ts"
 
// set blockfrost endpoint
const lucid = await Lucid.new(
    new Blockfrost(
        "https://cardano-preview.blockfrost.io/api/v0",
        blockfrostKey
    ),
    "Preview"
);
 
// load local stored seed as a wallet into lucid
lucid.selectWalletFromSeed(secretSeed);
const addr: Address = await lucid.wallet.address();
console.log("own address: " + addr);
 
const utxos = await lucid.utxosAt(addr);
const utxo = utxos[0];
console.log("utxo: " + utxo.txHash + "#" + utxo.outputIndex);
----

We import the necessary Lucid functions, classes and types, our API key
and the secret seed. Then, we initialize Lucid with our API key and
connect to the pre-production network. Next, we compute and log our
address, along with information about the first UTXO we get when
querying it at our address. Next, comes the code that handles the
minting:

[source,typescript]
----
const tn = fromText("PPP NFT");
const Params = Data.Tuple([Data.String, Data.BigInt, Data.String]);
type Params = Data.Static<typeof Params>;
const nftPolicy: MintingPolicy = {
    type: "PlutusV2",
    script: applyParamsToScript<Params>(
        "590906590903010000323322332232323232323232323232323232323232323232…",
        [utxo.txHash, BigInt(utxo.outputIndex), tn],
        Params)
};
 
const policyId: PolicyId = lucid.utils.mintingPolicyToId(nftPolicy);
console.log("minting policy: " + policyId);
const unit: Unit = policyId + tn; 


const tx = await lucid
    .newTx()
    .mintAssets({[unit]: 1n}, Data.void())
    .attachMintingPolicy(nftPolicy)
    .collectFrom([utxo])
    .complete();
 
const signedTx = await tx.sign().complete();
const txHash = await signedTx.submit();
console.log("tid: " + txHash);
----

First, we define our token name, followed by the [purple]#Params# variable, which
holds the data types for our parameters. Next, we define the actual
minting policy. We use the CBOR hex from the `nft.plutus` script and
apply our three parameters to it. Then, we define the policy ID and log
it. Additionally, we define the asset class, which we call [purple]#Unit#.

After that, we construct the transaction, specifying the asset we want
to mint – in this case, just one coin. We attach the minting policy,
then use the [blue]#collectFrom# function to specify which UTXO we want to spend
for the transaction fees. Finally, we sign and submit the transaction,
logging the transaction hash.

If we run this code multiple times, we would generate tokens with the
same name but different currency symbols. This difference in currency
symbols ensures that each token is truly an NFT, as the asset class is
defined by both the token name and its unique currency symbol.

For more information about native tokens, see:

* https://docs.cardano.org/developer-resources/native-tokens/[Native
tokens] overview on Cardano Docs
* https://developers.cardano.org/docs/native-tokens/[Discover native
tokens] section on the Developer Portal
* https://cardano-ledger.readthedocs.io/en/latest/explanations/index.html[Ledger
explanations] page, which also covers native tokens.

=== Testing Plinth scripts

This section outlines the different methods of testing smart contracts.
We introduce the
https://github.com/mlabs-haskell/plutus-simple-model[Plutus simple
model] (PSM) library developed by https://mlabs.city/[MLabs] and the
https://hackage.haskell.org/package/QuickCheck[QuickCheck] 
Haskell library used for property-based testing. We also
showcase how to write unit and property tests using these libraries. In
the future, the PSM library will be replaced by the
https://github.com/IntersectMBO/cardano-node-emulator[Cardano node
emulator] library that can be used to property test PlutusV3 smart contracts.

First, let’s see how to use a state monad to represent a blockchain and
keep track of transactions. The PSM library uses a state monad. Below is
a simple example:

[source,haskell]
----
module State where

import Control.Monad.State (State, get, put, runState)
 
-- Mock UTxO type
data UTxO = UTxO { owner :: String , value :: Integer }
    deriving (Show, Eq)
 
-- Mock blockchain type
newtype Mock = Mock { utxos :: [UTxO] }
    deriving (Show, Eq)
 
-- Initial blockchain state
initialMockS :: Mock
initialMockS = Mock [ UTxO "Alice" 1000 ]
----

The [purple]#UTxO# data type contains the owner of the UTXO and the value sitting
at the UTXO, which, in our case, is just an integer number. We create
the [purple]#Mock# blockchain type – a wrapper around a list of UTXOs. Thus, our
mock chain consists solely of a list of UTXOs. Finally, we create an
initial state of our blockchain, indicating that Alice has a 1,000 ada.

Next, using the state monad, we create a function that enables the
transfer of value from one user to another, which we will use in several
transactions.

[source,haskell]
----
-- Definition of the State type 
-- newtype State s a = State { runState :: s -> (a, s) }

sendValue :: String -> Integer -> String -> State Mock Bool
sendValue from amount to = do
    mockS <- get
    let senderUtxos = filter ((== from) . owner) (utxos mockS)
        blockchainWithoutSenderUtxos = filter ((/= from) . owner) 
                                              (utxos mockS)
        totalSenderFunds = sum (map value senderUtxos)
        receiverUtxo = UTxO to amount
        senderChange = UTxO from (totalSenderFunds - amount)
    if totalSenderFunds >= amount
        then do
            put $ Mock $ [receiverUtxo] ++ [senderChange] ++
                     	blockchainWithoutSenderUtxos
            return True
        else return False
 
multipleTx :: (Bool, Mock)
multipleTx = runState (do
    isOk  <- sendValue "Alice" 100 "Bob"
    isOk2 <- sendValue "Alice" 300 "Bob"
    isOk3 <- sendValue "Bob"   200 "Rick"
    return (isOk && isOk2 && isOk3))
    initialMockS
 
type Run a = State Mock a
----

The [blue]#sendValue# function takes the following parameters in the specified
order:

* The name of the user sending the funds
* The amount of value we intend to send
* The name of the user receiving the funds.

It returns a state monad parameterized by the potentially new state of
the mock blockchain and a boolean that indicates whether the transaction
that tried to update the mock blockchain was successful or not. If the
transaction fails, the state will remain unchanged. In the body of the
function, we first compute all the sender’s UTXOs from the blockchain,
and then all the UTXOs on the blockchain excluding the sender’s ones.
Then, we compute the total value that the sender owns, the UTXO that the
receiver will get, and the change amount that will go back to the
sender. Next, we check if the sender has enough funds to create the
transaction and if he does, we update the state of the blockchain with
two newly created UTXOs. If he does not, we return the original state of
the blockchain. In the [blue]#multipleTx# function, we create three transactions
and return final parameters of the state monad. We can now look in the
REPL at the results that the [blue]#multipleTx# function returns:

[source,shell]
----
Prelude State> fst multipleTx
True
Prelude State> snd multipleTx
Mock \{utxos = [UTxO \{owner = "Rick", value = 200},UTxO \{owner =
"Bob", value = 200},UTxO \{owner = "Alice", value = 600}]}
----

The [purple]#Mock# type is also used in the PSM library. The source code of this
library shows how [purple]#Mock# and [purple]#Run# types are defined:

[source,haskell]
----
data Mock = Mock
  { mockUsers :: !(Map PubKeyHash User)
  , mockAddresses :: !(Map Address (Set TxOutRef))
  , mockUtxos :: !(Map TxOutRef TxOut)
  -- ^ Since 0.4, reference script UTxOs are also included.
  , mockDatums :: !(Map DatumHash Datum)
  , mockStake :: !Stake
  , mockTxs :: !(Log TxStat)
  , mockConfig :: !MockConfig
  , mockCurrentSlot :: !Slot
  , mockUserStep :: !Integer
  , mockFails :: !(Log FailReason)
  , mockInfo :: !(Log String)
  , mustFailLog :: !(Log MustFailLog)
  , mockNames :: !MockNames
  -- ^ human readable names. Idea is to substitute for them
  -- in pretty printers for error logs, user names, script names.
  }

-- | State monad wrapper to run blockchain.
newtype Run a = Run (State Mock a)
  deriving newtype (Functor, Applicative, Monad, MonadState Mock)
----

The source code for the [purple]#Mock# data type can be found in the following
https://github.com/mlabs-haskell/plutus-simple-model/blob/main/psm/src/Plutus/Model/Mock.hs[GitHub file]. 
Below is an example that uses the PSM library. We will test two
mock transactions, where one should succeed and one should fail due to
insufficient funds.

[source,haskell]
----
{-# LANGUAGE NumericUnderscores #-}
 
module Main where
 
import           Prelude
import           Test.Tasty           (defaultMain, testGroup)
import           Control.Monad        (replicateM)
import           Plutus.Model         (Ada (Lovelace), Run, ada, adaValue,
                                       defaultBabbage, mustFail, newUser,
                                       noErrors, sendValue, testNoErrors,
                                       valueAt)
import           Plutus.V1.Ledger.Api (PubKeyHash)
 
main :: IO ()
main = defaultMain $ do
    testGroup
      "Test simple user transactions"
      [ good "Simple spend" simpleSpend
      , bad  "Not enough funds" notEnoughFunds
      ]
      where
        bad msg = good msg . mustFail
        good = testNoErrors (adaValue 10_000_000) defaultBabbage
----

We import the `Test.Tasty` and the `Plutus.Model` libraries, and then we
define our tests in the [blue]#main# function. At the beginning of the [blue]#main#
function, which serves as the entry point of our code, there is some
standard code that repeats in every test. We use the [blue]#defaultMain#
function, part of the `Tasty` module, to transform a tree of tests into
the IO action that the main function needs to run. The [blue]#testGroup#
function, also provided by the `Tasty` module, allows us to give a name to
a list of tests. This is handy when you have multiple groups of tests,
and you want to classify them. Finally, we have the list of tests, each
with its own description and the actual test. In the _Simple spend_
test, user one sends a transaction to user two, and everything should
proceed as expected. In the _Not enough funds_ test, user one sends some
funds to user two, but user one has not enough funds to cover the
transaction, so this test should fail. The code shows that we run the
tests using the [blue]#good# and [blue]#bad# functions. The [blue]#good# 
function is a partially applied [blue]#testNoErrors# function.

[source,shell]
----
testNoErrors :: Value -> MockConfig -> String -> Run a -> TestTree
----

The first parameter is the value we provide to the admin user. As in the
previous example, we will start with a single UTXO. We provide
10.000.000 lovelace to the [blue]#adaValue# function that takes an integer and
returns a variable of the Plinth type [purple]#Value#.

[source,shell]
----
adaValue :: Integer -> Value
----

We also provide the default Babbage mock configuration, which configures
our mock blockchain. The description of the test and the run action,
which the [blue]#testNoErrors# function also accepts, are provided in the list
of tests. In the end, it produces a variable of type [purple]#TestTree#. In the
case of the [blue]#bad# function, we use the [blue]#mustFail# function, which logs an
error if everything goes well and succeeds if an error occurs. In the
first scenario, we expect the test to succeed, while in the second
scenario, we anticipate a failure. Now, let’s examine the actual code
for the tests:

[source,haskell]
----
-- Set many users at once
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 3 $ newUser $ ada (Lovelace 1000)
 
-- Function to test that a simple transaction works
simpleSpend :: Run Bool
simpleSpend = do
	  -- Create 3 users and assign each 1000 lovelaces
    users <- setupUsers  
    -- Give names to individual users
    let [u1, u2, u3] = users  
    -- Send 100 lovelaces from user 1 to user 2
    sendValue u1 (adaValue 100) u2  
	  -- Send 100 lovelaces from user 2 to user 3
    sendValue u2 (adaValue 100) u3 
	  -- Check that all TXs were accepted without errors
    isOk <- noErrors  
	  -- Read user values
    vals <- mapM valueAt users  
	  -- Check isOk and that all users have correct values
    return $ isOk &&  
           (vals == fmap adaValue [900, 1000, 1100])
 
-- Function to test that a transaction fails if there are not enough funds
notEnoughFunds :: Run Bool
notEnoughFunds = do
  -- Create 3 users and assign each 1000 lovelaces
  users <- setupUsers  
  -- Give names to individual users
  let [u1, u2, _u3] = users  
  -- Send 10.000 lovelaces from user 1 to user 2
  sendValue u1 (adaValue 10000) u2
  -- Check that all TXs were accepted without errors (should fail)
  noErrors  
----

First, we create the helper function [blue]#setupUsers#, which creates three new
users. The [blue]#newUser# function creates a new user and transfers an input
amount of coins from the admin user to the new user. We transfer 1,000
lovelace and replicate this function three times. The function returns
the run monad, parameterized by a list of three public key hashes.

The [blue]#simpleSpend# function is also a run monad parameterized by a Boolean,
which indicates whether the given transaction has passed or failed. All
actions within this monad influence the blockchain state if they are
successful. In the body of this state monad, we first create a list of
public key hashes representing the three users and assign them names.

The actual transaction is constructed using the [blue]#sendValue# function,
which takes the public key hashes of both the sender and the recipient,
along with the lovelace amount to transfer. The function returns the run
monad parameterized by the unit type. For the [blue]#sendValue# function, the
success of a transaction is tracked as a part of the blockchain state.

We then use the [blue]#noErrors# action to verify that all transactions were
successful. Additionally, we check whether the final balances match our
expectations. We retrieve the value of a specific user using the [blue]#valueAt#
function, mapping over the list of public key hashes for our three
users. Finally, we compare the list of actual balances against the
expected ones, along with verifying that all transactions succeeded.

In the [blue]#notEnoughFunds# function, we again create three users and attempt
to send 10.000 lovelace from user u1 to user u2. Since this exceeds the
balance of u1, this transaction should fail. We return the result of the
[blue]#noErrors# action. We can name our test in the cabal file PMS and run it
using the following cabal command to obtain the test results:

[source,shell]
----
/<path>/<to>/<cabal_file># cabal test PSM
...
Running 1 test suites...
Test suite PSM: RUNNING...
Test simple user transactions
  Simple spend:      OK (1.21s)
  Not enough funds:  OK

All 2 tests passed (1.28s)
----

Let’s now run a unit test for a smart contract that checks:

* that the redeemer, which is an integer number, is smaller or equal to
zero
* that the deadline contained in the datum, which is a custom data type,
has passed.

Below, you can see the smart contract code, where we name our module
`NegativeRTime`:

[source,haskell]
----
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}
 
module NegativeRTimed where
 
import           Plutus.V1.Ledger.Interval (contains)
import           Plutus.V2.Ledger.Api      (POSIXTime,
                                            ScriptContext 
                                            (scriptContextTxInfo),
                                            TxInfo (txInfoValidRange), from)
import qualified Plutus.V2.Ledger.Api      as PlutusV2
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer)
import           PlutusTx.Prelude          (Bool, Ord ((<=)), traceIfFalse, 
                                            ($), (&&))
import           Utilities                 (wrapValidator)
 
------------------------------------------------------------------------------
---------------------------- ON-CHAIN / VALIDATOR ---------------------------
 
newtype CustomDatum = MkCustomDatum { deadline :: POSIXTime }
unstableMakeIsData ''CustomDatum
 
{-# INLINABLE mkValidator #-}
mkValidator :: CustomDatum -> Integer -> ScriptContext -> Bool
mkValidator (MkCustomDatum d) r ctx = traceIfFalse 
                                      "expected a negative redeemer"
                                  	  $ r <= 0 &&
                                      traceIfFalse "deadline not reached"
                                  	  deadlineReached
    where 
        info :: TxInfo
        info = scriptContextTxInfo ctx
 
        deadlineReached :: Bool
        deadlineReached = contains (from d) $ txInfoValidRange info


{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator
 
validator :: PlutusV2.Validator
validator = PlutusV2.mkValidatorScript $$(PlutusTx.compile
                                      	[|| mkWrappedValidator ||])
----

Let’s now look at the unit test for this contract that uses the PSM
library. We can name the file for writing unit tests `UTNegativeRTimed.hs`.

[source,haskell]
----
{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
 
module Main where
 
import           Control.Monad        (mapM, replicateM, unless)
import qualified NegativeRTimed       as OnChain
import           Plutus.Model         (Ada (Lovelace), DatumMode (HashDatum),
                                       Run, Tx, TypedValidator 
                                       (TypedValidator),
                                       UserSpend, ada, adaValue, 
                                       currentTimeRad,
                                       defaultBabbage, logError, mustFail,
                                       newUser, payToKey, payToScript, spend,
                                       spendScript, submitTx, testNoErrors,
                                       toV2, userSpend, utxoAt, validateIn,
                                       valueAt, waitUntil)
import           Plutus.V2.Ledger.Api (POSIXTime, PubKeyHash,
                                       TxOut (txOutValue), TxOutRef, Value)
import           PlutusTx.Builtins    (Integer, mkI)
import           PlutusTx.Prelude     (Eq ((==)), ($), (&&), (.))
import           Prelude              (IO, mconcat)
import           Test.Tasty           (defaultMain, testGroup)
 
------------------------------------------------------------------------------
-------------------------------- TESTING MAIN --------------------------------
 
main :: IO ()
main = defaultMain $ do
    testGroup
      "Testing validator with some sensible values"
      [ good "User 1 locks and user 2 takes with R = -42 after 
              deadline succeeds"
         	$ testScript 50 (-42)
      , good "User 1 locks and user 2 takes with R = 0   after 
              deadline succeeds"
         	$ testScript 50 0
      , bad  "User 1 locks and user 2 takes with R = 42  after 
              deadline fails"
         	$ testScript 50 42
      , bad  "User 1 locks and user 2 takes with R = -42 before 
              deadline fails"
         	$ testScript 5000 (-42)
      , bad  "User 1 locks and user 2 takes with R = 0   before 
              deadline fails"
         	$ testScript 5000 0
      , bad  "User 1 locks and user 2 takes with R = 42  before 
              deadline fails"
         	$ testScript 5000 42
      ]
    where
      bad msg = good msg . mustFail
      good = testNoErrors (adaValue 10_000_000) defaultBabbage
----

Our [blue]#main# function contains a list of tests with their descriptions. The
first two tests should pass, and the rest of the tests should fail. We
use the same test in all six cases, but the parameters we pass to the
test differ for each case. The first parameter we pass is the POSIX time
for the deadline, and the second is the redeemer. A deadline of 50
should work, since we hard-code the waiting time before submitting the
consuming transaction to 1,000.

Let’s now explore helper functions:

[source,haskell]
----
------------------------------------------------------------------------------
------------------------------ HELPER FUNCTIONS ------------------------------
 
waitBeforeConsumingTx :: POSIXTime
waitBeforeConsumingTx = 1000
 
-- Set many users at once
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 2 $ newUser $ ada (Lovelace 1000)
 
-- Validator's script
valScript :: TypedValidator datum redeemer
valScript = TypedValidator $ toV2 OnChain.validator
  
-- Create transaction that spends "usp" to lock "val" in "valScript"
lockingTx :: POSIXTime -> UserSpend -> Value -> Tx
lockingTx dl usp val =
  mconcat
    [ userSpend usp
    , payToScript valScript (HashDatum (OnChain.MkCustomDatum dl)) val
    ]
  
-- Create transaction that spends "ref" to unlock "val" from the "valScript" validator
consumingTx :: POSIXTime -> Integer -> PubKeyHash -> TxOutRef -> Value -> Tx
consumingTx dl redeemer usr ref val =
  mconcat
    [ spendScript valScript ref (mkI redeemer) (OnChain.MkCustomDatum dl)
    , payToKey usr val
    ]
----

First, we define the time to wait between the locking and consuming
transactions. Then, we set up two users, giving each 1,000 lovelace.
Next, we define the validator script using the actual validator from the
`NegativeRTimed` module, which we imported and named [purple]#OnChain#. Finally,
we create two functions to produce helper transactions – one to create
the UTXO at the script address and another to consume it.

Transaction types implement the Monoid type class, allowing them to be
combined using the [blue]#mconcat# operator. For the locking transaction, we
first use the [blue]#userSpend# function to specify which user UTXOs to spend.
In the second transaction, we use the [blue]#payToScript# function to send funds
to a specified script, providing the script address, datum or datum
hash, and the amount. The [blue]#lockingTx# function produces the spending
transaction. We follow a similar approach to build the consuming
transaction. Let’s now check from the REPL which types the [blue]#payToScript#
function accepts:

[source,shell]
----
Prelude> import Plutus.Model
Prelude Plutus.Model> :i payToScript 
payToScript :: (HasDatum script, HasAddress script) =>
  script
  -> DatumMode (DatumType script)
  -> Plutus.V1.Ledger.Value.Value
  -> Tx

Prelude Plutus.Model> :i DatumMode 
data DatumMode a = InlineDatum a | HashDatum a
----

The [purple]#DatumMode# type can be either an inline datum or a datum hash. The
[blue]#consumingTx# function defines the consuming transaction. Because want to
consume a UTXO sitting at a script address, we need to provide the
datum, the redeemer, and a reference to the UTXO. These parameters,
along with the script, serve as inputs to the [blue]#spendScript# function,
which defines the conditions under which a script UTXO can be spent. We
then combine the transaction produced by the [blue]#spendScript# function with
the transaction created by the [blue]#payToKey# function, which specifies the
public key hash to which the funds will be sent. We now look at the
[blue]#spendScript# function from the REPL:

[source,shell]
----
Prelude Plutus.Model> :i spendScript
spendScript ::
  IsValidator script =>
  script
  -> Plutus.V1.Ledger.Tx.TxOutRef
  -> RedeemerType script
  -> DatumType script
  -> Tx 
----

It takes a script, a transaction output reference, a redeemer and a
datum. Let’s now look at the [blue]#testScript# function that defines our actual
test:

[source,haskell]
----
------------------------------------------------------------------------------
------------------------------ TESTING REDEEMERS -----------------------------
 
-- Function to test if both creating and consuming script UTxOs works properly
testScript :: POSIXTime -> Integer -> Run ()
testScript d r = do
  -- SETUP USERS
  [u1, u2] <- setupUsers
  -- USER 1 LOCKS 100 lovelace ("val") IN VALIDATOR
  -- Define value to be transfered
  let val = adaValue 100  
  -- Get user's UTXO that we should spend
  sp <- spend u1 val      
  -- User 1 submits "lockingTx" transaction
  submitTx u1 $ lockingTx d sp val  
  -- WAIT FOR A BIT
  waitUntil waitBeforeConsumingTx
  -- USER 2 TAKES "val" FROM VALIDATOR
  -- Query blockchain to get all UTxOs at script
  utxos <- utxoAt valScript  
  -- We know there is only one UTXO (the one we created before)
  let [(ref, out)] = utxos  
  -- Create time interval with equal radius around current time
  ct <- currentTimeRad 100  
  -- Build Tx
  tx <- validateIn ct $ consumingTx d r u2 ref (txOutValue out)  
  -- User 2 submits "consumingTx" transaction
  submitTx u2 tx  
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  -- Get final balances of both users
  [v1, v2] <- mapM valueAt [u1, u2]  
  -- Check if final balances match expected balances
  unless (v1 == adaValue 900 && v2 == adaValue 1100) $  
    logError "Final balances are incorrect"
----

It takes the datum that contains the POSIX time and the redeemer. Then,
it returns the updated blockchain in the run monad parameterized by the
unit type. The first thing we do is set up two users. Then, we create a
value of 100 lovelace. After that, we use the spend function that takes
a public key hash and a value, and returns all the UTXOs owned by that
user to pay for the value. The [blue]#spend# function has the following type
signature:

[source,shell]
----
Prelude Plutus.Model> :i spend
spend :: PubKeyHash -> Value -> Run UserSpend
----

We can now submit the locking transaction by passing the [blue]#lockingTx#
function the spending value, which includes the UTXOs, along with the
value we want to send and the attached datum. We then submit this
transaction using the [blue]#submitTx# function, which also requires the public
key hash of the user submitting the transaction.

[source,shell]
----
Prelude Plutus.Model> :i submitTx
submitTx :: PubKeyHash -> Tx -> Run ()
----

Next, we indicate that user two submits the transaction. At the end of
the test, we check if users’ balances are as expected, if not, we log an
error.

[source,shell]
----
Prelude Plutus.Model> :i logError
logError :: String -> Run ()
----

The [blue]#logError# function takes a string and returns a run monad
parameterized by unit. We can name our test case in the cabal file
_UTNegativeRTimed_:

[source,shell]
----
test-suite UTNegativeRTimed
    import:             common-all
    type:               exitcode-stdio-1.0
    main-is:            UTNegativeRTimed.hs
    hs-source-dirs:     tests
    build-depends:      testing
----

We can then run the tests with the following cabal command:

[source,shell]
----
/<path>/<to>/<cabal_file># cabal test UTNegativeRTimed
...
Running 1 test suites...
Test suite UTNegativeRTimed: RUNNING...
Testing validator with some sensible values
  User 1 locks and user 2 takes with R = -42 after deadline succeeds: OK (0.54s)
  User 1 locks and user 2 takes with R = 0   after deadline succeeds: OK
  User 1 locks and user 2 takes with R = 42  after deadline fails   : OK
  User 1 locks and user 2 takes with R = -42 before deadline fails  : OK
  User 1 locks and user 2 takes with R = 0   before deadline fails  : OK
  User 1 locks and user 2 takes with R = 42  before deadline fails  : OK

All 6 tests passed (0.57s)
----

If we choose our tests carefully in unit testing, we can pinpoint logic
errors and issues in our smart contracts. However, with unit testing, we
cannot say much about the properties of our smart contracts, other than
that they pass the tests in these specific scenarios. We can graphically
display the unit tests we have run above with the illustration below:

image::sc_test_cases.png[width=400,height=320,title="Unit test cases"]

The green dots represent the tests that should pass, and the red dots
represent the tests that should fail. The surface of the diagram
represents all possible combinations for the two values that we input to
our test function. Our goal is to cover as much of this surface as
possible, which is challenging with unit testing. With property testing,
we can specify a property and then let the QuickCheck testing library
generate numerous random tests. This increases our confidence in the
smart contract behavior. This library is a Haskell library, and you can
use it to test any code, not just smart contracts. Let’s now look at our
property tests. We name the file that contains them
`PTNegativeRTimed.hs`:

[source,haskell]
----
{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# OPTIONS_GHC -Wno-orphans #-}

module Main where

import qualified NegativeRTimed       as OnChain
import           Control.Monad           (mapM, replicateM)
import           Plutus.Model            (Ada (Lovelace), DatumMode (HashDatum),
                                          Run, Tx,
                                          TypedValidator (TypedValidator),
                                          UserSpend, ada, adaValue,
                                          defaultBabbage, initMock, mustFail,
                                          newUser, payToKey, payToScript,
                                          runMock, spend, spendScript, 
                                          submitTx, toV2, userSpend, utxoAt, 
                                          valueAt, waitUntil, currentTimeRad, 
                                          validateIn)
import           Plutus.V2.Ledger.Api    (PubKeyHash, TxOut (txOutValue),
                                          TxOutRef, Value, POSIXTime 
                                          (POSIXTime, getPOSIXTime))
import           PlutusTx.Builtins       (Integer, mkI) 
import           PlutusTx.Prelude        (Bool (..), Eq ((==)),
                                          return, ($), (&&), (.))
import           Prelude                 (IO, Ord ((<), (>)), mconcat)
import           Test.QuickCheck         (Property, Testable (property),
                                          collect, (==>), Arbitrary
                                          (arbitrary), choose)
import           Test.QuickCheck.Monadic (assert, monadic, run)
import           Test.Tasty              (defaultMain, testGroup)
import           Test.Tasty.QuickCheck   as QC (testProperty)

------------------------------------------------------------------------------
--------------------------------- TESTING MAIN -------------------------------

-- | Test the validator script
main :: IO ()
main = defaultMain $ do
    testGroup
      "Testing script properties"
      [ testProperty "Anything before the deadline always fails" 
                     prop_Before_Fails
      , testProperty "Positive redeemer after deadline always fails" 
                     prop_PositiveAfter_Fails
      , testProperty "Negative redeemer after deadline always succeeds" 
                     prop_NegativeAfter_Succeeds
      ]
----

We use the [blue]#defaultMain# and [blue]#testGroup# functions from the  
`Tasty` module. To generate a test tree, we now use the [blue]#testProperty# 
function, which is also contained in the tasty package.

[source,shell]
----
Prelude> import Test.Tasty.QuickCheck
Prelude Test.Tasty.QuickCheck> :i testProperty
testProperty :: Testable a => TestName -> a -> TestTree
----

The final testing functions we provide to the [blue]#testProperty# function also
accept parameters, but we do not provide any, since the QuickCheck
testing library does this for us. The first property we test tells us
that any transaction submitted before the deadline always fails, no
matter which redeemer you choose. Next, we test the property that a
transaction with a positive redeemer submitted after the deadline always
fails. Additionally, we check that a transaction with a negative
redeemer submitted after the deadline always succeeds.

Let’s now look at the helper functions we will use in the testing
function:

[source,haskell]
----
------------------------------------------------------------------------------
-------------------------- HELPER FUNCTIONS/INSTANCES ------------------------

-- | Make Run an instance of Testable so we can use it with QuickCheck
instance Testable a => Testable (Run a) where
  property rp = let (a,_) = runMock rp $ initMock defaultBabbage 
                                         (adaValue 10_000_000) 
                in property a

-- Make POSIXTime an instance of Arbitrary so QuickCheck can generate random 
-- values to test
instance Arbitrary POSIXTime where
  arbitrary = do
    n <- choose (0, 2000)
    return (POSIXTime n)

-- Time to wait before consumming UTxO from script
waitBeforeConsumingTx :: POSIXTime
waitBeforeConsumingTx = 1000

-- Set many users at once
setupUsers :: Run [PubKeyHash]
setupUsers = replicateM 2 $ newUser $ ada (Lovelace 1000)

-- Validator's script
valScript :: TypedValidator datum redeemer
valScript = TypedValidator $ toV2 OnChain.validator

-- Create transaction that spends "usp" to lock "val" in "giftScript"
lockingTx :: POSIXTime -> UserSpend -> Value -> Tx
lockingTx dl usp val =
  mconcat
    [ userSpend usp
    , payToScript valScript (HashDatum (OnChain.MkCustomDatum dl)) val
    ]

-- Create transaction that spends "giftRef" to unlock "giftVal" from the 
-- "valScript" validator
consumingTx :: POSIXTime -> Integer -> PubKeyHash -> TxOutRef -> Value -> Tx
consumingTx dl redeemer usr ref val =
  mconcat
    [ spendScript valScript ref (mkI redeemer) (OnChain.MkCustomDatum dl)
    , payToKey usr val
    ]
----

We use the same helper functions from the previous example that
demonstrated how to unit test a smart contract. In addition to these, we
add two instances. First, we need a testable instance for the run type,
as the PSM library uses this run type to wrap the state monad. Once
created, this instance can be reused for other tests. Specifically, we
initialize the blockchain with the Babbage default configuration and
allocate 10,000,000 lovelace to the admin user. Then, we create an
arbitrary instance. QuickCheck has many instances of this arbitrary type
class for common types, but we have to create one for the [purple]#POSIXTime#
type. Because this type is simply a wrapper around an integer, we can
randomly pick a number between 0 and 2,000 with the choose function and
then return it as [purple]#POSIXTime#.

Let’s now look at how we define our property functions for testing:

[source,haskell]
----
------------------------------------------------------------------------------
------------------------------ TESTING PROPERTIES ----------------------------

-- All redeemers fail before deadline 
prop_Before_Fails :: POSIXTime -> Integer -> Property
prop_Before_Fails d r = (d > 1001) ==> runChecks False d r

-- Positive redeemer always fail after deadline
prop_PositiveAfter_Fails :: POSIXTime -> Integer -> Property
prop_PositiveAfter_Fails d r = (r > 0 && d < 999) ==> runChecks False d r

-- Negative redeemers always succeed after deadline
prop_NegativeAfter_Succeeds :: POSIXTime -> Integer -> Property
prop_NegativeAfter_Succeeds d r = (r < 0 && d < 999) ==> runChecks True d r
----

All the property functions take a POSIX time and an integer variable
that represents the redeemer. They return a [purple]#Property# type variable.
Also, all of these functions use the [blue]#runChecks# function together with
the `==>` implication for properties operator. The [blue]#runChecks# function
takes a Boolean, which indicates if we expect this test to fail or
succeed. It also takes a POSIX time and an integer, which are randomly
generated, and returns a [purple]#Property# type variable. The operator `==>` takes
a Boolean that indicates which values are allowed to be passed to the
[blue]#runChecks# function, which we will define later. It also takes a type
variable that has an instance of the testable type class, which the
[purple]#Property# type has, and the [blue]#runChecks# function returns. Below are the
type signatures of these functions.

[source,shell]
----
runChecks :: Bool -> POSIXTime -> Integer -> Property

(==>) :: Testable prop => Bool -> prop -> Property
----

For the first property test, we only allow deadlines larger than 1,001
milliseconds to be passed to the [blue]#runChecks# function. Thus, this property
test should always fail since the time that we submit the transaction is
1,000 milliseconds. The redeemer, in this case, can be an arbitrary
integer number. For the second property test, the deadline should be
smaller than 999 milliseconds. However, the redeemer should be positive,
so these tests should also fail. In the third property test, the values
for the redeemer and the deadline should be in a valid range, so these
tests should pass.

Let’s now look at the testing functions:

[source,haskell]
----
------------------------------------------------------------------------------
------------------------------ RUNNING THE TESTS -----------------------------

-- | Check that the expected and real balances match after using the validator 
-- with different redeemers
runChecks :: Bool -> POSIXTime -> Integer -> Property
runChecks shouldConsume deadline redeemer = 
  collect (redeemer, getPOSIXTime deadline) $ monadic property check
    where check = do
            balancesMatch <- run $ testValues shouldConsume deadline redeemer
            assert balancesMatch 

-- Function to test if both creating and consuming script UTxOs works properly
testValues :: Bool -> POSIXTime -> Integer -> Run Bool
testValues shouldConsume datum redeemer = do
  -- SETUP USERS
  [u1, u2] <- setupUsers
  -- USER 1 LOCKS 100 ADA ("val") IN VALIDATOR
  -- Define value to be transferred
  let val = adaValue 100                    
  -- Get user's UTXOs that we should spend
  sp <- spend u1 val                        
  -- User 1 submits "lockingTx" transaction
  submitTx u1 $ lockingTx datum sp val      
  -- WAIT FOR A BIT
  waitUntil waitBeforeConsumingTx
  -- USER 2 TAKES "val" FROM VALIDATOR
  -- Query blockchain to get all UTxOs at script
  utxos <- utxoAt valScript                 
  -- We know there is only one UTXO (the one we created before)
  let [(oRef, oOut)] = utxos                
      -- Define transaction to be submitted
      tx = consumingTx datum redeemer u2 oRef (txOutValue oOut)            
      -- Define expected balance for user 2
      v2Expected = if shouldConsume then adaValue 1100 else adaValue 1000  
  -- Create time interval with equal radius around current time
  ct  <- currentTimeRad 100                 
  -- Build final consuming Tx
  tx' <- validateIn ct tx                   
  -- User 2 submits "consumingTx" transaction
  if shouldConsume then submitTx u2 tx' else mustFail . submitTx u2 $ tx'  
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  -- Get final balances
  [v1, v2] <- mapM valueAt [u1, u2]               
  -- Check if final balances match expected balances
  return $ v1 == adaValue 900 && v2 == v2Expected 
----

The [blue]#collect# function is used such that QuickCheck actually displays the
values that are being generated and tested against our properties. The
[blue]#monadic# and the [blue]#property# functions are used to generate a [purple]#Property# type
variable from our test that is contained in the [blue]#check# variable. You can
see the type signature of all those three functions below:

[source,shell]
----
Prelude> import Test.QuickCheck
Prelude Test.QuickCheck> :i collect 
collect :: (Show a, Testable prop) => a -> prop -> Property

Prelude> import Test.QuickCheck.Monadic
Prelude Test.QuickCheck.Monadic> :i monadic
monadic :: (Testable a, Monad m) => (m Property -> Property) -> 
                                    PropertyM m a -> Property

Prelude Test.QuickCheck> :i property
class Testable prop where
  property :: prop -> Property
----

The [blue]#check# variable is of type [purple]#PropertyM m a#, which is a property monad.
Given that m has an instance of the monad type class, [purple]#PropertyM# also has
a monad instance. The figure below depicts that the property monad has
also an instance of the IO monad ([purple]#MonadIO#) and the Fail monad
([purple]#MonadFail#) given that m has an instance of both monads.

[source,haskell]
----
newtype PropertyM m a =
  MkPropertyM { unPropertyM :: (a -> Gen (m Property)) -> Gen (m Property) }
----

In the [blue]#check# variable, we first call our [blue]#testValues# function and use the
[blue]#run# function to raise our run monad to a property monad, and then
extract the return value of type Boolean. This Boolean indicates whether
the test has passed or failed. After that, we use the [blue]#assert# function
that takes our Boolean and returns a property monad parameterized by
unit. If the Boolean is false, it raises an error. You can see the type
signatures of the [blue]#run# and [blue]#assert# functions below:

[source,shell]
----
Prelude Test.QuickCheck.Monadic> :i run
run :: Monad m => m a -> PropertyM m a

Prelude Test.QuickCheck.Monadic> :i assert 
assert :: Monad m => Bool -> PropertyM m ()
assert True  = return ()
assert False = fail "Assertion failed"
----

The [blue]#testValues# function is structured very similarly to the one in 
the previous example. The difference is that we compose the expected
final balance of user two ([blue]#v2Expected#) depending on whether the test
should fail or pass. Also, when we submit the claiming transaction, we
combine it with the [blue]#mustFail# function if we expect the test to fail. In
the end, we compare the expected balances of user one and two with their
actual balances. Below is an example output when running these property
tests:

[source,shell]
----
/<path>/<to>/<cabal_file># cabal test PTNegativeRTimed 
...
Running 1 test suites...
Test suite PTNegativeRTimed: RUNNING...
Testing script properties
  Anything before the deadline always fails       : OK (0.94s)
    +++ OK, passed 100 tests; 127 discarded:
     1% (-1,1162)
     1% (-10,1450)
     ... 96 other tests
     1% (83,1783)
     1% (9,1568)
  Positive redeemer after deadline always fails   : OK (0.33s)
    +++ OK, passed 100 tests; 341 discarded:
     1% (1,208)
     1% (1,248)
     ... 96 other tests
     1% (9,588)
     1% (9,699)
  Negative redeemer after deadline always succeeds: OK (0.30s)
    +++ OK, passed 100 tests; 285 discarded:
     1% (-1,176)
     1% (-1,185)
     ... 96 other tests
     1% (-8,820)
     1% (-80,446)
 
All 3 tests passed (1.58s)
Test suite PTNegativeRTimed: PASS
----

=== Staking and Plinth

Section <<Script context explained>> discussed that the
possible script purposes are minting, spending, rewarding, and
certifying. This section covers the _rewarding_ purpose and explains how
to use Plinth to influence the conditions under which staking rewards
can be withdrawn.

Governing staking reward withdrawals with a Plutus script became
possible after the Alonzo hard fork, which brought Plutus to Cardano’s
mainnet and testnet environments. Staking on Cardano operates in cycles
called epochs, each lasting five days. As a result, staking activity on
the mainnet typically requires waiting for at least one full epoch, or
five days, before rewards are distributed. An alternative approach is to
set up a private testnet, where you have full control over the
parameters. This allows you to shorten slot lengths or epochs, making it
feasible to experiment with staking in a much shorter time frame.

You can find the repository for setting up the private Cardano testnet
on the
https://github.com/woofpool/cardano-private-testnet-setup[Woofpool]
GitHub page. It is recommended to use the branch that corresponds to the
current era, if available. At the time of writing, this is the Babbage
era. The default configuration of this repository will spin up three
nodes, create three users, set up three stake pools, and provide initial
funds to the users. For this to work, a Cardano node must be installed
and running. All instructions are provided on the Woofpool GitHub page.
The bash scripts, presented in this section, were tested with version
1.35.5 for the Cardano node and CLI. The Docker container that support a
Plutus V2 development environment presented in section 
<<Setting up a Plinth development environment>>, provides the Cardano 
node and CLI version 1.35.5.

To run the testnet, execute the `automate.sh` script located in the
_scripts/_ folder from the root directory of the GitHub project:

[source,shell]
----
/<path>/<to>/cardano-private-testnet-setup# scripts/automate.sh
----

This takes a couple of seconds. Once you have the private testnet up and
running, you will see the message ‘_Congrats! Your network is ready for
use!_’. Due to the fast pace of this testnet, you will need to generate
new KES keys approximately after one hour of operation. Alternatively,
you can stop the testnet by pressing CTRL+C and restart it as needed.
Sometimes, some Cardano nodes may continue running after the testnet has
been stopped. You can check this with a task manager program and stop
them manually. On mainnet, every stake pool operator needs to regenerate
the KES keys every couple of weeks. Use the following script to see
testnet parameters and the sync progress:

[source,shell]
----
#!/bin/bash
export CARDANO_NODE_SOCKET_PATH=/<path>/<to>/node.sock
cardano-cli query tip --testnet-magic 42
----

In the _private-testnet/_ folder, you can find the public and private
payment and staking keys, along with the addresses for the three users
set up for the testnet. Bash scripts for querying user funds, stake pool
information, stake address details, and withdrawing rewards are located
in the _code/Week08/scripts_ folder of the Plutus Pioneer program GitHub
repository,
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[4th
iteration]. These scripts that use the Cardano CLI were also tested
with Cardano node and CLI version 1.35.5. Detailed explanations of these
scripts are provided in the
https://www.youtube.com/watch?v=BBqOZAuMx1c&t=272s[PPP 040802 – The
private testnet] video lecture.

This section demonstrates how to create a stake address using a Plutus
script instead of a public-private key pair. The hash of the Plutus
script generates a stake script address. Similar to a minting policy,
the script receives a redeemer and the script context. Various
certificates can be attached to a stake address, notably registration,
delegation, and deregistration certificates.

To create a new stake address, we first register it by creating a
transaction that includes a registration certificate. If we want to
delegate to a pool or change an existing validation, we use a
transaction containing a delegation certificate that specifies the pool
we want to delegate to. Finally, we can unregister a stake address and
receive the original deposit, paid during registration, back.

In this section, we focus on the rewarding purpose. The [purple]#TxInfo# type,
discussed in previous sections, contains fields relevant to staking,
specifically [blue]#txInfoDCert# and [blue]#txInfoWdrl#. The former holds a list of
certificates attached to the transaction, while the latter is a map from
staking credentials to integers, indicating withdrawal amounts.

In this map, the key is the staking credential, which can be derived
from a key pair or a Plutus script. The corresponding integer specifies
the amount of lovelace to withdraw. When the staking credential
originates from a Plutus script, executing a withdrawal triggers the
corresponding Plutus script. If the script runs without errors, the
withdrawal is successful; if it produces an error, the transaction
becomes invalid.

Now, let’s examine an example Plinth script that defines a stake
validator controlling withdrawals of rewards, parameterized by an
address. This script allows withdrawals from corresponding staking
credentials given by the script, provided that at least half of the
withdrawn rewards are directed to the specified address.

[source,haskell]
----
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NoImplicitPrelude     #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE TypeFamilies          #-}
{-# LANGUAGE TypeOperators         #-}
 
module Staking
    ( stakeValidator
    , saveStakeValidator
    ) where
 
import           Plutus.V1.Ledger.Value (valueOf)
import           Plutus.V2.Ledger.Api   (Address, BuiltinData,
                                         ScriptContext (scriptContextPurpose,
                                                        scriptContextTxInfo),
                                         ScriptPurpose (Certifying, Rewarding),
                                         StakeValidator, StakingCredential,
                                         TxInfo (txInfoOutputs, txInfoWdrl),
                                         TxOut (txOutAddress, txOutValue),
                                         adaSymbol, adaToken,
                                         mkStakeValidatorScript)
import qualified PlutusTx
import qualified PlutusTx.AssocMap      as PlutusTx
import           PlutusTx.Prelude       (AdditiveSemigroup ((+)), Bool (..),
                                         Eq ((==)), Integer,
                                         Maybe (Just, Nothing),
                                         MultiplicativeSemigroup ((*)),
                                         Ord ((>=)), Semigroup ((<>)), foldl,
                                         otherwise, traceError, traceIfFalse,
                                         ($), (.))
import           Prelude                (IO, String, ioError)
import           System.IO.Error        (userError)
import           Utilities              (tryReadAddress, wrapStakeValidator,
                                         writeStakeValidatorToFile)
 
{-# INLINABLE mkStakeValidator #-}
mkStakeValidator :: Address -> () -> ScriptContext -> Bool
mkStakeValidator addr () ctx = case scriptContextPurpose ctx of
    Certifying _   -> True
    Rewarding cred -> traceIfFalse "insufficient reward sharing" $
                  	2 * paidToAddress >= amount cred
    _              -> False
  where
    info :: TxInfo
    info = scriptContextTxInfo ctx
 
    amount :: StakingCredential -> Integer
    amount cred = case PlutusTx.lookup cred $ txInfoWdrl info of
        Just amt -> amt
        Nothing  -> traceError "withdrawal not found"
 
    paidToAddress :: Integer
    paidToAddress = foldl f 0 $ txInfoOutputs info
      where
        f :: Integer -> TxOut -> Integer
        f n o
            | txOutAddress o == addr = n + valueOf (txOutValue o)
                                   	   adaSymbol adaToken
            | otherwise              = n
 
{-# INLINABLE mkWrappedStakeValidator #-}
mkWrappedStakeValidator :: Address -> BuiltinData -> BuiltinData -> ()
mkWrappedStakeValidator = wrapStakeValidator . mkStakeValidator
 
stakeValidator :: Address -> StakeValidator
stakeValidator addr = mkStakeValidatorScript $
    $$(PlutusTx.compile [|| mkWrappedStakeValidator ||])
    `PlutusTx.applyCode`
    PlutusTx.liftCode addr
 
------------------------------------------------------------------------------
------------------------------ HELPER FUNCTIONS ------------------------------
 
saveStakeValidator :: String -> IO ()
saveStakeValidator bech32 = do
    case tryReadAddress bech32 of
        Nothing   -> ioError $ userError $ "Invalid address: " <> bech32
        Just addr -> writeStakeValidatorToFile "./assets/staking.plutus" $ 
                     stakeValidator addr
----

We use a typed version for our validator. In the [blue]#mkStakeValidator#
function, the first argument, which is the address, is the script’s
parameter. The next argument is the redeemer and since we do not need
it, we can use unit for the redeemer type. Then follows the script
context, and in the end, we return a Boolean.

In the validation logic, we look at the script purpose. If it is
certifying, we return true. However, if the purpose is rewarding, we
check if at least half of the withdrawn rewards are allocated to the
specified address, we used as an additional parameter to the validator
script. We use the [blue]#paidToAddress# helper function, which will give us the
amount of lovelace sent to that specified address. We also verify that
twice the specified amount is greater than or equal to the withdrawn
amount, which we calculate using the helper function _amount_, taking in
the staking credentials. The amount helper function utilizes the
[blue]#txInfoWdrl# field of the transaction information, which is a map from
staking credentials to integers.

The staking credential is provided by the script purpose, defined by the
hash of the validation script we created. While this may seem circular,
it parallels the scenario with minting policies, where discussions often
involve the currency symbol of the minting policy being defined.
Similarly, here, we define the staking credentials, but they are
supplied in the script purpose.

We use the [blue]#txInfoWdrl# constructor to get a map of withdrawals and look
up our credentials. If they are not in the map, we would throw an error;
however, this situation cannot occur because the script will only
execute if we reach the point of performing a withdrawal for this
credential. We retrieve the corresponding integer, which represents the
amount we return. This process addresses the right-hand side of the
inequality in the validator script, representing the number of lovelace
we are withdrawing as rewards.

Next, we need to figure out how much we are paying to the address that
is a parameter to the script. We loop over all the outputs of the
transaction and check whether each output goes to the address we are
interested in. We use an accumulator variable in the helper function [blue]#f#
(defined inside the [blue]#paidToAddress# function) since there could be several
outputs to this address, and we are interested in the total amount – the
sum. If the rewards do not go to the right address, the sum does not
change; if they do, we extract value from the output using the function
[blue]#valueOf#, which takes a currency symbol and a token name. We apply this
function to the ada symbol and token name to obtain the amount of
lovelace allocated to this address in that output. This gives us the
left-hand side of the in-equation in the validator script. Then, we
check the inequality condition – if we send more than half of the amount
we are withdrawing to the given address, the validation logic passes. If
not, we raise an error with the message "_insufficient reward sharing_".

After we have defined our validator, we have to convert it into an
untyped version. In the `Utilities` module, defined in the
_code/Utilities_ folder of the Plutus Pioneer GitHub repository
(https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[4th
iteration]), we define the [blue]#wrapStakeValidator# helper function, which
conducts this conversion for us. It is identical to the function we used
for wrapping a minting policy, which also does not take in a datum. Once
we have converted it to an untyped version, we use the usual template
Haskell features to compile the stake validator and apply the address
parameter. The exception is that, this time, we use the
[blue]#mkStakeValidatorScript# function defined in the _Plutus.V2.Ledger.Api_
module. If we want to use this from the cardano-cli, we need a way to
execute it and serialize the resulting stake validator to disk. We can
use the function [blue]#writeStakeValidatorToFile# from the
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration/code/Utilities[Utilities
module] in the `Serialise.hs` file located in the 4th iteration branch
of the Plutus Pioneer GitHub repository. To apply this, we need a Plutus
address. Normally, Plutus addresses are in the form of a string in the
bech32 representation. For example, if we use this private testnet
setup, we have user addresses in the form of such a string. It is not
completely trivial to take such a script and convert it to a Plutus
address. For this, we use the `Conversion` module, which is also defined
as a part of the previously mentioned `Utilities` module, where the
function [blue]#tryReadAddress# is defined.

We can now use this code on the testnet. First, we need to decide which
address we use as a parameter. From the three users that the testnet
provides, we take the second one. Their address is the one stored in the
_payment2.addr_ file from the _private-testnet/addresses/_.

[source,shell]
----
addr_test1qzxkl9zxmyptd4ua8zw2gcwr5qyj9djdr7ucu97gs8sh5uwm9kpwsxt2ksuf5yqnxqjeq8k59nar9nacqgj793xgwa6q0j2rhv
----

We start a REPL and serialize the stake validator to the 
`staking.plutus` file, where we provide the payment address from user
two:

[source,shell]
----
/<path>/<to>/<project># cabal repl
Prelude Staking> saveStakeValidator
"addr_test1qzxkl9zxmyptd4ua8zw2gcwr5qyj9djdr7ucu97gs8sh5uwm9kpwsxt2ksuf5yqnxqjeq8k59nar9nacqgj793xgwa6q0j2rhv"
Serialized script to: ./assets/staking.plutus
----

After that, we have to build a stake address from this script. This will
be the first example of a stake address that is not based on a key pair,
but on the script that we have just defined. Then, we need to register
this stake address and delegate it to a pool. We can use a cardano-cli
bash script to accomplish this. Cardano CLI explanations and script
examples can be found in the Plutus Pioneer program’s
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[4th
iteration] GitHub repository in third and fourth week code examples and
lectures. We call the script below, `register-and-delegate.sh`.

[source,shell]
----
#!/bin/bash

tmp=/<path>/<to>/address-and-certificate-files
txin=$1
echo "txin: $txin"

script=/<path>/<to>/staking.plutus
script_stake_addr=$tmp/user1-script-stake.addr
script_payment_addr=$tmp/user1-script.addr
registration=$tmp/registration.cert
delegation=$tmp/delegation.cert
pp=$tmp/protocol-params.json
body=$tmp/tx.txbody
signed=$tmp/tx.tx

export CARDANO_NODE_SOCKET_PATH=/<path>/<to>/cardano-private-testnet-setup/private-testnet/node-spo1/node.sock

cardano-cli stake-address build \
	--testnet-magic 42 \
	--stake-script-file $script \
	--out-file $script_stake_addr

echo "stake address: $(cat $script_stake_addr)"

cardano-cli address build \
	--testnet-magic 42 \
	--payment-verification-key-file=/<path>/<to>/cardano-private-testnet-setup/private-testnet/stake-delegator-keys/payment1.vkey \
	--stake-script-file=$script \
	--out-file $script_payment_addr

echo "payment address: $(cat $script_payment_addr)"

cardano-cli stake-address registration-certificate \
	--stake-script-file $script \
	--out-file $registration

cardano-cli stake-address delegation-certificate \
	--stake-script-file $script \
	--stake-pool-id=$(/<path>/<to>/query-stake-pools.sh | head -n 1) \
	--out-file $delegation

cardano-cli query protocol-parameters \
	--testnet-magic 42 \
	--out-file $pp

cardano-cli transaction build \
	--babbage-era \
	--testnet-magic 42 \
	--change-address $(cat $script_payment_addr) \
	--out-file $body \
	--tx-in $txin \
	--tx-in-collateral $txin \
	--certificate-file $registration \
	--certificate-file $delegation \
	--certificate-script-file $script \
	--certificate-redeemer-file /<path>/<to>/unit.json \
	--protocol-params-file $pp

cardano-cli transaction sign \
	--testnet-magic 42 \
	--tx-body-file $body \
	--out-file $signed \
	--signing-key-file /<path>/<to>/cardano-private-testnet-setup/private-testnet/stake-delegator-keys/payment1.skey

cardano-cli transaction submit \
	--testnet-magic 42 \
	--tx-file $signed  
----

Because we need to build and submit a transaction, we need an input,
which we store in the _txin_ parameter. We store all of our certificate
and address files in one place. After that, we define several file
paths. The first one is for the serialized script, followed by the
location where we want to write the stake address. We will use this
stake address to build a payment address, with the payment part
belonging to user one and the stake part assigned to our new stake
address. Next, we define the registration and delegation certificate
file paths. Finally, we set the paths for the protocol parameters,
transaction body, signed transaction files, and the node socket file
path variable.

The first step is to build the stake address using the cardano-cli
command _stake-address build_. It accepts a testnet magic, the script we
created, and a file path where to save the stake address. We then build
a payment address, inputting the testnet magic, the payment verification
key of user one, the staking script file, and the output file path.

After that, we create a registration certificate for this script-based
stake address and a delegation certificate. To do this, we need the pool
ID we want to delegate to. We use the script `query-stake-pools.sh` and
select the first pool available. All scripts referenced in the above
code can be found in the
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration/code/Week08/scripts[code/Week08/script/]
folder of the 4th iteration of the Plutus Pioneer program’s GitHub
repository.

After querying the protocol parameters, we build our transaction. For
the change address, we use the newly created address, ensuring that it
is funded. The funds will come from user one’s original address, which
was based on a key pair. In principle, all the funds, except for the
transaction costs, will go to this new address, where user one retains
spending power, but the stake component has been replaced by our script.

When building the transaction, we use the specified input, which we also
use as collateral since Plutus scripts are involved. The logic of our
validation script always returns true for the certificates part;
however, it still needs to execute, requiring collateral. Next, we
attach the registration and delegation certificates, providing the
script as a witness. When we withdrew rewards for user one using the old
stake address, we needed to sign transactions with the corresponding
staking key. Now, this is replaced by providing the certificate.

We input the redeemer JSON file representing a unit and add the protocol
parameters file. After building our transaction, we need to sign it
using only user one’s payment key. Finally, we submit the transaction.
To use that script, we look up the UTXO available for spending using the
`query-utxo-user1.sh` script.

[source,shell]
----
                          TxHash                                  TxIx     Amount   
------------------------------------------------------------------------------------
4184b0b1b8363b81b30c58bfb5f3972dfce9a2dcf886998e37929964f3b3619b   0    342271389694
                                                                            lovelace
                                                                    + TxOutDatumNone
----

When we use the previously defined script for registration and
delegation of our funds, we input the above transaction hash and index 0
to it.

[source,shell]
----
/<path>/<to>/<script># ./register-and-delegate.sh 4184b0b1b8363b81b30c58bfb5f3972dfce9a2dcf886998e37929964f3b3619b#0
----

An example output of the above command can be seen below:

[source,shell]
----
txin: b1d51a046b9cd92ce504382fdd83ea4436d265ff97cb0a6eefb1dce6f8096550#0
stake address:
stake_test17q7pv2ap3scy9s9qurfjgwg6mmvsva87x5r8pydw9a66jqcuqdj7g
payment address:
addr_test1ypnuk08vjnrjq66frsj0cnk0fgexkf4d66d2tdvd2vgedqeuzc46rrpsgtq2pcxnysu34hkeqe60udgxwzg6utm44ypswpjxdv
Estimated transaction fee: Lovelace 345564
Transaction successfully submitted.
----

We see the log messages and the spent UTXO. The newly created stake
address is now based on our script. We also created the payment address
and submitted the transaction. Now, there should not be any funds left
at the initial address, as all the funds have been moved to the new
payment address we created. Therefore, if we query the funds for user
one, there will be none. Using the script `query-utxo-user1-script.sh`
we can check the funds for the new address we have just created. The
script can be seen below:

[source,shell]
----
#!/bin/bash
export CARDANO_NODE_SOCKET_PATH=/<path>/<to>/cardano-private-testnet-setup/private-testnet/node-spo1/node.sock
cardano-cli query utxo \
	--testnet-magic 42 \
	--address $(cat /<path>/<to>/user1-script.addr)
----

If we execute the query, we see that almost all the 300.000 ada has been
transferred to this address. The small difference is attributed to the
registration deposit and transaction fees.

[source,shell]
----
                          TxHash                                  TxIx     Amount   
------------------------------------------------------------------------------------
7c018e5e39649a52b9e1f9527e9ac8dcc70b1da818629dc30e6322cbea6f4e44   0    299999654436
                                                                            lovelace
                                                                    + TxOutDatumNone
----

After some time, when the rewards at the staking address have
accumulated, we can construct a transaction to withdraw them, ensuring
that half of the rewards are sent to user two. The example script below
demonstrates how to accomplish this using the cardano-cli tool:

[source,shell]
----
#!/bin/bash

txin=$1
tmp=/<path>/<to>/address-and-certificate-files
amt1=$(/<path>/<to>/scripts/query-stake-address-info-user1-script.sh | jq .[0].rewardAccountBalance)
amt2=$(expr $amt1 / 2 + 1)
pp=$tmp/protocol-params.json
body=$tmp/tx.txbody
signed=$tmp/tx.tx

echo "txin = $1"
echo "amt1 = $amt1"
echo "amt2 = $amt2"

export CARDANO_NODE_SOCKET_PATH=/<path>/<to>/cardano-private-testnet-setup/private-testnet/node-spo1/node.sock

cardano-cli query protocol-parameters \
    --testnet-magic 42 \
    --out-file $pp

cardano-cli transaction build \
    --babbage-era \
    --testnet-magic 42 \
    --change-address $(cat $tmp/user1-script.addr) \
    --out-file $body \
    --tx-in $txin \
    --tx-in-collateral $txin \
    --tx-out "$(cat /<path>/<to>/cardano-private-testnet-setup/private-testnet/addresses/payment2.addr)+$amt2 lovelace" \
    --withdrawal "$(cat $tmp/user1-script-stake.addr)+$amt1" \
    --withdrawal-script-file /<path>/<to>/staking.plutus \
    --withdrawal-redeemer-file /<path>/<to>/unit.json \
    --protocol-params-file $pp

cardano-cli transaction sign \
    --testnet-magic 42 \
    --tx-body-file $body \
    --out-file $signed \
    --signing-key-file /<path>/<to>/cardano-private-testnet-setup/private-testnet/stake-delegator-keys/payment1.skey

cardano-cli transaction submit \
    --testnet-magic 42 \
    --tx-file $signed
----

The objective is for user one to withdraw rewards from the newly created
stake address. First, we set the temporary folder. The amount to
withdraw is the same as before. Since we are now using the script-based
stake address, we query the accumulated rewards with the
`query-utxo-user1-script.sh` script, specifying the new address we
created. We extract the amount using the _jq_ tool.

Next, we calculate a second amount, ensuring that at least half of the
withdrawn rewards go to user two’s address. We use a Linux command to
compute this amount, adding one in case the result of dividing the first
amount by two is an odd number, which would round down.

After setting the node socket file path, we query the protocol
parameters and save them to a file. We then construct the transaction,
specifying the era and testnet magic. As the change address, we use the
new address, from which we are also taking the original funds. We
specify the output file for the transaction. We use the specified UTXO
as input and also as collateral. Then we pay user two half of the
calculated amount and perform the withdrawal from the new stake address,
which is specified along with the full amount of available rewards. We
need to provide the script file in this case, and for the redeemer, we
input a unit representation. Finally, we attach the protocol parameters
file.

When signing this transaction, only the payment part requires a
signature because the staking part is managed by the script. Finally, we
submit the transaction. Now we can use the UTXO returned by the
`query-utxo-user1-script.sh` script as input. We can now run the
following command:

[source,shell]
----
/<path>/<to>/<script># ./withdraw-user1-script.sh
7c018e5e39649a52b9e1f9527e9ac8dcc70b1da818629dc30e6322cbea6f4e44#0
----

If we submit the transaction with the line that pays half of the rewards
to user two, the transaction passes successfully. We can then query user
two’s funds – we see that he has the initial UTXO and also a second one
with rewards.

[source,shell]
----
                          TxHash                                  TxIx     Amount   
------------------------------------------------------------------------------------
9f54c1a9319b02a2da7110bb90946845dbe8e5fce0f770a4e8ee2955eed223cb   0    300000000000
                                                                            lovelace
                                                                    + TxOutDatumNone
902aba5b2b72df2423ee33d4af294e21e0903c31e34917a4de8570b3e8d08c7b   1      5070281709
                                                                            lovelace
                                                                    + TxOutDatumNone
----

If we query the funds for user one with the `query-utxo-user1-script.sh`
script, he has now more than the original 300,000 ada because he also
got the other half of the rewards.

[source,shell]
----
                          TxHash                                  TxIx     Amount   
------------------------------------------------------------------------------------
902aba5b2b72df2423ee33d4af294e21e0903c31e34917a4de8570b3e8d08c7b   0    305069582064
                                                                            lovelace
                                                                    + TxOutDatumNone
----

If we removed the line below from the withdrawal script, we would get an
error with the message "__insufficient reward sharing__", whichwe
have defined in the Plinth script.

[source,shell]
----
--tx-out "$(cat /<path>/<to>/cardano-private-testnet-setup/private-testnet/addresses/payment2.addr)+$amt2 lovelace" \
----

=== PlutusV3 features

PlutusV3 focuses on performance throughput, smart contract size,
platform capabilities, and interoperability with other blockchains.
Specifically, PlutusV3 brings:

* Bitwise primitives
* Cryptographic primitives
* Sums of products.

Bitwise primitives allow for the manipulation of data at the lowest
level of bits. Those operations are the fundamental building blocks of
many algorithms and data structures. There are numerous applications,
ranging from efficient representation and manipulation of sets of
integers to the implementation of cryptographic primitives and fast
searches. In particular, PlutusV3 enables converting integers to byte
strings, which allows, for example, to hash arbitrary data, which hasn’t
been possible in the past.

Cryptographic primitives form the foundation of blockchain technology.
The choice of primitives significantly influences blockchain’s
capabilities. Because other blockchains choose different primitives than
Cardano, it is challenging to interoperate with them. An example of
interoperability is checking Ethereum signatures in Plutus, which is
possible with PlutusV3. There are three groups of new cryptographic
primitives in PlutusV3:

* BLS12-381 is about elliptic curve pairing and including 17 primitives
that support cryptographic curves. Use cases include sidechains, ZKP,
Hydra, Mithril and ATALA
* Blake2b_224 is a cryptographic hash function that enables hashing of
public keys and scripts within Plutus, facilitating various interesting
applications
* Keccak-256 is also a cryptographic hash function that supports
Ethereum signature verification within Plutus scripts.

These cryptographic primitives bring new possibilities, unlock better
ways to achieve scalability, and allow for better interoperability with
Ethereum and EVM-based blockchains.

The last feature PlutusV3 brings is sums of products. One common method
for encoding data types in Plutus Core is the Scott approach. With the
introduction of PlutusV3, sums of products allow for encoding data types
more compactly and cost-effectively than Scott encoding, so the latter
is no longer required.

The sums of products method is designed to enhance script efficiency and
optimize code generation for Plutus Core compilers. This involves
implementing new term constructors for packing fields into constructor
values and enabling efficient tag inspection for case branches. As a
result, programs may experience a performance increase of up to 30%,
marking a significant optimization that streamlines operations and
ensures faster execution of smart contracts. For further details, refer
to https://cips.cardano.org/cip/CIP-0085[CIP-85]. Sums of products do
not change built-in functions available in Plutus, but change the Plutus
language itself.

The https://www.youtube.com/watch?v=oFgJg_DulKw&t=69s[PlutusV3
Overview] video demonstrates how to lock ada in a Plutus validator that
can only be unlocked by the owner of an ETH wallet. The demonstration
starts at 4:10. You can also read more about PlutusV3 and the features
that it brings in the IO blog,
https://iohk.io/en/blog/posts/2024/02/12/unlocking-more-opportunities-with-plutus-v3/[Unlocking
more opportunities with PlutusV3]. The official documentation provides
further information on the
https://docs.cardano.org/about-cardano/evolution/upgrades/chang/[Chang
hard fork] that enables PlutusV3.

*PlutusV3 smart contracts*

Section <<Script context explained>> highlighted the differences
between the PlutusV2 and V3 structure of the script context type.
Because of the changes in PlutusV3, spending and minting scripts only
access the script context as a parameter to the script and the redeemer
and datum can then be accessed within the script context. Let us recall
the structure of the script context type for PlutusV3.

[source,haskell]
----
data ScriptContext = ScriptContext
  { scriptContextTxInfo     :: TxInfo
  , scriptContextRedeemer   :: V2.Redeemer
  , scriptContextScriptInfo :: ScriptInfo
  }
  deriving stock (Generic, Haskell.Eq, Haskell.Show)
  deriving anyclass (HasBlueprintDefinition)
----

To recap, when a transaction is spending multiple UTXOs at a script
address, the spending script is run individually for every UTXO we are
spending. In such a case the [purple]#TxInfo# that can be accessed by the script,
is the same in every time the script runs, but the [purple]#Redeemer# and
[purple]#ScriptInfo# are different and are assigned individually for every UTXO we
are spending at this script address. This holds also true if we want to
mint different native assets that use the same minting policy (have the
same currency symbol) but get different token names assigned or trigger
both minting policies and spending scripts within one transaction.

Let us look now at a PlutusV3 script, where we check that the redeemer
is the number 42, that we already showed as a PlutusV2 script in section
<<Simple validation scripts>>.

[source,haskell]
----
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE Strict #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# OPTIONS_GHC -fno-full-laziness #-}
{-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}
{-# OPTIONS_GHC -fno-omit-interface-pragmas #-}
{-# OPTIONS_GHC -fno-spec-constr #-}
{-# OPTIONS_GHC -fno-specialise #-}
{-# OPTIONS_GHC -fno-strictness #-}
{-# OPTIONS_GHC -fno-unbox-small-strict-fields #-}
{-# OPTIONS_GHC -fno-unbox-strict-fields #-}
{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}

module Week02.Validators where

import PlutusLedgerApi.Common (
  FromData (fromBuiltinData),
  SerialisedScript,
  serialiseCompiledCode,
 )
import PlutusLedgerApi.V3 (
  Redeemer (getRedeemer),
  ScriptContext (..),
 )
import PlutusTx (
  BuiltinData,
  CompiledCode,
  UnsafeFromData (unsafeFromBuiltinData),
  compile,
 )
import PlutusTx.Bool (Bool (..))
import PlutusTx.Prelude (
  BuiltinUnit,
  Eq (..),
  Integer,
  Maybe (..),
  check,
  traceError,
  traceIfFalse,
  ($),
 )

{- ------------------------------------------------------------------------ -}
{------------------------------ 42 validator ------------------------------ -}

{-# INLINEABLE fortyTwoVal #-}
fortyTwoVal :: ScriptContext -> Bool
fortyTwoVal ctx = traceIfFalse "Redeemer is a number different than 42" 
                  $ 42 == r
 where
  r = case fromBuiltinData $ getRedeemer (scriptContextRedeemer ctx) of
    Just @Integer n -> n
    Nothing -> traceError "Redeemer is not a number"

{- ------------------------------------------------------------------------ -}
{--------------------------------- HELPERS -------------------------------- -}

compiledFortyTwoVal :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledFortyTwoVal = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinUnit
  wrappedVal ctx = check $ fortyTwoVal (unsafeFromBuiltinData ctx)

serializedFortyTwoValidator :: SerialisedScript
serializedFortyTwoValidator = serialiseCompiledCode compiledFortyTwoVal
----

The language extensions and import statements change in comparison with
the PlutusV2 script to accommodate for PlutusV3 changes. The validator
code now has a helper function that looks up the redeemer from the
script context and also checks if it is a integer. With the helper
functions, we compile the validator and serialize it. The PlutusV3
libraries allow for serializing the validator in the form of a Plutus
blueprint, as stated in https://cips.cardano.org/cip/CIP-57[CIP-57],
that contains beside the cbor-encoded serialized flat script also other
usefull information.

Next we can look at the vesting script that we presented in section
<<Time-dependent and parameterized validators>>. The vesting script
allows claiming the funds if a certain deadline has passed and the
beneficiary has signed the transaction. Both of this information has to
be attached to the datum of the UTXO we are creating at this script
address.

[source,haskell]
----
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveAnyClass             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost        #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE Strict                     #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE ViewPatterns               #-}
{-# OPTIONS_GHC -fno-full-laziness #-}
{-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}
{-# OPTIONS_GHC -fno-omit-interface-pragmas #-}
{-# OPTIONS_GHC -fno-spec-constr #-}
{-# OPTIONS_GHC -fno-specialise #-}
{-# OPTIONS_GHC -fno-strictness #-}
{-# OPTIONS_GHC -fno-unbox-small-strict-fields #-}
{-# OPTIONS_GHC -fno-unbox-strict-fields #-}
{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}

module Week03.Vesting where

import           GHC.Generics                  (Generic)
import           PlutusLedgerApi.Common        (FromData (fromBuiltinData),
                                                SerialisedScript,
                                                serialiseCompiledCode)
import           PlutusLedgerApi.Data.V3       (POSIXTime, PubKeyHash, from)
import           PlutusLedgerApi.V1.Interval   (contains)
import           PlutusLedgerApi.V3            (ScriptContext (..),
                                                ScriptInfo (..),
                                                TxInfo (txInfoValidRange),
                                                getDatum)
import           PlutusLedgerApi.V3.Contexts   (txSignedBy)
import           PlutusTx                      (BuiltinData, CompiledCode,
                                                UnsafeFromData
                                                  (unsafeFromBuiltinData),
                                                compile,
                                                makeIsDataSchemaIndexed)
import           PlutusTx.Blueprint            (HasBlueprintDefinition)
import           PlutusTx.Blueprint.Definition (definitionRef)
import           PlutusTx.Bool                 (Bool (..), (&&))
import           PlutusTx.Prelude              (BuiltinUnit, Maybe (..), 
                                                check,traceError,
                                                traceIfFalse, ($), (.))

{- ------------------------------------------------------------------------ -}
{----------------------------------- TYPES -------------------------------- -}

data VestingDatum = VestingDatum
  { beneficiary :: PubKeyHash
  , deadline    :: POSIXTime
  }
  deriving stock (Generic)
  deriving anyclass (HasBlueprintDefinition)

makeIsDataSchemaIndexed ''VestingDatum [('VestingDatum, 0)]

{- ------------------------------------------------------------------------ -}
{--------------------------------- VALIDATOR ------------------------------ -}

{-# INLINEABLE vestingVal #-}
vestingVal :: ScriptContext -> Bool
vestingVal ctx =
  traceIfFalse "Is not the beneficiary" checkBeneficiary && 
  traceIfFalse "Deadline not reachec" checkDeadline
 where
  checkBeneficiary :: Bool
  checkBeneficiary = txSignedBy info (beneficiary vestingDatum)

  checkDeadline :: Bool
  checkDeadline = from (deadline vestingDatum) `contains` 
                  txInfoValidRange info

  vestingDatum :: VestingDatum
  vestingDatum = case scriptContextScriptInfo ctx of
    SpendingScript _txRef (Just datum) -> 
      case (fromBuiltinData @VestingDatum . getDatum) datum of
        Just d  -> d
        Nothing -> traceError "Expected correctly shaped datum"
    _ -> traceError "Expected SpendingScript with datum"

  info :: TxInfo
  info = scriptContextTxInfo ctx

{- ------------------------------------------------------------------------ -}
{--------------------------------- HELPERS -------------------------------- -}

compiledVestingVal :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledVestingVal = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinUnit
  wrappedVal ctx = check $ vestingVal (unsafeFromBuiltinData ctx)

serializedVestingVal :: SerialisedScript
serializedVestingVal = serialiseCompiledCode compiledVestingVal
----

The validator code is mostly the same as compared to the PlutusV2
script, with the exception that we look up the datum in the
[blue]#scriptContextScriptInfo# field of the script context. We also check that
the datum exist and has the correct shape. As in the previous code
example with the helper functions, we again compile the validator and
serialize it.

== Smart contract security and best practices

=== Cardano security

Best practices for the security of smart contracts is an important
topic, since these programs can manage significant funds and include
sensitive information. Estimates for the loss of funds due to various
attacks and hacks, including scams, say that the total loss of funds was
over $3.2bn in 2021 and over $3.7bn in 2022 (source:
https://www.coindesk.com/tech/2023/05/24/attackers-left-empty-handed-as-crypto-hacks-drop-70-in-q1-2023/[CoinDesk]).
Hacks to blockchain smart contracts and bridges until October 2023 alone
totaled $4.28bn (source:
https://www.emurgo.io/press-news/why-your-web3-dapp-needs-a-smart-contract-audit/[Emurgo]).
The graph below displays the cumulative amount of lost funds in audited
and unaudited codebases for Web3 projects in a three-year period (data
taken from the https://rekt.news/leaderboard/[Rekt leaderboard]), Out
of 137 compromised projects, 58 were audited, and 79 were not, meaning
that unaudited Web3 projects account for a substantially larger
cumulative loss of funds, even though their number is not much higher
than the number of audited projects.

image::sc_loss_of_funds.png[width=635,height=421,title="Loss of funds, source: https://www.cyfrin.io/blog/competitive-vs-private-audits-comparison[Cyfrin blog]"]

Nevertheless, a $1.3bn loss in audited projects is still high. This
implies that an audit by itself may not always ensure a project’s
safety. Other factors, such as the auditing methodology and the security
features of the underlying blockchain, can also play a safety role.

A software audit is a type of software review where one or more auditors
(usually third parties) conduct an examination of a software product to
assess compliance with specifications, standards, contractual
agreements, and other criteria (source:
https://en.wikipedia.org/wiki/Software_audit_review[Wikipedia]).
Blockchain auditing can be defined as the systematic process of
reviewing and analyzing a blockchain's codebase and its specifications.
It involves code revision to ensure no hidden or unwanted design flaws
or bugs that may lead to production issues. Beside security guarantees,
an audit can also prove compliance with industry standards and best
practices and increase trust and credibility. Audits can be grouped into
manual auditing, where each line of code is analyzed by the auditors,
and automated auditing, where auditors use software auditing tools. A
combination of both is also possible.

Cardano was designed with security in mind from the beginning. Input |
Output (IO) has invested much effort into academic research, and its
research team has written and collaborated on
https://iohk.io/en/research/library/[over 200 scientific papers] as of
the time of writing. Some of the important research areas that IO
targets are cryptography, software engineering, distributed systems,
networks, formal verification, and programming languages. Ouroboros,
Cardano’s consensus protocol, is explained in detail in section 
<<About the Ouroboros protocol>>. Ouroboros represents the outcome of long
research presented in multiple papers. It is the first blockchain
consensus protocol developed through peer-reviewed research with
mathematically proven security features that guarantee the protocol is
secure as long as 51% of the active stake (ada locked in for an epoch
snapshot) is held by honest participants. The extended UTXO (EUTXO)
model, explained in section <<The EUTXO model>>, was also
developed through extensive research and is well-tested by the
community. There have been no major security breaches, and the Cardano
mainnet has not experienced any downtime. An event happened in January
2023 that affected the functionality of around half of all Cardano
nodes. During this event, the network was still processing transactions,
and within minutes, nodes started to recover by being manually restarted
by stake pool operators or by system management software. After the
restart, the nodes that were down managed to continue growing the chain
and producing blocks. The consensus algorithm worked, and the network
never split, which was due to Cardano's robust design. The issue was
later identified and fixed. Details can be found in
https://www.314pool.com/post/cardano-post-mortem-1[this] and
https://cardanospot.io/news/cardano-node-outage-what-we-know-0[this]
post-mortem.

Cardano is also well-designed to support
https://www.essentialcardano.io/article/concurrency-and-all-that-cardano-smart-contracts-and-the-eutxo-model[concurrency]
and parallelism. Concurrency is the ability for multiple parties to
progress on a task without interfering with each other, and parallelism
is the ability to have multiple transactions happen simultaneously.
While Ethereum has concurrency, it is not well suited for parallelism
because its account-based model has a global state that transactions
update and smart contracts can access. This means that the state can
change between when a user submits a transaction and when it is
processed, which means the transaction can fail even after the user pays
the transaction fee. You can read more about this topic in the following 
https://academy.geniusyield.co/articles/what-is-cardano[GeniusYield Academy blog]. 
There is no global state in Cardano, and a smart contract only sees the datum 
of the UTXO the transaction is consuming, the redeemer, and other data contained 
in the transaction context that also provides access to all inputs and outputs. 
Section <<Plutus smart contracts>> explains these concepts in detail.

In theory, there can be multiple transactions processed simultaneously,
given that they consume different input UTXOs. This is because
transactions can be validated _before_ they are submitted to the
blockchain. Given that the inputs are present at the time of submission,
a valid transaction will _always_ succeed with a predictable outcome. In
other words, transactions are deterministic because their outcome is
predictable. If the inputs to a valid transaction are not present at the
time of submission, the submitted transaction will not be processed, and
the user will not be charged any fees.
https://iohk.io/en/blog/posts/2022/04/13/boosting-cardano-s-throughput-with-script-referencing/[Reference
inputs] enable multiple transactions referencing the same UTXO, which
is possible because none of those transactions consumes this particular
UTXO. In Cardano, it is possible that a user forces an invalid
transaction to be processed, which will fail. In such a case, the user
will be charged fees because an attacker could try to flood the network
with invalid transactions to congest it, and the fees make such an
attack very expensive. Cardano’s determinism means that users always
know how much a transaction will cost before submitting it. The reason
for this is that protocol parameters, rather than network traffic,
govern pricing on Cardano. Also, a side effect of EUTXO and determinism
is that bad actors cannot rearrange transactions. This can happen in
account-based models, posing a risk for applications built on these
chains.

https://iohk.io/en/blog/posts/2021/09/06/no-surprises-transaction-validation-on-cardano/[This
blog post] explains in more detail the determinism of transaction and
script validation in Cardano. According to this article, in-determinism
means that the effect of a transaction on the ledger cannot be predicted
before execution, and it further explains the key points that make the
outcomes of script and transaction validation predictable on Cardano.

These are:

[arabic]
. The script interpreter will always terminate and return the same
validation result when applied to the same arguments
. A transaction necessarily fixes all arguments that will be passed to
the script interpreter during validation
. A transaction specifies all the actions it is taking that require
script validation
. Compulsory signatures on a transaction ensure that it cannot be
altered by an adversary in a way that causes scripts to fail
. Applying a transaction in the EUTXO ledger model is deterministic.

Determinism of fees and transactions can also be advantageous in Web3
applications, such as decentralized exchanges (DEXs). Liquidity
providers face the issue of impermanent loss on DEXs that use the
https://www.coindesk.com/learn/what-is-an-automated-market-maker/[Automated
market maker] (AMM) design model. In an AMM-style DEX, smart contracts
enable automated trading of cryptocurrency pairs, which are often a
fungible token (native or non-native) and a stablecoin.

Let us consider an example of an AMM DEX where the deposited token pair
is ETH and USDT (Tether), a stablecoin pegged to USD, and they need to
be of equivalent value. If the price of 1 ETH is 1,000 USD and a
liquidity provider wants to add 1 ETH to the pool, he must also add
1,000 USDT. Then, over time, the price of ETH rises to 3,000 USD, which
is three times larger than the initial price. During this time,
https://www.coindesk.com/learn/crypto-arbitrage-trading-how-to-make-low-risk-gains/#:~:text=In%20its%20simplest%20form%2C%20crypto,involves%20little%20or%20no%20risks[arbitrage traders] 
add USDT to the pool and remove ETH from it to take advantage
of small price differences across two different markets. The pool
reserves change such that the initial amount of ETH gets divided by
1.732, and the USDT amount gets multiplied by 1.732, which is the square
root of three. This means that now every ETH in the pool is backed by
3,000 USDT. When the same liquidity provider withdraws the funds, they
get around 0.5774 ETH and 1,732 USDT, which at the current market price
of ETH adds to around 3,464 USD. But if the trader had held on to the
initial funds of one ETH and 1,000 USDT, they would now have 4,000 USD,
meaning his impermanent loss was around 536 USD. The reason why it pays
off to be a DEX liquidity provider is because they get a percentage of
the trading fees. Arbitrage traders pay for every transaction they make,
and those fees can often be larger than the amount of impermanent loss.
https://iohk.io/en/blog/posts/2022/05/27/everything-you-always-wanted-to-know-about-impermanent-loss-and-were-afraid-to-ask/[This
blog post] states that the EUTXO accounting model is a suitable
environment for DEXs using the order book model. An order book model
simply lists the buy/sell orders, and if there is supply and demand, the
asset can be traded. An advantage of this design is concentrated
liquidity (liquidity allocated within a custom price range.) This
minimizes the effects of impermanent loss, creating a more stable
environment for liquidity providers. The blog post explains in more
detail how impermanent loss affects DEXs built on the account-based
accounting models compared to EUTXO.

Cardano smart contracts are also atomic and cannot make calls to each
other. In Ethereum and other blockchains where this is possible, a smart
contract function could, in the short term, give up control of a
transaction when it calls another contract. This other contract could
make recursive withdrawal calls to the first contract and drain its
funds before the first contract updates its state. This is known as a
reentrance attack, and it’s what happened to the DAO smart contract
https://www.coindesk.com/learn/understanding-the-dao-attack/[hacked in
2016]. On that occasion, 3.6m ETH (worth around 50m USD at the time)
was affected. Such attacks are not possible in Cardano due to the design
of the EUTXO accounting model.

The EUTXO model also treats its tokens as native, meaning they are
treated the same way as ada. For this reason, they get the same security
and transfer logic as ada does. Many other blockchains use smart
contracts to generate tokens, as Ethereum does with
https://en.wikipedia.org/wiki/Ethereum#ERC20[ERC-20 tokens]. Buying or
selling these tokens requires interaction with a smart contract, which
incurs higher transaction costs. Such tokens also carry a higher risk
because the security of the token is based on the smart contract’s
correctness and security.
https://www.emurgo.io/press-news/why-crypto-projects-built-on-cardano-are-more-secure/[This
Emurgo blog post] states that blockchains that use smart contracts to
manage native tokens can sometimes require smart contracts to have a
hierarchy of permissions, as in a DEX, for example. If in such a DEX,
the web of authority delegations has a complex structure, design
mistakes can happen. This can cause an attacker to be able to exploit
the system, potentially resulting in a user who wants to swap his tokens
to lose their funds. So, a user who wants to use such a DEX must be sure
that all the contracts are safe. Another security advantage of native
tokens is that over- and under-flow vulnerabilities present in ERC-20
tokens are eliminated, as Cardano’s scripting language does not have
fixed-size integers, and the ledger itself tracks the movement of
tokens. The table below compares the security features of Ethereum
ERC-20 tokens with Cardano native tokens.

[cols="1,1,1,1", options="header"]
|===
| |ERC20 |Native tokens |Comment 
|User errors in copying standard code |YES |NO |All shared functionality is provided by the ledger 
|Over-/under-flow vulnerabilities |YES |NO |Cardano's scripting languages don't have fixed-size integers
|Unprotected functions |YES |NO |User code is called only in very specific cases to validate minting
|Denial of service via gas price attacks |YES |NO |Denial of service attacks on the entire system are still possible 
|=== 

A comparison of various characteristics between Ethereum ERC-20 and
Cardano native tokens can be found on
https://cardano-ledger.readthedocs.io/en/latest/explanations/features.html[this
page].

Cardano also enables smooth upgrades to its protocol using a hard fork
combinator (HFC). Hard forks introduce radical changes to the blockchain
protocol. They might cause downtime, a chain restart, or compatibility
loss. In Cardano, the HFC is designed to enable the combination of
several protocols without having to make significant adjustments. It
allows Cardano nodes to run multiple protocol versions and enables
smooth transitions during hard forks. If a hard fork upgrades the Plutus
language to a new major version, smart contracts using an older version
of Plutus can still be processed. You can read more about the HFC in
<<Cardano node layers>> section, subsection **Consensus and storage layer**.

Cardano smart contracts see a predictable number of inputs and can only
produce a set number of outputs that are always the same given the same
inputs. Because of that, they are also perfect for audits. The job of a
smart contract auditor is also more straightforward because outcomes
that cannot be foreseen are minimized by the design of the EUTXO model.
A smart contract auditor only needs to follow the logic of the validator
to assess if all possible outcomes are desirable and is not concerned
with a global state that might influence the final output. Besides
auditing smart contracts, off-chain code and other parts of a DApp may
also be audited to assess the security of the entire application.

These are some of Cardano's security features. The security features and
best practices of the Plutus and Marlowe smart contract languages are
further discussed in the next four sections. Because those languages
follow different best practices for developing smart contracts, we will
explain the advantages and best practices for them separately.

=== Plutus security

Blockchain programming platforms often depend on a custom smart contract
language, such as Ethereum’s Solidity. Cardano offers Plinth (formerly
known as PlutusTx), which is a Turing-complete (see <<Glossary>>) 
smart contract language realized on top of Haskell, a high-assurance,
pure functional programming language with a strong type system. You can
read more about the characteristics and advantages of the Haskell
programming language in section <<Features and benefits of Haskell>>.
The Glasgow Haskell Compiler (GHC) is the most well-established Haskell
compiler used to compile Plinth code. On-chain code is compiled into
Plutus Core (known simply as _Plutus_), which is the scripting language
used by Cardano to implement the EUTXO model. Cardano nodes execute the
compiled Plutus scripts during transaction validation.

Plutus is a simple, functional language similar to Haskell, and a large
subset of Haskell can be used to write Plutus scripts. Its simple and
deterministic design allows careful cost control of program execution.
Plutus is also a variant of
https://en.wikipedia.org/wiki/Lambda_calculus[lambda calculus],
specifically, https://en.wikipedia.org/wiki/System_F[System F]. Lambda
calculus is a formal system in mathematical logic for expressing
computation based on function abstraction. GHC’s internal language (GHC
Core) is also based on System F, but it does differ from Plutus in some
ways. The Plutus language was designed with the following requirements
in mind:

* minimalism
* safety
* formalization
* size
* extensibility
* multiple source languages.

You can read a short explanation of each of the above requirements in
the
https://ci.iog.io/job/input-output-hk-plutus/master/x86_64-linux.packages.plutus-report/latest/download/1[Plutus
Platform] technical report, and you can read more about the design
details of the Plutus language in its
https://ci.iog.io/job/input-output-hk-plutus/master/x86_64-linux.packages.plutus-core-spec/latest/download/1[formal
specification] document. The
https://github.com/IntersectMBO/plutus[Plutus] GitHub page features
links to related materials.

Plutus scripts can be generated using Plinth, a GHC plug-in that runs
during the GHC compilation process. It modifies the program that GHC is
compiling however it likes. Under the hood, though, the compilation
process is more complex. The image below shows the compilation process
of the on-chain validation code.

image::sc_plutus_compilation.png[width=624,height=53,title="Plutus compilation pipeline"]

We start with Plinth, a subset of Haskell representing the high-level
language developers use to code the smart contract. Compiling this code
goes through several steps.

* First, it transforms into the GHC core, part of the GHC compilation
pipeline.
* Second, it gets compiled into the Plutus Intermediate Representation
(PIR). From now on, it will be independent of GHC and Haskell and have
total control of the compilation pipeline.
* Third, it transforms it into Plutus Core (Plutus). This is an
intermediate form that the compiler uses to statically check the
program.
* Fourth, we get to untyped Plutus Core, which the Cardano node runs to
validate the transaction. This language is hard to code directly, and it
is usually stored in binary representation. It is wise to break down
compilation pipelines by introducing intermediate languages to ensure no
step is too large, and to test each step independently.

For more information about the compilation process, refer to
https://iohk.io/en/blog/posts/2021/02/02/plutus-tx-compiling-haskell-into-plutus-core/[this
blog post].

You can also use a different high-level language if you have a compiler
that compiles to untyped Plutus. Some community members are doing
exactly this by replacing parts -or all- of the compilation pipeline.
Validators can be coded in pre-existing languages like Typescript
(https://github.com/HarmonicLabs/plu-ts[Plu-ts]) or Python
(https://opshin.dev/[OpShin]), or they can be coded in completely new
languages like https://aiken-lang.org/[Aiken]. A comparison of Aiken
and Plinth (the most used smart contract languages on Cardano as of
2023) is presented in section <<Plinth in comparison to Aiken>>.

The choice of Haskell enabled the research and engineering teams that
work on Cardano to reuse the existing Haskell infrastructure, libraries,
and tools that enable developers to build high-assurance software. To
assess the security of the Plutus language, formal methods were used
that are the most stringent form of reasoning about code correctness.
Formal methods are mathematically rigorous techniques for
the https://en.wikipedia.org/wiki/Formal_specification[specification],
development, https://en.wikipedia.org/wiki/Program_analysis[analysis],
and https://en.wikipedia.org/wiki/Formal_verification[verification] of
software and hardware systems. They are not well suited for any
arbitrary programming language but work well with pure functional
programming languages such as Haskell. With formal methods, one can
mathematically prove that the software under evaluation is correct and
does exactly what it is supposed to do.

In the process of formalizing Plutus, first starting with the paper
specification of the language, the semantics of the language were
formalized, and then the properties of the language were proven to
indicate that the design of the language was correct. Semantics are
given first by describing the reduction semantics of the language with
https://en.wikipedia.org/wiki/Operational_semantics#Structural_operational_semantics[Structural
Operational Semantics] (SOS). Then, the semantics on an abstract
machine (the https://en.wikipedia.org/wiki/CEK_Machine[CEK machine])
are given and shown as equivalent to the SOS. Other properties are also
shown. For example, the soundness and correctness of the typing system.
From this formal specification, an executable is produced by compiling
the specification into Haskell. This executable is a *reference
implementation* that behaves correctly (by definition), but it's not
efficient enough to be used in production. Then, real (efficient)
implementations can compare their results against those of the reference
implementation. This is done by automated testing in the conformance
test suite. The production code is tested against the reference
implementation. The https://github.com/IntersectMBO/plutus[Plutus]
repository contains the formalization of Plutus in Agda. The project is
located in the _plutus-metatheory_ folder. You can read more about
formal methods and functional programming in section 
<<Using functional programming and formal methods>>.

Besides formal methods, property-based testing is also used to deliver
high-assurance software for Cardano. For Haskell code, property-based
tests can be written using Haskell libraries such as
https://hackage.haskell.org/package/QuickCheck[QuickCheck] or
https://hackage.haskell.org/package/hedgehog[Hedgehog], which allow
developers to state properties that should always be in a program. Those
libraries use sophisticated algorithms to generate test cases and search
for minimal counterexamples that violate those properties.
https://iohk.io/en/blog/posts/2020/04/09/merging-formal-methods-and-agile-to-build-cardano/[This
blog post] further explains that for code interacting with the external
world, particularly network applications such as the Cardano node, it
can be hard to find minimal counterexamples. This is attributed to the
fact that the execution order is not deterministic because it can change
every time the software runs. In other words, the same code can be run
hundreds of times and only fail once. The blog post explains that a way
to get around this is by using simulations with deterministic execution
order. Running tests in such a simulation allows to reliably find and
fix a class of bugs in testing, which would otherwise only occur
randomly in production.

Formal verification and property-based testing can also be used to
secure the development of smart contracts. While Haskell is a great
programming language for implementing reliable software, it can not
catch all possible mistakes a programmer can make, so the code still
needs to be tested. Details on how to write property-based tests for
Plinth smart contracts can be found in the <<Testing Plinth scripts>> 
section, where we showcase how to property test smart contracts
using the https://github.com/mlabs-haskell/plutus-simple-model[Plutus
Simple Model] library developed by MLabs and the QuickCheck library.
Another library one can use for property testing Plinth smart contracts
is the https://github.com/tweag/cooked-validators[Cooked validators]
library developed by Tweag. IO also developed the
https://github.com/input-output-hk/quickcheck-contractmodel[Contract
Model] QuickCheck extension, which uses the off-chain code and a
specification of what should happen to test traces of transactions. It
also comes with some common vulnerabilities already modeled. Double
satisfaction, for example, means users don't have to implement them and
can check them by simply adding one line to their tests.

The test framework of the https://atlas-app.io/[Atlas] application
backend also uses the Plutus Simple Model. Atlas is a popular open
source library that covers all functionalities needed to work with
Plinth smart contracts and enables writing the complete server side code
in Haskell. It was developed by the company
https://www.geniusyield.co/[GeniusYield] in collaboration with other
companies such as MLabs, Well-Typed, and Plank. It significantly
abstracts away the complexity of building Cardano transactions and
interacting with Plinth smart contracts. Different data providers can be
configured to power the Atlas framework. It streamlines the process of
building transactions and executing smart contracts and provides the
following benefits:

* Developers can easily build transactions by using an intuitive API to
abstract away the complexity around building transactions, balancing
UTXOs, and interfacing with Plinth smart contracts.
* It leverages Haskell to avoid code duplication between on-chain and
off-chain code. Developers can use advanced functionalities offered by
IO Cardano/Plinth libraries, and easily convert between Atlas and
Cardano/Plinth types.
* It utilizes modular data providers. Developers can query ledger state
information from Maestro, a local node, Cardano DB Sync, or build an own
data provider.
* It enables writing realistic unit tests that correspond to on-chain
behavior and execute integration tests against the Cardano node in a
private network.
* It stays up to date, so developers benefit from Cardano's latest
innovations such as reference inputs, inline datums, and reference
scripts.

For testing smart contracts, third-party auditing companies can write
the tests as part of their auditing process of DApp smart contracts and
server-side code. Their auditing services may also include formal
verification. For Cardano DApps, companies such as Tweag, MLabs, Runtime
Verification, Hachi, Vacuumlabs, FYEO Inc., Anastasia Labs, TxPipe, and
some others offer Cardano auditing services. IO is also working with
some of these companies on a certification program for DApps running on
Cardano. The program creates three levels of certification for DApps in
a store.

* Level 1: automated tooling
* Level 2: in-depth audit
* Level 3: formal verification.

The below descriptions were originally included in
https://iohk.io/en/blog/posts/2021/10/25/new-certification-levels-for-smart-contracts-on-cardano/[this
blog post]:

* *Automated tooling* will give continual assurance about a range of
properties for smart contracts. It covers the discovery of different
types of issues or bugs and is characterized as low cost, low effort,
and accessible to everyone while providing a substantial level of
assurance. It can be applied repeatedly and automatically, so each time
there is a release or a sub-release of an application, the application
can be tested to confirm it still has the expected properties that.
* *In-depth audit* looks at the technology and processes that led to it
being produced. It involves a manual audit and verification of smart
contracts within the DApp itself. The testing is performed at a much
deeper level and involves more manual effort than can address a DApp in
its entirety, even if it is written in a variety of languages.
* *Formal verification* is more specialized, where the auditor aims to
provide full assurance of critical aspects of applications through
formal verification of smart contracts. Formal verification involves
ensuring that a smart contract serves the specific business or technical
requirements defined at the outset.

When using formal verification for smart contracts, the general
procedure is to first define the model that serves as an exact
representation of the smart contract behavior. Then, the smart
contract’s specifications are defined in a language that both the model
and the verification tools can comprehend. After that, the process of
verification can start, where mathematical tools and logic are used to
prove the correctness of the defined assumptions. In the end, the
results of the verification process are analyzed, and issues are
addressed. No matter the audit type, the company requesting it has to
provide a standard set of documents and information:

* General specification and design documents that unambiguously describe
the architecture, interfaces, and requirements characterizing the DApp.
* On-chain specification that clearly specifies the smart contract
properties.
* Off-chain specification that describes the expected behavior
(assumptions, constraints, and requirements) for all interfacing
components of the DApp.
* A description of how the DApp has been tested, together with the
results of the tests, and details of how those test results can be
replicated.
* A final version of the source code together with versioning
information.

You can read further details of the above points in
https://cips.cardano.org/cip/CIP-52[CIP-0052],
which defines guidelines and best practices for auditing DApps built on
Cardano. Furthermore, https://cips.cardano.org/cip/CIP-57[CIP-0057]
defines a language specification for documenting Plutus contracts
through the form of a JSON schema that sets the vocabulary and
validation rules to specify the Plutus contract interface. This enables
a better understanding of Plutus smart contracts written in any of the
high-level languages that compile to Plutus. It allows for the
development of tools that generate contract API references and
documentation. DApp developers also make their contracts easier to audit
as they can specify the expected behavior, and the auditing information
is provided in a more standardized way.

Different companies may use different approaches to perform smart
contract audits. Sometimes, auditing companies publicly disclose their
methodology.
https://www.tweag.io/blog/2023-05-11-audit-smart-contract/[This Tweag
blog post] presents the auditing process in their company. Beside
auditing smart contracts, other parts of a DApp can be audited. The
off-chain code, the backend, and the frontend of the DApps webpage, for
example. After the audit process, the vulnerabilities are usually
identified and grouped into categories:

* *Critical vulnerabilities* that pose a big risk for the DApp
* *High vulnerabilities* that may affect a large portion of the DApp’s
security
* *Medium vulnerabilities* are issues that affect the proper working
of a DApp but are not security threats that would need immediate action
* *Low vulnerabilities* that may affect things such as performance
but pose no risk to security.

Examples of common security vulnerabilities in Plutus smart contracts
are:

* other redeemer
* other token name
* arbitrary datum
* unbounded datum
* unbounded value
* unbounded inputs
* multiple satisfaction
* missing UTXO authentication
* UTXO contention
* cheap spam
* insufficient staking key control.

This
https://library.mlabs.city/common-plutus-security-vulnerabilities[MLabs
guide] describes each vulnerability by a property statement, test,
impact, and further explanation. Audit reports are often made publicly
available for the community to read because they are a great tool for
learning what mistakes not to make when developing a DApp. Also, the
company that ordered the audit increases the transparency of their
software. If it allows that, the audit report becomes publicly available
for the community to read. Below are links to repositories from the
auditing companies Tweag and Vacuumlabs that made some of their audit
reports freely available to the public:

* https://github.com/tweag/tweag-audit-reports[Tweag audit reports]
* https://github.com/vacuumlabs/audits[Vacuum Labs audit reports].

=== Plutus best practices

Will be written by Tsenguun.

=== Marlowe security

In the design process of the Marlowe smart contract language, trade-offs
were made in regard to how powerful the language should be. In computer
science, the https://en.wikipedia.org/wiki/Halting_problem[Halting
problem] states that it is impossible to write a program that takes as
input another program written in a Turing-complete programming language,
and decides whether that program will stop or not. Such programming
languages are so powerful that it is difficult or impossible to
automatically analyze programs written in them. You always have to write
tests or use other methods as formal verification to check certain
properties of such programs. In practice, for a large class of programs,
it may be possible to have automated tools, but there can be no general
tools that decide whether the program stops or not. This is only one
example of undecidability. More often, the security properties of the
program need to be checked and proven that the program behaves as
expected. On the other hand, if you are willing not to have
Turing-completeness, you can have simple but powerful program analysis
tools and program language built-in security features. Powerful analysis
tools also exist for Turing-complete programs; they are just more
complex to build, and such programs have fewer built-in security
features.

Marlowe is not a Turing-complete language, so you cannot express
arbitrary logic in it. This gives the option to statically analyze how
long a contract will run. All Marlowe contracts are guaranteed to have a
finite lifetime. There are other things Marlowe contracts take care of,
such as ensuring that no funds are forever locked in a contract. In
Cardano’s implementation of Marlowe, there is an edge case where it is
possible to lock funds by creating a contract that exceeds the
limitations of the blockchain, for example, by making too many external
payments in the same transaction. The chapter _Tools for Detecting
Potential Locking/Blocking of Marlowe_ in the
https://www.google.com/url?q=https://github.com/input-output-hk/marlowe-cardano/blob/d73ecdc0b05836eacf66a157dad785b541669d9d/marlowe/best-practices.md%23tools-for-detecting-potential-lockingblocking-of-marlowe-on-cardano&sa=D&source=docs&ust=1710169345676571&usg=AOvVaw1LUgqEGLs9N71F5AcXSMYD[Marlowe
best practices] page explains how to prevent such a scenario. In the
real world, you can enforce contracts by using the legal system or
financial regulations. However, due to the decentralized nature of the
blockchain, this may not be possible. When you use Marlowe to create a
smart contract, you can’t force anyone to make a payment that fulfills a
contract. Marlowe considers that and implements a finite lifetime
mechanism to wait for someone to make a payment. If the contract is
waiting for an action, like a payment, and that action does not happen,
the finite lifetime mechanism enables a timeout mechanism that always
says what action can happen when the timeout is reached. Marlowe
provides the following safety guarantees:

* Execution always terminates
* Contracts expire eventually and deterministically
* No assets retained when the contract reaches its final state
* Conservation of value.

The safety-first principle used in Marlowe's design has limited its
functionality for a good reason. There are two additional limitations
considered when a Marlowe contract is created:

{empty}(1) the number of participants in a contract is limited to the
predetermined amount when the contract was designed;

{empty}(2) existing Marlowe contract logic cannot be revised. To ensure
the above-mentioned safety guarantees, the following programming
language constructs are absent from the Marlowe language to ensure
Marlowe’s safety:

* Recursion is not allowed.
* Looping is not supported.
* Functions or macros may not be defined.
* Timeouts must be numeric constants.
* Only *Case* continuations may be merkleized. The Faustus programming
language relaxes some of the limitations above, yet it compiles to safe
Marlowe. Besides Faustus, you can ‘relax’ the above limitations if you
embed Marlowe into another language (JavaScript, for example). By using
the TS-SDK, you can have JavaScript functions and loops that unfold a
larger Marlowe contract.

Merkleization is the process of constructing
https://en.wikipedia.org/wiki/Merkle_tree[Merkle trees] that can be
used to verify any kind of data stored, handled, and transferred in and
between computers. It enables large smart contracts to be concisely
represented on-chain. Instead of storing gigabytes of data representing
a huge contract, only the hash of that contract needs to be represented
on-chain. You can learn more about merkleization in Marlowe in
https://www.youtube.com/watch?v=e6vdq5GN5Q8[a video from IO Academy].
Merkleization is hidden through the Marlowe object concept, and you can
read about the marlowe-object package in its
https://github.com/input-output-hk/marlowe-ts-sdk/tree/main/packages/marlowe-object[frontend
documentation]. The
https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe-object/doc/object-format.md[Marlowe
Object Format] is a way to describe a Marlowe contract as a set of
labeled objects that reference one another, which can be linked to
create a Marlowe contract. The term comes from the object files produced
by a compiler, which can be linked to create an executable program.

Marlowe also contains additional constraints imposed by Cardano:

[arabic]
. No more than one Marlowe contract may be run in a single Marlowe
transaction
. Token names are limited to 32 bytes
. An invalid initial state will prevent a Marlowe contract from
executing properly on Cardano. Some of the smart contract execution
paths may be blocked
. Each transaction output on the Cardano ledger must include a minimum
lovelace value in the UTXO
. Because the Cardano ledger contains a rule that the size (in words) of
the bytes storing the information about native tokens in a UTXO cannot
exceed the protocol parameter maxValueSize, there is a limit to the
number of different types of tokens that can be held in a single UTXO
. The size (in bytes) of a transaction is limited by a Cardano ledger
rule specified by the protocol parameter maxTxSize
. If a Marlowe contract does too much computation or uses too much
memory in a transaction, it may violate the rule that execution costs in
Plutus are limited to specific usage of ‘memory’ and CPU ‘steps’.

You can look up the
https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe/best-practices.md[Marlowe
best practices guide] to read more about these limitations. While
Marlowe contracts might run on the Playground, they would not run
on-chain if the contract violates the
https://cardano-ledger.readthedocs.io/en/latest/[Cardano ledger
restrictions]. You can check a Marlowe contract for compatibility with
the Cardano ledger rules by using the _marlowe-cli run analyze_ command.
The Marlowe CLI
https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe-cli/ReadMe.md[GitHub
page] provides additional information about this topic.

The following properties regarding the safety of Marlowe were proven
using formal methods:

* Conservation of funds
* Contracts always terminate
* Positivity of account balances
* Quiescence
* Idempotency of reductions
* Composition of inputs.

The formal specification and proofs for the Marlowe language were made
using the Isabelle proof assistant, which can be used for formal
software verification. The proofs were audited and can be found in the
https://github.com/input-output-hk/marlowe[Marlowe GitHub repository].
This repository also contains the
https://github.com/input-output-hk/marlowe/tree/master/marlowe-spec-test[marlowe-spec]
software tool, with which a Marlowe interpreter written in any smart
contract language can be validated for compliance with the Marlowe
formal specifications. The specifications can be found in the
marlowe-cardano 
https://github.com/input-output-hk/marlowe-cardano/tree/main/marlowe/specification[GitHub repository] 
that contains the official Cardano implementation of
Marlowe. The Marlowe interpreter and the role-payout validator are
implemented as Plinth scripts and can be found in the
marlowe-plutus https://github.com/input-output-hk/marlowe-plutus[GitHub
repository], which also provides instructions on how to compile the
scripts.

The auditing company Tweag performed an audit of the Marlowe high-level
language and the implementation of Marlowe on Cardano before Marlowe's
deployment on mainnet. The audit discovered significant issues,
including handling of negative deposits, prevention of ‘double
satisfaction’, enforcement of state invariants, an implementation
difference between formal specification versus the Plinth
implementation, and the proof of money preservation theorem. The issues
were addressed before deploying Marlowe on mainnet. The full
https://github.com/tweag/tweag-audit-reports/blob/main/Marlowe-2023-03.pdf[audit
report] can be found at Tweag’s GitHub page. IO also issued a report on
the
https://github.com/input-output-hk/marlowe/blob/master/response-to-audit-report.md[Marlowe
GitHub page] explaining the actions taken. You can read a short
description of the issues and how they were addressed
https://iohk.io/en/blog/posts/2023/06/27/a-comprehensive-guide-to-marlowes-security-audit-outcomes-built-in-functional-restrictions-and-ledger-security-features/[in
this blog post], which also talks about the security of Marlowe and
Cardano.

=== Marlowe best practices

Marlowe contracts can be designed in many ways. Once you have designed
your contract, it is good practice to simulate it on the Playground
first and create a walkthrough of all possible execution paths. The
Playground also offers a set of tools that can perform a static analysis
of the contract. No matter the Playground programming language you
choose, the tools can be accessed from the bottom bar in the Static
Analysis tab. Once you click on it, the analysis console opens up,
displaying a section on the right-hand side where you can set the
contract input parameters. Then, you can make three possible analyses:

* Analyze for warnings
* Analyze reachability
* Analyze for refunds on Close.

The analysis for warnings action analyzes the contract for potential
mistakes a smart contract designer could make. An example of a warning
would be that a contract would try to pay an amount of ada to a party
that exceeds the total amount of ada that the contract is holding at the
time of the payment action. The analysis will produce a description of
the warning, and it will display an _offending sequence_ that shows the
contract actions leading to the warning. The reachability analysis
action analyzes if any unreachable subcontracts exist. In other words,
it checks if an execution path of the smart contract exists that cannot
be reached with any possible transaction. The analysis for refunds on
Close action analyzes if any of the Close constructs refund any money.
That means it checks if all refunds are explicitly stated in the
contract or if some happened because funds remain in the contract when
it reaches the end of any possible execution path. Even if funds remain,
this does not represent an issue since its owners can redeem the funds
because no funds are locked by the contract indefinitely.

Besides being a smart contract programming language, Marlowe is also an
ecosystem of tools to enable the deployment, interaction, and analysis
of Marlowe smart contracts. Formal proofs, extensive testing, and
analysis tools provide strong assurances for the safety of Marlowe
contracts. Marlowe Runtime, which is used under the hood by the TS-SDK,
provides off-chain services that discover Marlowe's contract history and
build transactions that apply input to Marlowe's contracts. If a project
using the TS-SDK decides to deploy its own instance of Marlowe Runtime,
precautions should be taken if there is an interest in examining the
Marlowe transactions produced by the Runtime. If Marlowe Runtime is
deployed as part of a web service, then one must be aware of the
possibility of person-in-the-middle, cross-site scripting, and other
attacks. Marlowe Runtime contains a registry of known Marlowe script
versions that it uses to create new Marlowe transactions. One should
only use Marlowe Runtime to create contracts if one trusts the script
hashes in that registry. The Marlowe test suite verifies that the script
registry has not been inadvertently or maliciously altered. Of course,
this does not guarantee that the test itself has not been altered.

Another Marlowe tool is the Marlowe CLI, which includes capabilities for
analyzing the suitability of a Marlowe contract for execution on the
Cardano blockchain. As mentioned in the previous section, the
_marlowe-cli run analyze_ command enables a smart contract designer to
check that his contract does not violate any of the
https://cardano-ledger.readthedocs.io/en/latest/[Cardano ledger
restrictions]. Its command line interface allows the user to select
which checks to perform, and its output highlights the causes and
location of violations. It is important to realize that the tool tests
whether or not it is _possible_ to avoid violating the ledger rules in
executing a contract. This does not mean that it is _trivial_ to
construct every valid transaction for the contract. Further details can
also be found in the
https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe/best-practices.md[Marlowe
best practices guide], which explains how to avoid protocol limits when
designing Marlowe contracts in the following cases:

[arabic, start=1]
. Choose role and token names that are no longer than 32 bytes
. Ensure that the contract's initial state is valid
. Ensure that the initial value in the contract contains sufficient
lovelace
. Avoid contracts that use an excessive number of native token types
. Avoid or break up complex logic in the contract
. Use reference scripts and merkleization to reduce on-chain size
. Be parsimonious in the use of the contract's internal state.

Look up the
https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe/debugging-cookbook.md[Marlowe
debugging cookbook] for technical approaches on how to debug Marlowe
contracts on Cardano. Some types of contracts are not well suited for
using Marlowe on the Cardano blockchain, including:

* Contracts that contain timeouts spaced close to the Cardano block
production rate
* Contracts that require floating point arithmetic
* Contracts that require many bound values in their internal state
* Contracts that make many differently named choices by many parties
* Contracts that have many alternative and simultaneous actions
possible. For example, a distributed exchange (DEX), order book, market
maker, or token marketplace would be poorly suited for Marlowe unless
the Marlowe contracts were supervised by Plinth contracts or
semi-centralized off-chain infrastructure.

Also, security and best practices should be taken into account when
constructing transactions targeting a Marlowe contract. A user should be
able to answer the following questions before signing a Marlowe
transaction:

* Does the transaction operate a Marlowe contract?
* What is the current contract and what is its state?
* What input is being applied to the contract?
* What else is occurring in the transaction?

The
https://github.com/input-output-hk/marlowe-cardano/blob/main/marlowe/security.md[Marlowe
security guide] answers all these questions in detail. As a conclusion,
when developing a Marlowe smart contract, one should:

* Use the https://playground.marlowe-lang.org/#/[Marlowe Playground] to
simulate the contract and perform static analysis
* Use the _marlowe-cli run analyze_ tool to check if the contract can
run on the Cardano network and does not violate any of the Cardano
ledger rules
* Read and understand the Marlowe guides referenced in this section and
check if the Marlowe smart contract satisfies all criteria
* Test off-chain code by running all execution paths of the contract on
a Cardano testnet. You can read more about the Cardano testnet at
https://docs.cardano.org/cardano-testnet/overview[Cardano docs].
