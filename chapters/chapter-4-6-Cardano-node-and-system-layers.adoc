== Cardano node and system layers

:url-repo: https://github.com/input-output-hk/mastering-cardano/chapters
:imagesdir: images

=== Introduction to the Cardano node

The Cardano blockchain is powered by a network of interconnected nodes.
A Cardano node is a fundamental, top-level component of this network,
serving as a device running specific software that helps maintain and
secure the system.

Nodes connect to each other within the networking layer, which is the
driving force for delivering information exchange requirements. Cardano
nodes maintain connections with peers that have been chosen via a custom
peer-selection process. By running a Cardano node, you are participating
in and contributing to the network.

The custom peer-selection process in Cardano nodes is designed to
enhance the network's decentralization, security, and resilience. Here's
a brief overview of how it works:

* *Dynamic peer-to-peer (P2P) networking.* Cardano nodes use a dynamic
P2P networking system. This system automates the peer selection process,
allowing nodes to maintain a specific number of active peer connections.
If a connection with a peer is lost, the node will automatically select
alternative peers and persistently attempt connections until the desired
target is reached.
* *Elimination of static configurations.* The dynamic P2P system
eliminates the need for static configurations and manual input from
stake pool operators (SPOs). This simplifies the process of running
relay and block-producing nodes.
* *Enhanced communication.* By automating the peer selection process,
dynamic P2P enables enhanced communication between distributed nodes,
ensuring better data synchronization and consensus among participants.

These features collectively contribute to the robustness and efficiency
of the Cardano network. As a critical piece of the Cardano blockchain, a 
node performs several essential functions:

* *Validating transactions.* Whenever a transaction, such as sending
ada, occurs on the Cardano blockchain, nodes are responsible for
verifying and validating it. This process ensures that all transactions
are legitimate and prevents double-spending.
* *Maintaining the blockchain.* The blockchain is a distributed ledger
that records all transactions on the network. Nodes maintain an
up-to-date and accurate copy of this ledger, continuously adding new
blocks of transactions, which explains the term "blockchain".
* *Propagating information.* Nodes communicate with each other to share
information about transactions and blocks. When a new transaction or
block is verified, nodes propagate (or share) this information across
the network, ensuring consistency and synchronization among all nodes.

A node in the Cardano blockchain is implemented by a software called
https://github.com/IntersectMBO/cardano-node[cardano-node]. The
cardano-node software is the backbone of the Cardano blockchain network.
It is a crucial piece of software that runs on each node, enabling them
to perform their essential functions. To fully understand the role of
the cardano-node software and its relationship with Cardano nodes, let's
dive into its key aspects and functionalities.

The cardano-node software was originally developed by IO, one of the
companies that pioneered Cardano. This software is designed to run on
computers (nodes) and allows them to interact with the Cardano
blockchain. It is written in the Haskell programming language, known for
its robustness and security features.

The relationship between the cardano-node software and Cardano nodes can
be compared to the relationship between an operating system and a
computer. Just as an operating system enables a computer to perform its
functions, the cardano-node software allows nodes to interact with other
nodes and perform their roles. There are several types of nodes, each
with specific roles and responsibilities:

* *Relay nodes.* These nodes are responsible for maintaining connections
with other nodes in the network. They relay (propagate) information such as
transactions and blocks between nodes, ensuring the network remains
synchronized.
* *Block-producing nodes.* These nodes are responsible for producing new
blocks and adding them to the blockchain. They are typically operated by
stake pools, which are groups of stakeholders who combine their
resources to increase their chances of being selected to produce a
block.
* *Edge nodes.* These nodes interact with end-users and applications.
They provide interfaces for users to submit transactions and query the
blockchain. Edge nodes do not produce blocks but play a crucial role in
facilitating user interactions with the blockchain.
* *Stake pool nodes.* These are specialized block-producing nodes that
are part of a stake pool. They validate transactions, produce blocks,
and maintain the combined stake of various stakeholders in a single
entity.

Each of these node types plays a vital role in ensuring the security,
stability, and efficiency of the Cardano blockchain.

*Key features of the cardano-node software*

The cardano-node software undergoes constant development and updates, so
the key features presented here provide an overview of its capabilities.
For the latest information, please refer to the
https://developers.cardano.org/[Cardano developers' website].

* *Blockchain synchronization.* Blockchain
synchronization in Cardano uses the cardano-node software and involves a
series of protocols and processes to ensure that all nodes maintain an
up-to-date copy of the blockchain. Synchronization relies on
mini-protocols like chain-sync, block-fetch, and tx-submission for data
exchange. Nodes communicate using node-to-node and node-to-client
Inter-Process Communication (IPC) protocols, facilitating the exchange
of blocks, transactions, and ledger state queries. This continuous
synchronization ensures that the local database remains current with the
latest blockchain data, maintaining the integrity and consistency of the
Cardano network.
* *Transaction validation.* One of the primary roles of
cardano-node is to validate transactions. When a user initiates a
transaction, the node software checks the transaction's validity. This
involves verifying that the sender has enough ada to cover the
transaction and ensuring that the transaction follows the network's
rules.
* *Block production and validation.* The
cardano-node software creates new blocks for nodes participating in
block production (such as stake pool nodes). It compiles validated
transactions into blocks and adds them to the blockchain. Additionally,
it validates new blocks produced by other nodes to ensure they are
legitimate.
* *Network communication.* The cardano-node facilitates
communication between nodes. It propagates information about new
transactions and blocks across the network, ensuring all nodes remain
synchronized. This P2P communication is vital for maintaining the
network's decentralized nature.
* *Consensus participation.* Cardano uses a
proof-of-stake consensus mechanism called Ouroboros. The cardano-node
software enables nodes to participate in this consensus process. Stake
pool nodes, in particular, play a significant role in producing new
blocks and validating transactions based on their stake in the network.
* *Monitoring and reporting.* The cardano-node software
provides various monitoring and reporting tools that allow node
operators to track the performance and health of their nodes. This
includes metrics on block production, network connectivity, and resource
usage.

If you are interested in installing and running a node, please refer to
the node documentation on the https://developers.cardano.org/[Cardano
developers’ website]. All node configuration files can be found on the
https://book.world.dev.cardano.org/[Cardano operations book] website.

*Cardano node design principles*

In proof-of-stake systems, the costs for an attacker producing data and
for a defender verifying this data are more balanced than in
proof-of-work systems, where the attacker’s costs for producing data are
significantly higher than the defender’s costs for verification.

This motivated many design principles of the Cardano node, such as:

* Designing for worst-case complexity in adversarial conditions
* Relying solely on local or trusted information
* Minimizing the difference in memory use between typical and worst-case
scenarios
* Ensuring graceful degradation under excess load.

The Cardano node was designed to mitigate potential attacks that could
overload a node, force it to accept bad data, or block its interactions
with other nodes. These attacks might target a single node during
network synchronization or block production. Additionally, the design
aims to mitigate distributed attacks aimed at a significant portion of
block-producing nodes. Each version of the Cardano node comes as a
single package, usable by both stake pool operators for block production
and by users running the node for other purposes, such as network
synchronization and transaction management. This approach ensures that
security features are consistent across both block-producing and
non-producing nodes.

You can find more information on the design principles and decisions in
the https://www.youtube.com/watch?v=PKzkzqUB8e0[Cardano architecture]
video lecture by Duncan Coutts Cardano’s chief technical architect.

=== Cardano node layers

The Cardano node performs several functions that can be categorized into
three layers:

* network layer
* consensus and storage layer
* settlement and scripting layer.

A Cardano node layer is represented by a set of libraries that target
specific functionalities, such as networking, consensus, or settlement.
The consensus and storage layer, often referred to as the consensus
layer, and the settlement and scripting layer, known as the ledger
layer, are two distinct components that do not depend on each other.
These layers are integrated through a consensus/ledger integration
layer, which configures how the consensus protocol interacts with the
ledger rules. On the other hand, the network layer is more closely
integrated with the consensus layer, with the boundary between these two
being less distinct compared to the clear separation between the
consensus and ledger layers. A simple diagram below represents these
node layers:

image:node_internals.png[image,width=700,height=340]

The Cardano node also contains an additional layer called the
https://github.com/input-output-hk/cardano-shell[node shell], which
manages various functions surrounding the node, namely:

* logging
* monitoring
* configuration
* exception handling
* node startup.

*Network layer*

The network layer maintains the connections between all the distributed
nodes in the Cardano network. It handles communication protocol details
and peer selection, obtaining new blocks from the network as they are
produced by block-producing nodes and transmitting them between nodes.
This layer is a P2P system, with Cardano nodes maintaining connections
with peers chosen via a custom peer selection process. Specifically
designed for proof-of-stake systems, the network layer includes a
framework for writing typed protocols, supporting pipelining,
multiplexing, and various protections against adversarial peers.

The https://github.com/IntersectMBO/ouroboros-network[Ouroboros
network] repository contains specifications of network protocols and
implementations of the network components that run these protocols.
These components support a family of Ouroboros consensus protocols. The
official
https://docs.cardano.org/about-cardano/explore-more/cardano-network/[network
documentation] explains the data flow between and within Cardano nodes
and the network constraints, such as congestion control and real-time
coordination. It also lists types of mini-protocols that are used to
communicate between multiple nodes participating in the Cardano network.
You can read more about network protocols in chapter 
<<Overview of Cardano network protocols>>.

*Consensus and storage layer*

The consensus and storage layer operates the Ouroboros blockchain
consensus protocol. In a blockchain context, consensus ensures that all
participants agree on the one true version of the chain. The consensus
layer is responsible for making key decisions about the chain,
including:

* adopting blocks and determining when to produce new blocks
* choosing between competing chains, if there are any
* selecting slot leaders to produce blocks
* coordinating the interaction between the network and ledger layers.

The consensus layer also maintains all the necessary state to perform
these tasks. The Ouroboros consensus algorithm, embedded in the
consensus layer, sets block adoption and production rules. To adopt a
block, the protocol must validate it against the current state of the
ledger. The storage layer provides efficient access to:

* the current ledger state
* recent past ledger states; useful when switching and validating
competing chains
* direct access to blocks, facilitating efficient streaming to clients.

*Block production* occurs within the consensus layer, and to produce
blocks, this layer must also maintain a memory pool (mempool) of
transactions to be inserted into those blocks. For more details about
block production, read chapters <<Reaching consensus using proof of stake>>, 
and <<About the Ouroboros protocol>>.

The problem of *chain selection* arises when two or more nodes extend
the chain with different blocks. This can happen when nodes are unaware
of each other’s blocks due to temporary network delays or partitioning.
This situation can also occur under normal conditions depending on the
consensus algorithm. When it does, the consensus protocol is responsible
for choosing between these competing chains. If the protocol switches to
a different chain (a different tine of a fork), it must retain enough
history to reconstruct the ledger state on that chain.

An important task of the consensus layer is *selecting slot leaders*. In
proof-of-work blockchains, any node can produce a block at any time,
provided that they have sufficient hashing power. By contrast, in proof
of stake, time is divided into slots, and each slot has a number of
designated slot leaders who can produce blocks in that slot. It is the
responsibility of the consensus protocol to decide to assign slot
leaders to slots. Further explanations can be found in the
proof-of-stake and Ouroboros chapters.

The consensus layer also *orchestrates* between the network and ledger
layers. The network layer primarily transmits blocks and block headers,
but does not interpret them. In a few cases, it relies on the consensus
layer when making some block-specific decisions. The ledger layer deals
only with high-level concerns, meaning it describes how the ledger state
is transformed by valid blocks. It only sees a linear history and is
unaware of multiple competing chains or the rollbacks required when
switching from one chain to another. The consensus layer mediates
between these layers and decides which chain is preferable and should be
adopted.

The consensus layer was designed not only to perform the above-mentioned
tasks, but also to emphasize the *compositionality*, making it usable
with many different consensus algorithms and ledgers. This enables the
_hard fork combinator (HFC)_ technology that allows combining multiple
ledgers and regard them as a single blockchain. Because of the hard fork
combinator, a new node version designed for the latest ledger era also
understands all previous eras. This capability ensures that previous
versions of Plutus scripts remain supported by the node even when Plutus
is upgraded. The HFC enables smooth protocol upgrades without disruption
for users and also preserves the chain history of all operations. You
can read more about it in the
https://iohk.io/en/blog/posts/2020/05/07/combinator-makes-easy-work-of-shelley-hard-fork/[hard
fork combinator] blog.

Generally, the term _hard fork_ describes a radical change from one
protocol to another. In most blockchains, a hard fork indicates block
changes or a change to their interpretation. Traditionally, when a
blockchain hard fork happens, the current protocol stops operating, and
new rules and changes are implemented, resulting in the chain restart.
There is no backward compatibility, and the old version of the protocol
can not be used in parallel with the new version for the same
blockchain. The term soft fork is used if the protocol changes are
compatible with the previous versions.

The HFC technology allows for the combination of two incompatible
protocols into one, resulting in a sequential combination of the two
protocols. This enables Cardano to integrate blocks from all development
phases. Furthermore, the entire network – comprising all connected
Cardano nodes – can upgrade gradually, eliminating the need for
simultaneous upgrades. Nevertheless, a hard fork still needs to be
triggered, and the mechanism to do this will change from the
genesis-key-based mechanism to the one defined in
https://cips.cardano.org/cip/CIP-1694[CIP-1694]. The genesis key
mechanism requires that 70% of all SPOs first upgrade to the new node
version, and then a consensus of five out of seven genesis keys needs to
be reached to trigger the hard fork. The genesis keys were distributed
such that three belong to IO, two to Emurgo, and two to the Cardano
Foundation. After the acceptance of CIP-1694, genesis keys won’t be used
anymore. SPOs will still play a crucial role in Cardano upgrades, and
will always be free to decide whether they want to upgrade their nodes
to a new version that would signal the acceptance of a proposed hard
fork.

In addition to compositionality, other design goals of the consensus
layer include:

* support for multiple consensus protocols
* compatibility with multiple ledgers
* decoupling the consensus protocol from the ledger
* enhancing testability
* ensuring adaptability and maintainability
* delivering predictable performance
* providing protection against denial-of-service (DoS) attacks.

You can read more about these goals in the Cardano consensus and storage
layer
https://ouroboros-consensus.cardano.intersectmbo.org/pdfs/report.pdf[technical
report], which targets more experienced developers.
This report explains how the goals were achieved, identifies areas for
improvement, and presents how the design of this layer can scale to meet
future requirements.
https://iohk.io/en/blog/posts/2020/05/28/the-abstract-nature-of-the-consensus-layer/[The
abstract nature of the Cardano consensus layer] blog also elaborates on
these goals and provides simple code examples.

*Settlement and scripting layers*

The settlement and scripting layers form the ledger layer that defines
the rules governing blockchain data. These rules govern transaction
logic for ada and other Cardano native assets. The ledger layer has a
multi-era ledger implementation derived from a set of formal
specifications. These formal specifications define the core Cardano
components of the ledger layer and the rules for their use. The
https://github.com/IntersectMBO/cardano-ledger[Cardano ledger]
repository lists all eras and provides the formal ledger specification
for each. The
https://github.com/IntersectMBO/formal-ledger-specifications[Formal
ledger specification] repository will eventually replace it. Some
practical ledger explanations can also be found in the 
https://cardano-ledger.readthedocs.io/en/latest/[Cardano ledger documentation].

The ledger layer is stateless and consists exclusively of pure functions
that define how the ledger is updated with each new block. These
functions are derived from the formal ledger rules using the extended
UTXO accounting model. The scripting layer handles rules for smart
contract logic, such as spending, minting, staking, and certification
script logic. Transaction logic not involving smart contracts is managed
by the settlement layer, which also provides
https://developers.cardano.org/docs/get-started/cardano-cli/simple-scripts/[simple
scripts] – a basic smart contract language that enables multi-signature
addresses and time locks. An overview of Cardano smart contract
languages is covered in chapter <<Smart contract programming languages>>, 
which presents various Cardano smart contract
languages and explains the types in which they can be grouped.

The scripting layer is defined by the Plutus Core scripting language,
commonly referred to as Plutus, which provides Turing-complete
smart-contract capabilities to Cardano and can be processed by Cardano
nodes. Plutus is a typed Lambda-Calculus that acts as low-level
interpreted assembly code. The compilation pipeline from the
Haskell-based Plinth (formerly Plutus TX) smart contract language to
Plutus is explained in chapter <<Plutus security>>.

Chapter <<Writing smart contracts>>, besides providing an overview of
smart contract language options and explaining Plutus, also showcases
code examples, best practices, and learning resources for the Plinth and
Marlowe smart contract languages.
