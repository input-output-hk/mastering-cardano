
:imagesdir: ../images

[[writing-smart-contracts]]
== Writing smart contracts

[[chapter8-prefaces]]
=== Prefaces

[[chapter8-plutus-preface]]
==== Plutus preface

_Prof Philip Wadler(((Wadler, Philip))), FRS_ +
_University of Edinburgh and IO_

Smart contracts(((smart contract))) for the Cardano blockchain run in a language called
Plutus. Roughly speaking, Plutus plays the role for Cardano that the
Ethereum Virtual Machine(((EVM))) (EVM) does for Ethereum(((Ethereum))). But where the EVM
requires a dense forty-two-page yellow paper to define, the key
concepts of Plutus can be spelled out in less than one page.

The reason for this is that Plutus is based on the lambda calculus(((lambda calculus))),
first defined by the logician Alonzo Church in the 1930s, and an
elaboration of the lambda calculus(((lambda calculus))) called System F(((System F))),
first defined by the logician Jean-Yves Girard in the 1970s. To be fair, that claim is
a bit of an oversimplification. While the core of Plutus is indeed
based on those systems and can be described quite concisely, Plutus
also contains a collection of built-in operators and rules for costing,
which takes longer to spell out.

The reason for designing a language with such a tiny core is tied
closely to the needs of the Cardano blockchain. Any significant
updating of Cardano, including a change to the definition of Plutus,
requires a hard fork, and it is highly desirable to avoid these. How
do you design a system that can last unchanged for the next fifty
years? Base your design on a system that is fifty years old!

Because this fifty-year-old theory would now be executed directly on
the Cardano blockchain, carrying billions of dollars of value, there
was a business case for formally validating that theory. Input | Output
(IO)(((IO))) hired James Chapman(((Chapman, James))) to validate our variant of
System F(((System F))) in the Agda proof
assistant -- James, having written his dissertation on a related subject,
is one of the foremost experts in the field. The completed proof validated
the theory. It also gave us an executable version of
Plutus. Continuous Integration ensures the production Plutus
implementation is regularly checked against the executable formal
specification. Further, the formal specification serves as the
foundation for a new effort to write a validator that issues checkable
certificates to ensure that phases of the compiler(((compiler))) optimize code
correctly. James is now head of formal methods for IO.

Everything should be made as simple as possible, but not simpler.
Arguably, our initial simple design is too simple. It requires
representing data types as higher-order functions(((function, higher-order))),
but we had reason to believe the extra cost was negligible. Always check your
assumptions! Once the system was up and running, performance
measurements showed the cost of implementing data structures as
functions was greater than expected. So, we modified the design to
support data structures directly in Plutus Core, and the feature is
available as of version 1.1.0.

The on-chain production evaluator for Plutus is written in Haskell,
one of the most widely used functional programming languages. Plutus
is designed to represent the output of a compiler(((compiler))), and no one should
write it directly. Haskell can also be used as a source language for
creating Plutus scripts, using the Plinth language embedded into
Haskell. On Ethereum, one must learn the special-purpose language
Solidity(((Solidity))) to write smart contracts that compile to the EVM.
In contrast, on Cardano, one can use the Haskell language, designed by an
expert team of researchers thirty years ago. It has a mature and
stable core, even though it is still an actively growing research
language. The brilliant idea to apply Haskell in this way is due
to Manuel Chakravarty(((Chakravarty, Manuel))), a contributor to both
the design and implementation of Haskell.

In addition to Plinth (embedded in Haskell), a wide range of
other languages can also be used to generate smart contracts in
Plutus to run on Cardano. These include: Aiken (a stand-alone
language), Plutarch (also embedded in Haskell), Plu-ts (embedded in
TypeScript), OpShin (embedded in Python), Scalus (embedded in Scala),
Helios (which runs on top of JavaScript and TypeScript), and Pluto
(which closely resembles Plutus with added syntactic sugar for
convenience). Marlowe, which is not a general-purpose language(((language, general-purpose))) but
aims to make it easy to write certain kinds of financial contracts, is
also available.

Many people have contributed to the designs of Plutus and Plinth. I
won't attempt to name them all here because with my absent-minded
professor's memory I fear I would leave someone out. I am grateful for
the opportunity I've had to work with them and with everyone at
IO. I'm particularly grateful to Charles Hoskinson(((Hoskinson, Charles))) for the
opportunity to collaborate with IO. It's been an amazing
experience – it's not often that you can suggest a practical
application of a fifty-year-old theory and have people take you
seriously!

[[chapter8-marlowe-preface]]
==== Marlowe preface

_Prof Simon Thompson(((Thompson, Simon)))_ +
_University of Kent_ +
_Eötvös Loránd University_ +
simon.thompson@marlowe-lang.org

Marlowe(((Marlowe))) is a high-level smart contract language designed to describe
asset flows on the blockchain. Marlowe embodies a local, account-based
model and runs equally well on UTXO and account-based chains like
Ethereum(((Ethereum))). Marlowe describes fully distributed interactions between
contract participants, mediated by the underlying blockchain.

Contracts written in Marlowe automatically provide safety guarantees,
ensuring that no assets remain locked in a script indefinitely and that
no scripts run forever. Marlowe contracts can also be fully analyzed for
contract faults before execution. Marlowe on-chain validators have
been audited, and Marlowe supports contracts on both the Cardano mainnet
and pre-production testing environment.

Decentralized application (DApp) developers, small and medium-sized
enterprises, and other entities can use the Marlowe platform to develop
Cardano-based DApps. The platform provides everything needed to build
and run complete DApps on Cardano, leveraging the guarantees of Marlowe
smart contracts(((smart contract))) and integrating with Web3(((Web3)))
workflows through a TypeScript SDK. The platform includes:

* _The Marlowe Runtime(((Marlowe, runtime)))_ supports all the necessary on- and
off-chain contract actions, including the tedious work of transaction
construction and tracking contract activity by other participants.

* _The Marlowe TypeScript SDK(((TS-SDK)))_ fully integrates Marlowe as a component
within a complete DApp, including contract creation and initialization,
as well as execution.

* _The Marlowe Playground(((Marlowe, playground)))_ provides the environment for learning Marlowe
through its Blockly(((Blockly))) representation, as well as simulation and analysis
of contracts as they are developed.

* _End-to-end DApp examples_ were developed in collaboration with Gimbalabs(((Gimbalabs)))
with Catalyst Fund12(((Catalyst, Fund12))) support, and are designed to make access to the Marlowe
Platform as straightforward as possible.

* _Other components_ support free-standing execution of Marlowe smart
contracts, including the Marlowe Runner(((Marlowe, runner))) and the
Marlowe CLI(((Marlowe, CLI))).

The platform simplifies development for the developer community and
provides key components, such as oracles(((oracles))), used in many DApps. Individual
end users can also execute Marlowe contracts directly on the Cardano
blockchain, using the facilities that the Marlowe Runner(((Marlowe, runner))) and the CLI provide.
These features directly support decentralized finance (DeFi) interactions,
including peer-to-peer loans and escrow facilities.

The Marlowe platform offers a complementary route to DApp development
alongside Aiken or Plinth as long as the DApp's core functionality can
be expressed through Marlowe contracts. Each Marlowe contract has a
predetermined, finite set of roles and behavior that is guaranteed to
terminate. However, it is crucial to realize that a Marlowe DApp can
dynamically create and execute multiple Marlowe contracts for particular
use cases. For example, an escrow service DApp can generate a new
Marlowe contract for each particular use of the service, and that
contract will provide a guarantee of termination and no asset retention
for each such use. Using the TypeScript SDK for Marlowe, developers can
build complete DApps using familiar technology.

Marlowe originated as a research project funded by IO at the
University of Kent in 2017 and became part of IO in 2019. As of autumn
2024, Marlowe is an independent open-source project owned and managed by
Marlowe Language Community Interest Company (CIC), a non-profit
organization (UK company number 16010921). This CIC supports Marlowe
users and developers by overseeing development, maintenance, education,
and training. It also hosts Marlowe open-source software repositories
and maintains the ecosystem's online presence.

With Tomasz Rybarczyk, I have been funded under Catalyst Fund13(((Catalyst, Fund13))),
https://projectcatalyst.io/funds/13/f13-cardano-use-cases-concept/marlowe-2025-oracle-protocol-design-and-implementation[project 1300131],
to formalize, develop, and implement the Marlowe Oracle protocol
based on a novel pull-based model, where oracles(((oracles))) respond dynamically to
on-chain data requests, ensuring better adaptability and data coverage
for a wider array of contracts. The project will also provide validator
and runtime adaptations to support the protocol and integrate it with
the Marlowe TypeScript SDK(((TS-SDK))), Aiken, and the Marlowe DApp starter kit(((DSK))).

This is just the first step in Marlowe's new development phase, with
plans to enhance the developer experience on the Marlowe platform and
refine the core language evolution to better support its aim of
providing a high-level, chain-agnostic language for blockchain financial
smart contracts. Please join us on this journey!

[[chapter8-smart-contract-programming-languages]]
=== Smart contract programming languages

Cardano(((Cardano))) smart contract languages can be grouped into three categories:

* Native languages(((language, native))) that run on the Cardano node
* Compiled languages(((language, compiled))) that can be compiled to a native language
* Interpreted languages(((language, interpreted))) that are interpreted by a compiled language.

[[chapter8-native-languages]]
==== Native languages

The Cardano node can only process native languages. Currently, there are
two available: simple scripts(((simple scripts))) and Plutus(((Plutus))).

The Shelley era(((era, Shelley))) introduced script addresses and
https://developers.cardano.org/docs/get-started/cardano-cli/simple-scripts/[simple
scripts], also known as native scripts(((native scripts))).
They can be used for multi-signature addresses(((addresses, multi-signature))),
requiring multiple keys to sign a transaction to spend funds. The
Allegra era extended simple scripts(((simple script))) by adding conditional time-based
functionality. This allows the creation of addresses with 'time locks',
where funds can only be withdrawn before or after a specified time. A
script can also be written to allow one group of keys to spend funds
before a certain time, and another group after.

The Alonzo era(((era, Alonzo))) introduced the Plutus scripting language, also referred
to as Plutus Core(((Plutus core))). Plutus smart contracts validate transactions and because
of this they are also called validation scripts or validators.
In practice, the Cardano node executes an untyped version called Untyped
Plutus Core(((Plutus core))) (UPLC). The compilation pipeline from a
compiled language to UPLC is covered in section <<chapter8-plutus-security, Plutus security>>.
Plutus is a simple, functional language that enables general-purpose
Turing-complete(((Turing-complete))) smart contracts(((smart contract)))
on Cardano. It implements Cardano's extended UTXO
(EUTXO) model, which is as powerful in expressing smart contract logic
as Ethereum's account-based model, allowing for arbitrary logic in smart
contracts. A comparison of Plutus with Bitcoin Script(((Bitcoin script))) and
Solidity(((Solidity))) languages is presented in section
<<chapter8-plutus-in-comparison-to-bitcoin-script-and-solidity,
Plutus in comparison to Bitcoin Script and Solidity>>.
The security advantages of Cardano's EUTXO model over Ethereum's account-based
model are discussed in section <<chapter8-cardano-security, Cardano security>>.

[[chapter8-compiled-languages]]
==== Compiled languages

Smart contract developers do not write code directly in Plutus. Instead,
they use compiled or interpreted languages that are compiled into
Plutus. The language developed by IO that compiles to
Plutus is called Plinth(((Plinth))), previously known as PlutusTx. Plinth is a
Turing-complete(((Turing-complete))) subset of the Haskell programming language
(https://www.sciencedirect.com/science/article/pii/S0167642323001338#se0070[Krijnen
et al], 2023). It draws from modern language research to provide a
safe, full-stack programming environment based on Haskell, the leading
purely functional programming language(((programming, purely functional))).
It is a general-purpose smart
contract language that focuses on security. The basics of coding smart
contracts in Plinth are explained in section
<<chapter8-plutus-smart-contracts, Plutus smart contracts>>.

There are also other compiled smart contract languages developed by
companies within the Cardano ecosystem. They are all domain-specific languages
(https://en.wikipedia.org/wiki/Domain-specific_language[DSL]) as they
target the smart contract domain. Some of them, including Plinth, are
embedded DSLs
(https://en.wikipedia.org/wiki/Domain-specific_language#External_and_Embedded_Domain_Specific_Languages[eDSL])
because they are implemented as libraries in a general-purpose
programming language. Some examples include:

* https://aiken-lang.org/[Aiken]: a unique, typed, purely functional
DSL; IO supports its development
* https://github.com/HarmonicLabs/plu-ts[Plu-ts]: a typed eDSL in
TypeScript
* https://opshin.dev/[OpShin]: a typed eDSL in Python
* https://github.com/hyperion-bt/helios[Helios]: a
JavaScript/TypeScript SDK and typed DSL
* https://github.com/plutonomicon/plutarch-plutus[Plutarch]: a typed
eDSL in Haskell for writing efficient Plutus validators
* https://scalus.org/[Scalus]: a typed eDSL in Scala
* https://github.com/mlabs-haskell/purus[Purus]: a PureScript to
Plutus Core(((Plutus core))) compiler(((compiler)))
* https://github.com/Plutonomicon/pluto[Pluto]: a DSL resembling UPLC(((UPLC)))
with some syntactic sugar, written in a Haskell-like syntax.

One can read more about languages that compile to UPLC(((UPLC))) at the official
https://plutus.cardano.intersectmbo.org/docs/delve-deeper/languages[Plinth docs].
The logic in all compiled Cardano smart contract languages follows the
same rules defined by Plutus. Learning one compiled language also helps a
developer to understand other compiled languages(((language, compiled))) that
use different syntax. You can refer to the
https://cardano-foundation.github.io/state-of-the-developer-ecosystem/2024/#what-do-you-use-or-plan-to-use-for-writing-plutus-script-validators-smart-contracts[State
of the Cardano Developer Ecosystem report] – 2024 to see how much these
languages are used in practice. As of 2024, the most commonly used ones
are Aiken and Plinth. A comparison of these languages is discussed in section
<<chapter8-plinth-in-comparison-to-aiken,
Plinth in comparison to Aiken>>. A brief comparison of
some of the listed languages can also be found in the following blogs:

* The https://www.emurgo.io/press-news/the-programming-languages-behind-cardano-on-chain-code/[Emurgo]
blog about the programming languages behind Cardano on-chain code
* The https://www.essentialcardano.io/article/programming-languages[Essential Cardano] blog about programming languages.

Languages that compile to Plutus generate scripts that have the same
logic, but might be optimized differently for factors like size or
performance. This data is presented in the
https://mlabs-haskell.github.io/uplc-benchmark/comparison.html[UPLC benchmark]
comparison. Community guidelines and tools can help optimize
Plutus scripts for size, CPU, and memory consumption, reducing
transaction fees. These tools can also help analyze the fees users will
encounter while interacting with a Plutus script. The official
documentation provides more information on the
https://docs.cardano.org/about-cardano/explore-more/fee-structure/[Cardano
fee structure]. Links to Cardano developer tools are provided at the
end of this section.

Some examples of projects that can be built using
Plinth or other compiled Cardano smart contract languages include:

* NFT marketplaces and platforms (https://www.nmkr.io/[NMKR],
https://cardahub.io/home[CardaHub],
https://www.jpg.store/[JPGStore],
https://jamonbread.io/[JamOnBread])
* Decentralized exchanges (DEX) (https://muesliswap.com/[MuesliSwap],
https://minswap.org/[MinSwap], https://sundae.fi/products/sundaeswap[SundaeSwap],
https://www.geniusyield.co/[GeniusYield])
* Automated lending and borrowing platforms
(https://liqwid.finance/[Liqwid],
https://lenfi.io/[Lenfi], https://fluidtokens.com/[FluidTokens])
* Digital identity management platforms
(https://github.com/hyperledger-identus[Identus], https://iamx.id/[IAMX],
https://www.profila.com/[Profila], https://cardanofoundation.org/veridian[Veridian])
* Decentralized, blockchain-powered mobile network
(https://worldmobile.io/en[WorldMobile])
* Decentralized artificial intelligence systems
(https://singularitynet.io/[SingularityNET],
https://cardanogpt.ai/[CardanoGPT])
* Decentralized autonomous organizations (DAO)
(https://indigoprotocol.io/#indigo-dao[IndigoDAO],
https://www.clarity.vote/organizations/CharityDAO[Charity DAO],
https://github.com/eLearningDAO[eLearning DAO])
* Decentralized synthetic assets protocol
(https://indigoprotocol.io/[IndigoProtocol])
* Decentralized prediction markets (https://foreon.network/[Foreon])
* Decentralized cloud storage systems
(https://iagon.com/storage[Iagon]).

You can also explore active projects built on Cardano on the pages
below. These pages categorize projects into areas like DEX, identity and
data, lending and borrowing, developer tools, education, artificial
intelligence (AI), decentralized finance (DeFi), infrastructure,
marketplaces, and more:

* https://www.cardanocube.com/cardano-ecosystem-interactive-map[CardanoCube
interactive map]: presents projects in a visually engaging, interactive
format. For each selected project, the page provides a description and links to an official
webpage, white paper, social media pages, and GitHub repository.
* https://cardanospot.io/project-library/all[CardanoSpot project
library]: offers a category filter to list projects by category.
For each selected project, a description is provided along
with links to the official page and a white paper.
* https://developers.cardano.org/showcase[Cardano developers
showcase] page: tags projects by groups
and adds a short description to each.

[[chapter8-interpreted-languages]]
==== Interpreted languages

The third category of smart contract languages in Cardano consists of
interpreted languages that are interpreted by a compiled language.
https://marlowe-lang.org/[Marlowe], initially developed by IO, is an
interpreted smart contract language that is not Turing-complete(((Turing-complete))). It is
well-suited for designing financial contracts, such as those defined in
Algorithmic Contract Types Unified Standards(((ACTUS)))
(https://www.actusfrf.org/[Actus]), for example. The Marlowe interpreter is
written as a Plinth smart contract. Besides the programming language,
the Marlowe project provides open-source tools to easily create, verify,
and deploy secure financial smart contracts on Cardano. You can write
smart contracts in JavaScript and Haskell or use Blockly(((Blockly))),
a visual coding(((visual coding))) solution. All language options are
available in the online development environment –
https://playground.marlowe-lang.org/#/[Marlowe playground]. The
Marlowe language, its tools, architecture, and contract examples are
presented in section <<chapter8-marlowe-smart-contracts, Marlowe smart contracts>>.

With Marlowe, it is possible to design a diversity of contracts for the
following domains:

* Bonds(((bonds))), forwards, options, futures(((futures))), swaps(((atomic swap))), etc.
* Structured financial products
* Escrows
* Auctions
* Peer-to-peer loans(((peer-to-peer loans)))
* Token swaps
* Airdrops.

Section <<chapter8-marlowe-best-practices-and-security, Marlowe security and best practices>>
explores the security and best practices of Marlowe in more detail.

[[chapter8-on-chain-and-off-chain-code]]
==== On-chain and off-chain code

Sometimes, smart contract code is referred to as on-chain code(((on-chain, code))) because
it runs in the node during the inclusion of new transactions that aim to
spend a UTXO at a script address. Off-chain code(((off-chain code))), in contrast, runs on
the user's or a service provider's device and queries the blockchain,
builds, signs, and submits transactions. A web application that
connects with a wallet and interacts with one or more smart contracts is
called a decentralized application (DApp). Chapter
<<decentralized-applications, Decentralized applications>>
covers DApps in more detail. Every DApp contains some
off-chain code and interacts with one or more smart contracts that
represent the on-chain code. Off-chain code tasks can be
performed with a command line tool, such as the
https://github.com/IntersectMBO/cardano-cli/tree/main[Cardano CLI], or
with the help of libraries and builder tools that are embedded in
popular programming languages. Some of them include:

* https://blockfrost.dev/sdks[Blockfrost SDK]: enables access to the
Blockfrost API layer for Cardano. The SDK is provided in various
programming languages such as Arduino, .NET, Crystal, Elixir, Go,
Haskell, Java, JavaScript, Kotlin, PHP, Python, Ruby, Rust, Scala, and
Swift.
* https://meshjs.dev/[MeshJS]: a NodeJS-based open-source library
providing numerous tools to easily build DApps on Cardano. It also
integrates the popular https://react.dev/[React] library.
* https://lucid.spacebudz.io/[Lucid]: a popular JavaScript/TypeScript
library for off-chain code, which is further developed by the
https://no-witness-labs.github.io/evolution-sdk/[Evolution-SDK]
project. The Evolution-SDK project was temporarily called
Lucid Evolution(((Lucid Evolution))) and was funded by
https://projectcatalyst.io/funds/11/cardano-open-developers/anastasia-labs-lucid-evolution-redefining-off-chain-transactions-in-cardano[Catalyst
Fund11].
* https://atlas-app.io/[Atlas]: an all-in-one, Haskell-native
application backend for writing off-chain code for Plutus smart
contracts.

Explore Cardano tools that can be used for building DApps at:

* The https://developers.cardano.org/tools/[Builder Tools] page on the
Cardano Developer portal. You can filter the tools by language/technology
or by domain. Every tool contains a short description.
* The Cardano community-built
https://www.essentialcardano.io/article/a-list-of-community-built-developer-tools-on-cardano[developer tools] list hosted on Essential Cardano(((Essential Cardano))).

You can also look at the State of the Cardano Developer Ecosystem report
– 2024, listing the most commonly used
https://cardano-foundation.github.io/state-of-the-developer-ecosystem/2024/#which-libraries-do-you-use-in-your-projects[Cardano libraries].

Section <<chapter8-plutus-smart-contracts, Plutus smart contracts>>
presents the MeshJS tool and
showcases how to write off-chain code for smart contracts in subsections
<<chapter8-off-chain-code-with-meshjs, Off-chain code with MeshJS>> and
<<chapter8-minting-policies-and-native-tokens, Minting policies and native tokens>>.
We provide a link to a repository that contains the presented MeshJS code
examples and also contains Lucid Evolution code examples.

[[chapter8-smart-contract-case-studies]]
=== Smart contract case studies

[[chapter8-world-mobile-token-smart-contracts]]
==== World Mobile Token smart contracts

The https://worldmobile.io/en[World Mobile] company offers an
interesting case study of a solution that can change the current state
of internet networks. With the help of Cardano and smart
contracts(((smart contract))), the company provides a sharing economy model to deliver
network infrastructure and enable connectivity in a more distributed and
decentralized manner.

The establishment of a sharing economy leads to reduced operational
costs and more efficient resource allocation. Additionally, the
token-based, decentralized nature of this sharing economy makes the
model highly scalable in terms of deployment. Instead of depending on a
centralized network operator to continuously assess the network's
capacity and demand, which is always changing, the network's expansion
is driven by the communities that require access to the internet. Smart
contracts play a key role here: they remove intermediaries and
incentivize network expansion through an automated reward system,
whereby operators are rewarded for providing good-quality services.

*Network overview*

The World Mobile network(((World Mobile, network))) consists of three layers
of nodes, each with different responsibilities:

* *Earth nodes* contain the core business logic of the World Mobile
Chain. They provide an authentication layer (decentralized identity
module), manage all blockchain transactions (blockchain module), and
include a telecommunications layer.
* https://airnode.worldmobile.io/[*Air nodes*] are located in areas
where connectivity is needed. They serve as the first point of contact
with the network for individual users or entire communities.
* *Aether nodes* interface with legacy telecommunications networks. They
handle protocol translations, media transcoding, and the routing of
traffic to these networks.

*Earth nodes core logic*

To simplify the complexity of business logic within the network, Earth
nodes are responsible for calling the appropriate smart contracts. For
example, Earth nodes handle the processing of rewards for other nodes,
ensuring automated payments are made once the conditions of the smart
contracts are met. Additionally, Earth nodes process and verify
identities provided by Air nodes, responding with the user's available
account balance and a list of available services.

Earth node operators must stake a certain amount of tokens to join the
network. The minimum number of tokens required to operate an Earth node
is set at 100,000 tokens, as specified in the initial blockchain
parameters. Each Earth node earns rewards based on several factors.
Firstly, rewards are given for producing and committing blocks to the
blockchain, which includes financial settlements and metadata such as
the hash reference to call details records (CDRs). Secondly, node
operators are rewarded for providing services to users, such as routing
communication traffic (voice, SMS, etc.).

Earth nodes can operate from any location globally; however, traffic
routing within the network is biased towards nearer nodes to enhance
performance and service quality.

*World Mobile token and Earth node non-fungible tokens (NFTs)*

Utilizing Cardano's native token capabilities, World Mobile introduced
the https://worldmobiletoken.com/[World Mobile Token] (WMT) as the
primary currency for transactions and reward distribution within its
ecosystem. The primary purpose of a WMT is to incentivize both token
holders and node operators. Token holders support network operations by
delegating their WMTs to node operators (stakers) who manage nodes.
There is a finite supply of two billion WMTs, with
only a portion initially circulating.

Additionally, there exists another currency within the World Mobile
ecosystem – Earth node non-fungible token (ENNFT). ENNFTs are created
using Cardano's native token functionality and are issued to Earth node
owners who locked 100,000 WMT to a smart contract before January 4,
2023. These NFTs(((NFTs))) provide monthly rewards; each month, Earth node owners
receive 1,300 WMT (1.3%) for maintaining their node.

*Cardano within the WMT sharing economy model*

In contrast to traditional network models, the operation and maintenance
of nodes within the WMT sharing economy model is shared with
communities and local businesses. This approach enhances scalability and
reduces costs by allocating resources to areas where they are most
needed. Leveraging blockchain technology and smart contracts offers
numerous advantages that align seamlessly with this distributed model:

* *Transparency*: Cardano records information that can be easily
accessible to different stakeholders to make more informed decisions
* *Privacy*: user information is stored using private/public
encryption(((encryption, private/public))) provided by Cardano
* *Immutability*: Cardano's EUTXO model ensures transaction immutability
and restricts spending to only unspent transaction outputs(((transaction, output))),
making the reward system more deterministic.

[[chapter8-cardano-addresses]]
=== Cardano addresses

A blockchain address serves as a communication link between the
blockchain and the user. With the introduction of stake pools(((stake pool)))
in the Shelley era(((era, Shelley))), a Cardano address consists of two parts:
the _payment_ part and the _staking_ part.

image::sc_cardano_address.png[width=400,height=280,title="Cardano address"]

Both parts of a Cardano address are cryptographically derived from the
private key(((private key))), containing the same owner information. The
payment part,
which is always present, determines the conditions under which a UTXO at
the address can be spent. It is either defined by the hash of a public
key or a Plutus script. If it contains a public key hash(((public key, hash))), UTXOs can only
be spent if the transaction is signed with the corresponding private
(signing) key. If it contains a script hash(((script, hash))), the script executes during
validation to decide whether UTXOs at the address can be spent.

The optional staking part controls delegation and staking rewards. If
defined with a public key hash, the corresponding private key(((private key)))
owner can spend the rewards. If defined with a script hash(((script, hash))),
the script determines the conditions under which staking rewards can be spent.

Cardano Shelley addresses(((address, Shelley))) can be divided into four categories:

* Base addresses(((address, base)))
* Pointer addresses(((address, pointer)))
* Enterprise addresses(((address, enterprise)))
* Reward account addresses(((address, reward account))).

Only __base __and __pointer __addresses carry staking rights. The _base_
address directly specifies the staking key controlling the stake, while
a _pointer_ address indirectly specifies it. The advantage of the
_pointer_ address is that it can be considerably shorter than the hash
used in base addresses. _Enterprise_ addresses, which carry no staking
rights, are also shorter and can be used for sending and receiving
funds. _Reward account addresses_, used to distribute proof-of-stake
rewards (either directly or via delegation), are cryptographic hashes of
the public staking key. They follow the account-based model, unlike the
UTXO model(((UTXO, model))). Rewards are reflected in accounts, and UTXOs
are created only when rewards are withdrawn.

The Shelley era(((era, Shelley))) continued to support Byron-era(((era, Byron)))
_bootstrap addresses_ and _script addresses_. The
https://docs.cardano.org/learn/cardano-addresses/[Cardano addresses]
documentation page provides more information about address categories.

[[chapter8-binary-format]]
==== Binary format

Under the hood, a Cardano address is a sequence of bytes that conforms
to a particular format. Users will typically interact with addresses
only after they have been encoded into sequences of human-readable
characters. https://en.bitcoin.it/wiki/Bech32[Bech32] and
https://bitcoinwiki.org/wiki/base58[Base58] are encodings used in
Cardano, as opposed to standard hexadecimal notation
(https://en.wikipedia.org/wiki/Hexadecimal[Base16]). These encodings
represent the addresses users perceive, though they are distinct from
the underlying byte sequences. Shelley addresses(((address, Shelley))), which include staking
addresses, use Bech32(((Bech32))) encoding without a character length limit. In
contrast, Byron addresses(((address, Byron))) are encoded in Base58(((Base58))),
allowing for easy differentiation from Shelley-era addresses. Below are examples
of the different address types:

image::sc_address_types.png[width=900,height=162,title="Address types, source: https://cips.cardano.org/cip/CIP-19[CIP-19]"]

In Cardano addresses(((Cardano, address))), the sequence of bytes (decoded from _Bech32_ or
_Base58_) consists of two parts – a one-byte header and a payload of
several bytes. Depending on the header, the interpretation and length of
the payload vary. In the header byte, the bits from 7 to 4 indicate
the type of addresses being used; we'll call these four bits the header
type. The remaining four bits from 3 to 0 are either unused or refer to
what we call the network tag. You can see a graphical representation
below:

image::sc_address_structure.png[width=300,height=208,title="Address structure, source: https://cips.cardano.org/cip/CIP-19[CIP-19]"]

Depending on the various header types and address formats, there are
currently 11 types of addresses in Cardano, which are either Shelley(((address, Shelley))) or
Byron addresses(((address, Byron))), including the addresses used for staking. You can see
the various address structures below:

[source,console]
----
           TYPE  |     TAG     |   PAYMENT   |   DELEGATION
ADDRESS = %b0000 | NETWORK-TAG | KEY-HASH    | KEY-HASH       ; type 00, Base
                                                                Shelley address
        \ %b0001 | NETWORK-TAG | SCRIPT-HASH | KEY-HASH       ; type 01, Base
                                                                Shelley address
        \ %b0010 | NETWORK-TAG | KEY-HASH    | SCRIPT-HASH    ; type 02, Base
                                                                Shelley address
        \ %b0011 | NETWORK-TAG | SCRIPT-HASH | SCRIPT-HASH    ; type 03, Base
                                                                Shelley address
        \ %b0100 | NETWORK-TAG | KEY-HASH    | POINTER        ; type 04, Pointer
                                                                Shelley address
        \ %b0101 | NETWORK-TAG | SCRIPT-HASH | POINTER        ; type 05, Pointer
                                                                Shelley address
        \ %b0110 | NETWORK-TAG | KEY-HASH                     ; type 06, Enterprise
                                                                Shelley address
        \ %b0111 | NETWORK-TAG | SCRIPT-HASH                  ; type 07, Enterprise
                                                                Shelley address
        \ %b1000 | BYRON-PAYLOAD                              ; type 08, Byron /
                                                                Bootstrap address
        \ %b1110 | NETWORK-TAG | KEY-HASH                     ; type 14, Stake
                                                                Shelley address
        \ %b1111 | NETWORK-TAG | SCRIPT-HASH                  ; type 15, Stake
                                                                Shelley address

NETWORK-TAG  = %b0000 ; Testnet
             \ %b0001 ; Mainnet
----

For _Bech32_-encoded addresses (used for all Shelley addresses), the last
six characters of the data part form a checksum of the previous address
data and contain no information. This allows for quick offline validity
checks and provides an additional safety measure for wallets. For an
additional explanation of address type structures, refer to
https://cips.cardano.org/cips/cip19/#binaryformat[Cardano Improvement Proposal 19]
(CIP-19), which defines the technical details of Cardano
addresses.

[[chapter8-marlowe-smart-contracts]]
=== Marlowe smart contracts

[[chapter8-about-marlowe]]
==== About Marlowe

Marlowe(((Marlowe))) is a domain-specific language (DSL) for building
financial smart contracts. One can think of Marlowe as a robust, open-source
technology that provides a special-purpose language describing asset flows
on the blockchain. As a special-purpose DSL, it offers a higher-level model of
contracts in a more restricted domain than other Cardano languages
compiling directly to Plutus. This means that Marlowe can provide
safety guarantees, such as ensuring that no assets are held in a script
indefinitely, by design. Additionally, it offers
tools for a full analysis of potential contract faults before contract
execution.

The implementation of Marlowe on Cardano is carried out using Plinth.
Marlowe smart contracts are interpreted by a Plinth smart contract under
the hood. Marlowe enables the implementation of specific domain
expertise to write and manage contracts conveniently, without the steep
learning curve associated with software development, blockchain, or
smart contracts. Marlowe's core technology has been audited, and it
supports contracts on mainnet and pre-production testing environments.
Its Runtime enables all the necessary on- and off-chain contract
activity, including the tedious work of transaction construction. The
TypeScript SDK supports Marlowe as a component within a complete DApp.
This makes it a smart contract technology that is complementary to
Aiken, Plinth, or any other Cardano smart contract language. It
abstracts away the complexities of Cardano and provides a local,
account-based model like Ethereum.

Beyond the notable benefit of usability by non-programmers, the Marlowe
language offers many other advantages:

* Easily checks that programs have the intended properties
* Ensures high assurance that the contract consistently fulfills its
payment obligations
* Helps people write programs in the language using special-purpose
tools
* Emulates contract behavior before execution on the blockchain,
ensuring intended performance through static analysis(((static analysis)))
* Provides valuable diagnostics to potential participants before they
commit to a contract
* Formally proves properties of Marlowe contracts, delivering the
highest level of assurance regarding intended behavior through logic
tools
* Prevents certain flawed programs from being written by design
* Mitigates some unanticipated exploits that have affected existing
blockchains.

Marlowe is modeled after special-purpose financial contract languages
popularized over the past decade by academics and enterprises, such as
LexiFi, which provides contract software for the financial sector. In
developing Marlowe, these languages have been adapted to work on
blockchain. Although it is implemented on Cardano,
Marlowe could also be implemented on Ethereum or other blockchain
platforms, making it 'platform-agnostic', similar to modern
programming languages like Java and C++. Designed as an industry-scale
solution, Marlowe embodies examples from the https://actusfrf.org[Actus]
taxonomy for financial contracts. It can also interact with
real-world data providers through oracles(((oracles))), enabling contract
participants to make choices within the contract flow that determine
on-chain and off-chain outcomes, such as in a wallet.

Marlowe is based on original, peer-reviewed research conducted by the
Marlowe team, initially at the University of Kent with support from a
research grant from IO, and later as an internal engineering team within
IO. The Marlowe team at IO was also collaborating with the
https://www.uwyo.edu/acct-fin/cbdi/[Wyoming Center for Blockchain and Digital
Innovation] (CBDI)
at the University of Wyoming. More information about
the research conducted for Marlowe can be found on the official
documentation page, which also lists
https://docs.marlowe-lang.org/docs/platform-and-architecture/platform#research-based[published
research papers] related to Marlowe.

In the future, Marlowe will be administered by an independent vehicle, a
not-for-profit organization, which will ensure community representation
and stewardship. This will allow the community to actively contribute to
its roadmap and propose updates and enhancements. To further support
Marlowe's vision, a new
https://github.com/marlowe-foundation/org/blob/main/sig-charter.md[Special
Interest Group] (SIG) has been established that is active on Discord,
focusing on Marlowe's continued innovation and enhancement, with
builders at the heart.

In summer 2024, IO transferred the intellectual property rights for
Marlowe to the Marlowe Foundation(((Marlowe, Foundation))) – a non-profit organization
established to oversee the continued development of Marlowe and its
ecosystem as a community-based project. The Marlowe repositories will be
transferred to the https://github.com/marlowe-lang[marlowe-lang]
GitHub, and continued development will take place there.

[[chapter8-developer-tools-and-services]]
==== Developer tools and services

Marlowe provides a set of open-source tools that help create, test, and
deploy secure smart contracts on Cardano. It offers intuitive solutions
to create, utilize, and monetize smart contracts with ease, catering to
developers of all expertise levels. The following developer tools and
features are available:

* _Marlowe language_ – a DSL that includes a web-based platform to build
and run smart contracts
* _Marlowe Playground(((Marlowe, playground)))_ – a simulator that allows
testing Marlowe smart contracts before deployment to ensure intended code behavior
* _Marlowe Runner(((Marlowe, runner)))_ – an easy-to-use DApp that can be used to deploy,
execute, and interact with Marlowe smart contracts
* _Marlowe Scan(((Marlowe, scan)))_ – a tool for visualizing Marlowe contracts on Cardano
* _Marlowe Runtime(((Marlowe, runtime)))_ – the application backend for managing Marlowe
contracts on Cardano, which includes easy-to-use, higher-level APIs for
developers to build and deploy enterprise and Web3(((Web3))) DApp solutions
* _Marlowe CLI(((Marlowe, CLI)))_ – provides capabilities to work with Marlowe's Plutus
validators and run Marlowe contracts manually
* _Marlowe starter kit(((Marlowe, starter kit)))_ – provides tutorials for developers to learn and
run simple Marlowe contracts on Cardano
* _Marlowe TypeScript SDK(((TS-SDK)))_ (currently in beta) – a suite of
TypeScript/JavaScript libraries for developing web DApps on Cardano
using Marlowe technologies
* _Demeter.Run(((Demeter.Run))) integration_ – a web service that allows building Marlowe
projects without installing any software
* _Documentation website_ – significantly expanded, updated, and
integrated into the updated Marlowe website.

_IMPORTANT:_
During Marlowe's transition phase some tools may have issues when used
with the latest test or main network due to Cardano updates — especially
for repositories that are not actively maintained by the Marlowe Foundation.

The
https://docs.marlowe-lang.org/docs/platform-and-architecture/marlowe-language-guide[Marlowe
language] enables users to build contracts by combining a small number
of constructs, which can describe many different financial contracts.
Contract participants can engage in various actions: they can be asked
to deposit money or make choices between various alternatives [source:
Marlowe: implementing and analyzing financial contracts on blockchain,
Lamela et al. 2020]. Marlowe contract examples are presented in section
<<chapter8-contract-examples, Contract examples>>.

The https://playground.marlowe-lang.org/[Marlowe Playground] is the
main entry point for learning and developing Marlowe smart contracts. It
is an online simulation that allows users to experiment with, develop,
simulate, and analyze Marlowe contracts(((Marlowe, contract))) in a web browser without
installing any software. Supported programming languages include Marlowe
itself, Haskell, JavaScript, and TypeScript. The playground also
includes Blockly(((Blockly))) – an editor for visual programming. Together, these
languages form a plug-and-play building and simulation smart contract
environment that is simple to use, visual, and modular. The playground
also allows downloading contracts as a JSON file for further use. For
more details on how to use the playground, see this
https://www.youtube.com/watch?v=EgCqG0hPmwc[video tutorial].

https://docs.marlowe-lang.org/docs/getting-started/runner[Marlowe
Runner] is an online tool that facilitates the deployment and execution
of Marlowe contracts on the blockchain, eliminating the need for
command-line expertise. With Marlowe Runner(((Marlowe, runner))), users can deploy contracts
created in the Marlowe playground, test them, and interact with them in
a simulated environment before mainnet deployment. For this, users need
to connect to the Runner using a Cardano wallet such as https://www.lace.io/[Lace]
or https://eternl.io/[Eternl]. Contracts can be uploaded to the Runner as
a JSON file, or one can manually paste the JSON structure into an editor
window. One can look at the source graph before creating a contract,
which is also available when interacting with the contract. If a Marlowe
contract uses role tokens(((role tokens))), the funds cannot be retrieved from the
role-token contract with the Runner. In such a case, one can use the
https://docs.marlowe-lang.org/docs/developer-tools/ts-sdk/payouts-dapp-prototype[Payout
DApp prototype]. A
https://www.youtube.com/watch?v=B5XcH0j7Y7w&list=PLNEK_Ejlx3x2ukxS8Xd0Z-cq24-1jP9G9[video
tutorial] about using Marlowe Runner(((Marlowe, runner))) can be found on the IO YouTube channel.

https://github.com/marlowe-lang/marlowe-scan[Marlowe Scan] is a tool
that allows users to query information about Marlowe contracts and view
the current contract state. It can be used for the preview and pre-production
test networks and the mainnet. Users can also view the contract code,
download it, and view a list of transaction IDs.

https://docs.marlowe-lang.org/docs/developer-tools/runtime/marlowe-runtime[Marlowe
Runtime] is the application backend for managing Marlowe contracts on
Cardano. It provides easy-to-use, higher-level APIs and complete backend
services that enable developers to build and deploy enterprise and Web3(((Web3)))
DApp solutions using Marlowe. Users don't need to assemble the
"plumbing" that manually orchestrates a backend workflow for a
Marlowe-based application. Runtime takes commands relevant to the
Marlowe ledger and maps them to the Cardano ledger. It consists of a
series of services that can be divided into frontend and backend
components. Marlowe Runtime backend services are off-chain components
largely responsible for interfacing with a Cardano node. They offer
abstractions to hide many implementation details of Plutus and the
Cardano node directly. There are two ways to interface with Marlowe
Runtime:

* Using Marlowe Runtime(((Marlowe, runtime))) web REST API
* Using the `marlowe-runtime-cli` command line tool.

The role of Runtime is to facilitate the mapping between the Marlowe
conceptual model and the Cardano ledger model in both directions. Users
can primarily perform two types of tasks: discovering and querying
on-chain Marlowe contracts, as well as creating Marlowe transactions.
More specifically, the tasks include the following:

* Creating contracts
* Building transactions
* Submitting transactions
* Querying contract information and history
* Listing contracts
* Subscribing to live contract updates.

There are two main use cases for using Marlowe as a layer for smart
contract developers. Depending on the complexity of the smart contract
and the DApp, higher-level operations provide a simplified interface,
allowing developers to focus mainly on smart contract logic rather than
implementation details. However, more complex workflows might require
lower-level control, necessitating a deeper understanding of Plutus. For
more information, refer to the list of high- and low-level operations on
the https://docs.marlowe-lang.org/docs/developer-tools/overview[developer
tools] documentation page.

https://docs.marlowe-lang.org/docs/developer-tools/marlowe-cli[Marlowe
CLI] is a command-line tool that provides access to Marlowe
capabilities on testnet and mainnet. It is specifically built to run
Marlowe contracts directly without needing a web browser or a mobile
app. Just as the `cardano-cli` tool enables plain transactions, simple
scripts, and Plutus scripts, the Marlowe CLI(((Marlowe, CLI))) tool provides the
ability to interact with and develop Marlowe contracts. Users can
measure transaction size, submit transactions, test wallet integration,
and debug validators. The tool provides a concrete representation of
Marlowe contracts that are quite close to what is occurring on-chain.
Users can also create their own workflows that operate with Marlowe or
develop custom tool sets. This allows them to wrap the Marlowe CLI(((Marlowe, CLI))) tool
similarly to how developers have wrapped the cardano-cli to create
services such as libraries, faucets, and marketplaces.

The image below offers an overview and description of the Marlowe CLI(((Marlowe, CLI)))
and Marlowe Runtime(((Marlowe, runtime))) tools for running and querying Marlowe contracts:

image::sc_marlowe_tools.png[width=806,height=560,title="Marlowe tools, source: https://docs.marlowe-lang.org/docs/developer-tools/overview[Marlowe docs]"]

The https://github.com/marlowe-lang/marlowe-starter-kit[Marlowe
starter kit] is a GitHub repository that contains Jupyter notebook(((Jupyter notebook)))
lessons demonstrating the use of the Marlowe CLI(((Marlowe, CLI))) and Marlowe Runtime
tools through concrete examples. It can be used with Demeter Run, a
Docker(((Docker))) deployment of Marlowe Runtime, and Nix(((Nix))) to run the Jupyter
notebooks. The repository provides instructions for setting up various
environments. Additionally, the Jupyter notebooks offer guidance on
interacting with Marlowe smart contracts, covering different approaches
and tools.

The https://docs.marlowe-lang.org/docs/developer-tools/ts-sdk/ts-sdk-intro[Marlowe
TypeScript SDK] (TS-SDK) consists of JavaScript and TypeScript
libraries, available as npm(((npm))) packages, designed to support DApp
developers with the necessary tools to build and integrate with the
Marlowe smart contract ecosystem. There are
https://www.youtube.com/watch?v=0Qa1CsZUGnw&list=PLNEK_Ejlx3x1lRhBpL8TUdirMdBPOOvlp[short
video tutorials] on the IO YouTube channel that demonstrate
how to use the TS-SDK to build an example DApp. Since the tutorials were
created during the beta stage, function names may change in the official
release. The TS-SDK offers the following features:

* Smart contract toolkit
* Integration with Marlowe Playground(((Marlowe, playground)))
* Wallet connectivity
* Integration with Runtime
* Coordination between wallets and Runtime
* Prototype DApp examples.

You can read more about these features in the official TS-SDK
documentation. To interact with Marlowe contracts, the TS-SDK needs a
Runtime instance. The TS-SDK GitHub repository provides the
https://github.com/marlowe-lang/marlowe-ts-sdk?tab=readme-ov-file#cip-30-and-browser[following
table] showing the compatibility between the SDK and the Runtime
versions. The SDK also provides a wrapper around the
https://github.com/spacebudz/lucid[Lucid Library]. This allows using
the SDK in a Node.js(((NodeJS))) environment.

The https://demeter.run/[Demeter.Run] platform, developed and
maintained by https://txpipe.io/[TxPipe], offers a variety
of tools and development environments targeting the Cardano ecosystem.
Their price model depends on the usage of their services, and users also
have the option to get some working time for free. You can read more
about the platform in section
<<chapter8-setting-up-a-plinth-development-environment,
Setting up a Plinth development environment>>.

The https://docs.marlowe-lang.org/docs/introduction[Marlowe
documentation] provides extensive explanations, links to learning
resources, and access to tutorials and community resources from the top
bar.

[[chapter8-marlowe-runtime-architecture]]
==== Marlowe Runtime architecture

Below is the Marlowe Runtime(((Marlowe, runtime))) architecture:

image::sc_marlowe_runtime_architecture.png[width=900,height=540,title="Marlowe runtime architecture, source: https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe-runtime/doc/ReadMe.md#architecture[Marlowe GitHub]"]

The Marlowe Runtime backend consists of a chain-indexing and query
service (marlowe-chain-indexer / marlowe-chain-sync), a
contract-indexing and query service for Marlowe contracts
(marlowe-indexer / marlowe-sync), and a transaction-creation service for
Marlowe contracts (marlowe-tx). These backend services work together,
relying upon https://github.com/IntersectMBO/cardano-node[cardano-node]
for blockchain connectivity and PostgreSQL for persistent storage.
Access to the backend services is provided via a command-line client
(marlowe-runtime-cli), or a REST/WebSocket server (web-server) that uses
JSON payloads. Web applications can integrate with a
https://cips.cardano.org/cips/cip30/[CIP-30 light wallet] for
transaction signing, whereas enterprise applications can integrate with
https://github.com/cardano-foundation/cardano-wallet[cardano-wallet],
https://github.com/IntersectMBO/cardano-cli[cardano-cli],
or https://github.com/vacuumlabs/cardano-hw-cli/tree/develop[cardano-hw-cli]
for the same purpose.

The backend services use typed protocols over TCP sockets, with separate
ports for control, query, and synchronization. Each service handles
rollbacks using intersection points that reference specific slots/blocks
on the blockchain. Most of the data flow is stream-oriented, and the
services prioritize statelessness. The information flow within the
backend maximizes the node as the single source of truth, minimizing the
danger of downstream components receiving inconsistent information. The
Haskell types in the client API for Runtime Clients are independent of
various Cardano packages for ledger, node, and Plutus, resulting in a
Haskell client for Runtime having minimal dependencies in its `.cabal`
file.

Please note that the Marlowe Runtime architecture may evolve. Refer to
the https://docs.marlowe-lang.org/docs/platform-and-architecture/architecture[Marlowe
documentation] for the latest version.

[[chapter8-contract-examples]]
==== Contract examples

Marlowe is designed to create the following building blocks of financial
contracts:

* Payments to and deposits from participants
* Choices by participants
* Real-world information.

It is a small language with a handful of different constructs that, for
each contract, describe behavior involving a fixed, finite set of roles
or accounts. When a contract is run, the roles it involves are fulfilled
by participants, who are identities on the blockchain. An on-chain
token represents each role. Roles can be transferred during contract
execution, meaning they can be traded. Users can also use external
accounts represented by their Cardano addresses(((Cardano, address)))
instead of roles. In this case, role tokens(((role tokens))) are not created.
In a Marlowe contract(((Marlowe, contract))), internal
accounts correspond to roles or external accounts, with internal
accounts controlled by the smart contract. Typically, all participants
should make a deposit, sending funds from their wallets to the Marlowe
contract, which retains the funds and associates them with the relevant
internal accounts. Depending on the contract's terms, funds can be
transferred between these internal accounts and back to external
accounts. No funds are permanently locked in a Marlowe contract; when
the contract concludes, any remaining funds in internal accounts can be
withdrawn by their owners.

Contracts are built by putting together a small number of constructs
that, in combination, describe and model many different kinds of
financial contracts. Some examples include:

* A running contract that can make a payment to a role or a public key
* A contract that can wait for an action by one of the roles, such as a
deposit of currency
* A choice from a set of options.

Crucially, a contract cannot wait indefinitely for an action: if no
action has been initiated by a set time (the timeout), the contract will
continue with an alternative behavior. For example, it may refund any
funds in the contract as a remedial action. Marlowe contracts can branch
based on alternatives and have a finite lifetime, after which any
remaining funds are returned to the participants. This feature means
that funds cannot be locked forever in a contract. Depending on the
contract's current state, it can choose between two alternative future
courses of action, which are also contracts. When no further actions are
required, the contract closes, and any remaining funds are refunded.
Marlowe is embedded in Haskell and is modeled as a collection of
algebraic data types, with contracts defined by the _Contract_ type:

[source,haskell]
----
data Contract = Close
              | Pay Party Payee Token Value Contract
              | If Observation Contract Contract
              | When [Case] Timeout Contract
              | Let ValueId Value Contract
              | Assert Observation Contract
----

Marlowe has _six_ ways of building contracts. Five of these methods –
`Pay`, `Let`, `If`, `When`, and `Assert` – build a complex contract from simpler
contracts, and the sixth method, `Close`, is a simple contract. At each
step of execution, besides returning a new state and continuation
contract, it is possible that effects – payments – and warnings can also
be generated. A description of each of the methods that the Contract
data type defines can be found in the
https://docs.marlowe-lang.org/docs/platform-and-architecture/marlowe-language-guide#about-a-marlowe-contract[Marlowe
language guide] hosted on the official documentation page.

The Haskell source code for the data types that Marlowe code uses can be
found in the
https://github.com/marlowe-lang/marlowe-cardano[marlowe-cardano]
GitHub repository. If you are writing Marlowe version 1 scripts, the
module you need to import in a Haskell project to be able to write
Marlowe code is `Language.Marlowe.Extended.V1`
(https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe/src/Language/Marlowe/Extended/V1.hs[source
code]). Some important Haskell data types that this module exports are
contained in the `Language.Marlowe.Core.V1.Semantics.Types` module
(https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe/src/Language/Marlowe/Core/V1/Semantics/Types.hs[source
code]). You can look up these modules if you view the documentation for
Marlowe dependencies. The
https://github.com/input-output-hk/marlowe-dependency-docs[marlowe-dependency-docs]
GitHub repository contains instructions for setting up your own
documentation server.

Let us now look at an example of a Marlowe contract involving three
parties – Alice, Bob, and Charlie. In this contract, Alice and Bob
deposit 10 lovelaces. Then, Charlie decides whether Alice or Bob
receives the total amount. If any of the three parties fails to
participate, the contract ensures that all deposited funds are
reimbursed. You can see a demonstration of this contract's design using
Blockly(((Blockly))) in the Marlowe Playground(((Marlowe, playground)))
in the following https://youtu.be/fldaBHmYfqk[Plutus Pioneer
program] video.

Below, you can see the contract code in the Marlowe language:

[source,console]
----
When
    [Case
        (Deposit
            (Role "Alice")
            (Role "Alice")
            (Token "" "")
            (Constant 10)
        )
        (When
            [Case
                (Deposit
                    (Role "Bob")
                    (Role "Bob")
                    (Token "" "")
                    (Constant 10)
                )
                (When
                    [Case
                        (Choice
                            (ChoiceId
                                "Winner"
                                (Role "Charlie")
                            )
                            [Bound 1 2]
                        )
                        (If
                            (ValueEQ
                                (ChoiceValue
                                    (ChoiceId
                                        "Winner"
                                        (Role "Charlie")
                                    ))
                                (Constant 1)
                            )
                            (Pay
                                (Role "Bob")
                                (Account (Role "Alice"))
                                (Token "" "")
                                (Constant 10)
                                Close
                            )
                            (Pay
                                (Role "Alice")
                                (Account (Role "Bob"))
                                (Token "" "")
                                (Constant 10)
                                Close
                            )
                        )]
                    1682551111000 Close
                )]
            1682552111000 Close
        )]
    1682553111000 Close
----

Next is a flowchart generated with the Marlowe Runner(((Marlowe, runner))) that indicates
possible actions and outcomes of the above contract. The highlighted
block is the start of the contract, and the greyed-out blocks show
possible execution paths:

image::sc_marlowe_contract_tree.png[width=930,height=207,title="Marlowe contract tree"]

Below, you can see the image of the contract implemented in the
Blockly(((Blockly))) tool:

image::sc_marlowe_contract_choice.png[width=586,height=960,title="Marlowe choice contract"]

The `When` constructor, in the beginning, waits for an external action
that we specify in square brackets. If this external action does not
happen, we will close the contract. We do this by specifying a timeout
in POSIX time(((POSIX time))) (measured as milliseconds after UNIX epoch –
00:00:00 https://en.wikipedia.org/wiki/Coordinated_Universal_Time[UTC] on
1 January, 1970) after the closing square bracket of the `When`
constructor and add the `Close` constructor at the end. If the
external action does not happen before this timeout, the contract
terminates. Our external action will be a deposit by Alice, and we say
that the deposit should happen until a certain time. We use the `Case`
constructor for that, which contains two pairs of regular brackets.
The first one defines the case of what has to happen for the contract to
progress, and the second one defines the logic that follows if the case
action is met. In the first bracket, we specify that Alice should
deposit 10 lovelaces. We do this by using the `Deposit` constructor. First,
we specify to which account the deposit should go. We can specify this
with the `Role` constructor followed by the role name, which, in our
case, is Alice. Second, we specify who is depositing into the previously
mentioned account. We can again use the `Role` constructor and Alice's
name. We could also use the `Address` constructor, where we would have
to input Alice's Cardano address. Then, we have to specify what kind of
currency we are depositing. For this, we use the `Token` constructor
and add the currency symbol and the token name. For the ada currency, we
can use two empty strings. At the end, we specify the amount (in lovelaces) of the
currency we want to deposit. For this, we can use the `Constant`
constructor followed by a number.

After defining the first part of the `Case` statement, the next step is to
outline the logic for when the condition is met. This begins with a new
`When` statement, in which Bob will deposit 10 lovelaces, and a new timeout is
set. The code for Bob's deposit mirrors Alice's, but the role name
changes from Alice to Bob. After that, we again define the logic that
follows if Bob makes his deposit. We use a `When` statement that says
Charlie has to make a choice. We set a timeout for the statement in case
Charlie does not make his choice and then the contract gets terminated.
We use a `Case` statement for Charlie to make a choice, and in the code,
we apply the `Choice` constructor for that decision. This constructor
takes two arguments. First, it takes the information about the choice
name and the person making the choice. The `ChoiceId` constructor
defines this, specifying the person with the `Role` statement. The second
argument is a list of integers that defines Charlie's possible choices.
Since Charlie decides whether the funds go to Alice or Bob, the list
contains only two numbers.

The logic that follows after that is a conditional statement, which uses
the `If` constructor. First, it takes the condition statement and then
the two possible cases depending on the condition. For the condition
statement, we use the `ValueEQ` constructor. It takes the value that
Charlie chose and compares it to a number. We retrieve the value from
Charlie's choice by using the `ChoiceValue` constructor and input the
`ChoiceId` statement that we previously used. The value to which we
compare it is 1, for which we again use the `Constant` constructor.
The first case that follows the conditional statement is when the choice
equals 1, which means that the funds from Bob will go to Alice. To
transfer the funds from Bob's internal account to Alice's internal
account, we use the `Pay` constructor. We first specify the party that
sends the money, for which we can use the `Role` statement. After that, we
have to specify the account with the `Account` constructor, which can
again take a `Role` statement. Because we chose the `Account`
constructor, the transfer occurs between internal accounts. There is
also a `Party` constructor that can be used in this field, which takes
an `Address` constructor and sends the money to an external address.
Next, we need to specify the currency and the amount we want to send. At
the end, we write the `Close` constructor, which means that the funds
from the internal accounts will be sent back to the external account of
those parties. The second `Pay` statement is the same, but the roles of
Alice and Bob are reversed, as Charlie will send the funds to Bob if he
makes choice 2.

Let us look at another, more complex example that uses the same Marlowe
constructors. The contract will be an escrow that regulates a funds
transfer between a buyer and a seller. If there is a disagreement
between them, a mediator will decide whether the funds are refunded or
paid to the seller. Below, you can see the Marlowe contract code:

[source,console]
----
When [
  (Case
 	(Deposit (Role "Seller") (Role "Buyer")
    	(Token "" "")
    	(ConstantParam "Price"))
 	(When [
       	(Case
          	(Choice
             	(ChoiceId "Everything is alright" (Role "Buyer")) [
             	(Bound 0 0)]) Close)
       	,
       	(Case
          	(Choice
             	(ChoiceId "Report problem" (Role "Buyer")) [
             	(Bound 1 1)])
          	(Pay (Role "Seller")
             	(Account (Role "Buyer"))
             	(Token "" "")
             	(ConstantParam "Price")
             	(When [
                   	(Case
                      	(Choice
                         	(ChoiceId "Confirm problem" (Role "Seller")) [
                         	(Bound 1 1)]) Close)
                   	,
                   	(Case
                      	(Choice
                         	(ChoiceId "Dispute problem" (Role "Seller")) [
                         	(Bound 0 0)])
                      	(When [
                            	(Case
                               	(Choice
                                  	(ChoiceId "Dismiss claim" (Role "Mediator")) [
                                  	(Bound 0 0)])
                               	(Pay (Role "Buyer")
                                  	(Party (Role "Seller"))
                                  	(Token "" "")
                                  	(ConstantParam "Price") Close))
                            	,
                            	(Case
                               	(Choice
                                  	(ChoiceId "Confirm problem" (Role "Mediator"))
                                        [(Bound 1 1)]) Close)]
                       		 (TimeParam "Mediation deadline")
                       		 Close)
                   		 )]
               		 (TimeParam "Complaint response deadline")
               		 Close))
       		 )]
   		 (TimeParam "Complaint deadline")
   		 Close)
   	 )]
    (TimeParam "Payment deadline")
    Close
----

The next image shows the contract implemented using the
Blockly(((Blockly))) tool:

image::sc_marlowe_contract_escrow.png[width=390,height=1100,title="Marlowe escrow contract"]

First, the buyer must deposit the funds into the seller's internal
account, with the amount defined by the _Price_ parameter. The next
`When` statement presents two options. In the first case, the buyer
confirms everything is fine, and the contract closes. This is handled
using a `Choice` statement, where the buyer has only one option. In the
second case, the buyer reports a problem, and the funds are returned to
the buyer's internal account. Two further possibilities arise: if the
seller agrees with the problem, the contract closes, and the buyer's
funds are transferred back to their external account. If the seller
disputes the issue, and no action is taken by the timeout, the contract
closes, and the buyer is refunded. If disputed, another `When` statement
allows the mediator to either dismiss the claim, transferring the funds
to the seller's internal account before closing the contract, or confirm
the issue, in which case the buyer is refunded, and the contract closes.
If the mediator does not act by their deadline, the contract closes, and
the buyer is refunded. All deadlines are set as time parameters before
the contract is submitted on-chain.

Another feature Marlowe contracts enable is peer-to-peer trustless
lending. A borrower can obtain loans directly from individual lenders,
bypassing traditional financial institutions. An example of a
zero-coupon bond contract, which functions as a peer-to-peer lending
agreement, can be found on the
https://github.com/marlowe-lang/marlowe-starter-kit[Marlowe starter
kit] GitHub page. In this case, the loan is not collateralized, meaning
the lender risks losing the funds if the borrower fails to repay, as the
smart contract cannot enforce repayment. There are a couple of options
to mitigate this risk:

* Back the smart contract with a traditional legal contract
* In some B2B environments, bilateral or multilateral umbrella legal
agreements cover instruments like this
* Combine with a reputation system, as is commonly done in micro-lending
* Add a guarantor to the contract
* Link the contract to a margin account
* Bundle the contract with other instruments to create a structured
product that mitigates the default risk.

Regardless of the Marlowe contract a user interacts with, if role tokens(((role tokens)))
are involved, they can be traded, effectively transferring the token
ownership to another person. A Marlowe contract can facilitate these
token trades, and ownership of role tokens(((role tokens))) can also be traded for
certain time periods. More contract examples can be found in the Marlowe
Playground or the
https://github.com/marlowe-lang/real-world-marlowe[Real world
Marlowe] GitHub repository, which also showcases the off-chain code for
interacting with contracts. Additionally, a
https://github.com/marlowe-lang/marlowe-cardano/tree/main/marlowe-actus[Marlowe
Actus implementation] is available for https://actusfrf.org[Actus].

Marlowe DApps can be discovered by searching the keyword _Marlowe_ in
various https://projectcatalyst.io/search?q=marlowe[Project Catalyst] proposals.
The Marlowe team at IO has also developed the following Marlowe DApps:

* https://github.com/marlowe-lang/marlowe-payouts[Marlowe Payouts]
– helps users discover available payouts from Marlowe contracts on
Cardano, simplifying the tracking and withdrawal process
* https://github.com/marlowe-lang/marlowe-token-plans[Token Plan
Prototype] – allows token providers to create token plans, where they
deposit ada, and release funds over time to a claimer, based on a
time-based scheme
* https://github.com/marlowe-lang/marlowe-order-book-swap[Order Book
Swap Prototype] – a decentralized platform for users to list tokens for
swap, specifying the desired return. Interested parties can accept
offers, resulting in a token swap.

[[chapter8-integrating-with-plinth]]
==== Integrating with Plinth

Marlowe contracts can be integrated with Plinth smart contracts or other
compiled languages(((language, compiled))), such as Aiken, for example. This section focuses on
integration with Plinth. One example is the open roles Plinth smart
contract, which enables interaction with a Marlowe contract where
participants' Cardano addresses(((Cardano, address))) are unknown at deployment. When using
open roles, the Marlowe contract sends role tokens(((role tokens))) to the
https://github.com/marlowe-lang/marlowe-plutus/blob/main/marlowe-plutus/src/Language/Marlowe/Plutus/OpenRoles.hs[open
roles] Plinth validator script that holds them until an address is
specified later. This enables the contract to be verified on-chain
before users interact with it. When the user initiates an action, like a
deposit or choice, the smart contract assigns them the appropriate role
and distributes the role token from the validator script. The developer
simply needs to specify the `OpenRoles` type when setting contract
participants, while Marlowe Runtime manages the rest. The
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe-runtime/doc/open-roles.md[Open
roles in Marlowe] GitHub documentation page explains this process in
more detail.

Marlowe and Plinth validators can interact as follows:

* PlutusTx validators can run in the same transaction as Marlowe
transactions
* The script context contains sufficient information for a
Plinth validator to inspect the Marlowe transaction's redeemer,
incoming, and outgoing datum
* The Marlowe validator will allow the Plinth transaction to run, as
long as the Marlowe validator is not making a payment
* The presence of a datum in the UTXO holding the role token by the
Plinth script does not interfere with Marlowe validation
* The Marlowe validators do not need to be modified to run alongside a
Plinth script that holds the role token.

[[chapter8-future-of-marlowe]]
==== Future of Marlowe

The Marlowe Foundation(((Marlowe, Foundation))) will continue supporting
Marlowe by consolidating and extending it for Cardano DApp builders. This
includes providing oracles(((oracles))) and micropayments(((micropayments))),
optimizing execution, and supporting runtime monetization. Marlowe offers a
lower barrier to entry for DApp development. The new Marlowe DApp starter
kit (DSK), which will be maintained by the Marlowe Foundation(((Marlowe, Foundation))),
will highlight these advancements and streamline onboarding for small and
medium-sized businesses, developers, infrastructure providers, and stake pool
operators(((stake pool, operator))).

Once the intellectual property rights for Marlowe are moved from IO to
the Marlowe Foundation, the Marlowe repositories will be moved to an
independent GitHub organization, and community activities will be
coordinated through the Marlowe special interest group, supported by a
new, members-based, non-profit organization. The Marlowe Foundation(((Marlowe, Foundation)))
created the https://cardano.ideascale.com/c/idea/122392/[Marlowe 2025]
Catalyst application and plans to seek additional funding from Catalyst
and other sources.

image::sc_marlowe_2025_plan.png[width=675,height=468,title="Marlowe 2025 plan"]

The Marlowe 2025 application targets DApp developers and aims to further
Marlowe's development to help businesses leverage emerging market
opportunities, making advanced features more accessible and relevant to
a broader audience. Marlowe can be particularly attractive to businesses
looking to use Cardano because it reduces the risks and costs of initial
blockchain onboarding. The application aims to unlock Marlowe's
potential by implementing critical updates to its validator and tech
stack, transforming the Marlowe Runtime, protocols, and contracts into
competitive products. These updates will create new business
opportunities by making Marlowe tools essential for small and medium
businesses, developers, infrastructure providers, and stake pool operators(((stake pool, operator)))
(SPOs). The Marlowe 2025 application targets the following areas:

* Marlowe DApp starter kit
* Validator enhancements
* Configurable runtime fee mechanism
* Marlowe oracle protocol
* Outreach

[[chapter8-marlowe-dapp-starter-kit]]
===== Marlowe DApp starter kit

The Marlowe DApp starter kit(((DSK))) (DSK) will consolidate the documentation,
examples, and tutorials into an end-to-end guide for designing,
implementing, deploying, and maintaining DApps that leverage Marlowe
tools and capabilities. The DSK will include comprehensive support
materials, such as tutorials, readily available software packages, and
pre-built binaries to ensure ease of implementation. The initial DSK
will be delivered early in the project, with incremental enhancements
added as new technologies are developed.

[[chapter8-validator-enhancements]]
===== Validator enhancements

Targeted changes will be implemented to the current validator to
significantly reduce on-chain execution costs for specific contracts and
Marlowe idioms. By addressing inefficiencies in the existing execution
flow, the changes aim to optimize a set of key contracts with business
value potential. This process will not only improve efficiency but also
expand capabilities, including the integration of off-chain micropayment
channels into the framework. These changes will also be incorporated
across the whole Marlowe toolset. The selected contracts, chosen for
their real-world application potential, will be demonstrated through
DApp prototypes, fully documented and accessible via the marlowe-ts-sdk
for developers to build upon.

[[chapter8-configurable-runtime-fee-mechanism]]
===== Configurable runtime fee mechanism

To encourage infrastructure providers and SPOs to adopt Marlowe, a
configurable fee mechanism will be introduced within the Marlowe
Runtime. This backend enhancement will support the safe execution of
Marlowe contracts via web applications, supported by a new transaction
validation layer in the TypeScript client library. This layer will
ensure secure interactions, even with untrusted backends, facilitating a
wider distribution and adoption of Marlowe technology.

[[chapter8-marlowe-oracle-protocol]]
===== Marlowe oracle protocol

The Marlowe oracle protocol will be formalized and expanded with a
detailed CIP specification, building on the oracle scanner MVP. This
protocol employs a unique on-chain request-response mechanism, offering
distinct advantages over traditional feed-based systems by enabling
extensive data set coverage. The Marlowe Foundation(((Marlowe, Foundation)))
will collaborate with existing oracle
providers on the Cardano network to ensure seamless integration. The
protocol will also be made interoperable with other languages such as
Aiken or Plinth, allowing scripts to efficiently manage oracle data.
This enhancement will not only ensure compatibility with current
technologies but also open up numerous new applications on Cardano.

[[chapter8-outreach]]
===== Outreach

The Marlowe 2025 project aims to enhance community engagement through a
series of live online presentations, leveraging the previous experience
from participating in local and international Cardano summits, meetups,
and workshops. These efforts aim not only to educate, but also to foster
community collaboration to further drive the technology evolution and
refinement.

The Marlowe 2025 proposal marks the first step in launching Marlowe as
an independent project. The Marlowe Foundation(((Marlowe, Foundation)))
will make further bids to
Catalyst and other funding bodies, engaging with the community through
the Special Interest Group and potentially collaborating with other
partners. A key focus will be the development of Marlowe V2 – a separate
conceptual track aimed at fundamental language modifications. This track
will be organized through the creation of Marlowe improvement proposals
(MIPs), in collaboration with the wider community.

[[chapter8-impact-of-marlowe]]
==== Impact of Marlowe

Marlowe has the potential to evolve into a smart contract technology
complementary to Plinth and Aiken.

Marlowe significantly reduces the barriers to entry for new businesses
and developers interested in exploring blockchain solutions by
simplifying the onboarding process. The technology not only mitigates
the complexities of the UTXO model(((UTXO, model))) through a user-friendly yet robust
programming language, but also drastically lowers costs, reduces risks,
and shortens prototyping time for traditional Web2 businesses looking to
integrate blockchain functionality. The introduction of marlowe-ts-sdk
and the Marlowe Runtime, which integrates with familiar REST APIs, make
it straightforward to build end-to-end DApps incorporating Marlowe on-
and off-chain together with traditional web frameworks.

The Marlowe 2025 proposal is designed to sustain and enhance this
project. To accelerate adoption, Marlowe will be enriched with efficient
real-world functionality and innovative features such as off-chain
micropayment channels. The technology's success relies on a thriving
ecosystem around it; therefore, Marlowe improvements in oracle data
availability and infrastructure robustness are critical. By simplifying
the initial onboarding process to a single npm(((npm))) install command, a surge
in Marlowe's usage is anticipated. In doing this, it will benefit a
range of different stakeholders in different ways.

[[chapter8-stakeholder-beneficiaries]]
===== Stakeholder beneficiaries

Marlowe is essential for the Cardano infrastructure. The addition of
oracles(((oracles))) and micro-payments in the Marlowe product will benefit
infrastructure providers by simplifying or expanding their services.
Cardano DApp developers will similarly gain the ability to incorporate
Marlowe features into their development solutions.

The Marlowe DSK is designed for small and medium-sized enterprises and
developers, enabling quick and effective onboarding. By focusing on
developers and lowering barriers throughout the development cycle – from
design to deployment – the DSK will streamline access to Marlowe. The
inclusion of features like micropayments(((micropayments))) and oracles will also attract
potential users in the decentralized finance (DeFi) space. The
simplifications and end-to-end support provided by the DSK will help
users quickly learn about Marlowe's applications and facilitate smoother
onboarding.

The proposal is designed to foster a positive feedback loop within the
Cardano ecosystem, enhancing the symbiotic relationship between Marlowe
technology and its infrastructure. The planned enhancements will not
only benefit developers and businesses, but will also create incentives
for infrastructure providers (possibly SPOs) and oracle services to
engage more deeply with Cardano. This collaborative growth, supported by
the Marlowe special interest group and existing forums, will help forge
a vibrant and sustainable ecosystem, positioning Marlowe as a
cornerstone of the Cardano economy.

[[chapter8-plutus-smart-contracts]]
=== Plutus smart contracts

[[chapter8-overview-and-learning-resources]]
==== Overview and learning resources

The _Plutus smart contracts(((smart contract)))_ section presents the rules
of the Plutus language by demonstrating how to write and interact with Plinth(((Plinth)))
smart contracts (previously known as PlutusTx). Plinth is a high-level smart
contract language embedded in Haskell that compiles to Untyped Plutus Core(((Plutus core)))
(UPLC). Because these rules also apply to other compiled
languages(((language, compiled))) such as Aiken, Plu-Ts, and OpShin, learning
the basics of Plinth helps developers read and write smart contracts in other
languages that target Plutus.

The https://cardano-foundation.github.io/state-of-the-developer-ecosystem/2024/#what-do-you-use-or-plan-to-use-for-writing-plutus-script-validators-smart-contracts[2024
Cardano ecosystem report] shows that Aiken(((Aiken))) is the most used smart contract
language in the Cardano community. It is a user-friendly standalone language
with easy-to-follow and comprehensive documentation. It provides a simple
setup of the development environment needed to write, test, and compile smart
contracts for Cardano. A more detailed comparison of Aiken and Plinth
can be found in the <<chapter8-plinth-in-comparison-to-aiken,
Plinth in comparison to Aiken>> section, which also lists
Aiken learning resources. Plinth(((Plinth))), as a high assurance language embedded in Haskell,
works better with the https://wiki.portal.chalmers.se/agda/pmwiki.php[Agda]
proof assistants that can be used for the formal verification of smart contract
code. The advantages of the Haskell(((Haskell))) programming language are presented
in section <<chapter1-features-and-benefits-of-haskell,
Features and benefits of Haskell>>. IO offers a free self-paced
and beginner-friendly
https://github.com/input-output-hk/haskell-course/[Haskell course]
that is hosted on GitHub and teaches the necessary skills for programmers to
read and write Plinth scripts. The official
https://www.haskell.org/documentation/[Haskell documentation] site
provides more learning resources.

Before reading section _Plutus smart contracts_, one should have a basic
understanding of the extended UTXO (EUTXO) accounting model that is presented
in <<chapter4-the-eutxo-model, The EUTXO model>> section. One should also be
familiar with the types of smart contract languages offered by Cardano, covered in the
<<chapter8-smart-contract-programming-languages,
Smart contract programming languages>> section, which lists each type and provides
resources for development tools. Additionally, understanding Cardano addresses(((Cardano, address)))
and their binary format, as explained in section <<chapter8-cardano-addresses, Cardano addresses>>, is
important. Plinth code examples presented in this section are based on
PlutusV3, which became available after the Chang hard fork(((hard fork, Chang))). From the
https://docs.cardano.org/about-cardano/evolution/upgrades/chang/[Cardano
docs] page, we get a short description of what PlutusV3(((PlutusV3))) brings to
Cardano:

[quote, Cardano docs]
____
With the introduction of PlutusV3, Plutus scripts are available for use
as part of the governance system, enabling sophisticated voting
possibilities like supporting DAOs, for example. Chang also brings
advanced Plutus cryptographic primitives(((cryptographic, primitive))), other new primitives, and
performance enhancements to the platform. These additions provide
developers with a richer smart contract creation toolkit, enhancing both
developer and user experiences, and unlocking new possibilities for
decentralized applications (DApps) on Cardano.
____

Section <<chapter8-plutusv3-features, PlutusV3 features>> explains some of the PlutusV3 features
that are not covered in the coding sections, and highlights the advantages
they bring. The _Plutus smart contracts_ section covers the following topics:

* Plutus in comparison to Bitcoin Script(((Bitcoin script))) and Solidity(((Solidity)))
* Plinth in comparison to Aiken
* Setting up a Plinth development environment(((development environment, Plinth)))
* Simple validation scripts
* Script context explained
* Time-dependent and parameterized validators
* Off-chain code with MeshJS
* Minting policies and native tokens
* PlutusV3 features.

Plinth validator code and https://meshjs.dev/[MeshJS] off-chain code
presented in the _Plutus smart contracts_ section can be found at the
https://github.com/input-output-hk/plutus-pioneer-program/tree/plinth-plutusV3[plinth-plutusV3]
branch of the Plutus Pioneer program(((Plutus Pioneer program))) (PPP)
GitHub repository. This branch contains validator examples of the
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[4th
PPP iteration], translated from PlutusV2 to PlutusV3. In addition
to MeshJS off-chain code, the _plinth-plutusV3_ branch also contains
Lucid Evolution off-chain code examples. Further Cardano learning resources
and smart contract examples in Plinth, Aiken, and other smart contract
languages can be found at:

* https://www.gomaestro.org/smart-contracts[Cardano's smart contract
marketplace] – hosted by Maestro. The platform provides powerful APIs
and advanced software tools to build and scale DApps with ease.
* Gimbalabs(((Gimbalabs))) https://plutuspbl.io/[Plutus project-based learning] –
provides _Course Repositories_ that redirect to Plutus example projects.
More resources are available on their
https://www.youtube.com/@gimbalabs/playlists[YouTube channel].
* Project pages listed in the education sections of
https://www.cardanocube.com/cardano-ecosystem-interactive-map[Cardano's
interactive map]. One can also explore projects in other groups and view
their GitHub repositories.
* https://github.com/johnnygreeney/cardanoforthemasses[Cardano for the Masses]
online book written by John Greene(((Greene, John))) that is available
under an open-source license.
* Cardano foundation's free online https://cardanofoundation.org/academy[Cardano academy]
course, that teaches the basics of blockchain and Cardano.

Cardano's hard fork combinator(((HFC))) technology, briefly introduced in section
<<cardano-node-layers, Cardano node layers>>, subsection _Consensus and storage layer_,
enables the Cardano node(((Cardano node))) to continue processing scripts written in earlier
versions of Plutus even after a hard fork introduces a new Plutus version.
If you encounter smart contract code examples written in PlutusV1(((PlutusV1)))
or PlutusV2(((PlutusV2))), you can check out videos and learning examples of the
previous Plutus Pioneer program iterations:

* https://github.com/input-output-hk/plutus-pioneer-program/tree/third-iteration[third-iteration] - PlutusV1 examples
* https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[fourth-iteration] - PlutusV2 examples.

[[chapter8-plutus-in-comparison-to-bitcoin-script-and-solidity]]
==== Plutus in comparison to Bitcoin Script and Solidity

This section compares the basic characteristics of smart contracts in
Bitcoin(((Bitcoin))), Ethereum(((Ethereum))), and Cardano(((Cardano))),
highlighting the new concepts each introduced in the cryptocurrency space.

A Bitcoin Script(((Bitcoin script))) is a simple stack-based smart contract language, whose
most complex control structure is a conditional. It is written in a
Forth-like non-Turing-complete(((Turing-complete))) language and is essentially linear, which
means it can branch, but the language does not offer looping constructs
or recursion. All Bitcoin scripts terminate, and it is possible to give
an accurate estimate of the time taken to execute a script. Bitcoin
scripts have the following developer limitations (taken from
https://iohk.io/en/research/library/papers/functional-blockchain-contracts/[_Functional
Blockchain Contracts_], _Chakravarty et al. 2019_):

[arabic]
. The Bitcoin Script language constrains programs to be of a limited
size and provides barely any control structures (essentially only
conditional statements). The primitive operations that can be used in
Bitcoin Script are also very limited (for example, the division
operation was originally included but was subsequently disabled).
. The computational context available to a Bitcoin Script program is
very constrained. For example, it cannot inspect a transaction
currently being validated, but it can access the transaction's hash.

A compilation pipeline is being developed at IO that builds a connection
from Cardano smart contracts to Bitcoin. This is done by combining Untyped
Plutus Core (UPLC), the CEK machine - a clever interpreter architecture,
and RISC-V that is a widely supported open-source reduced instruction set
architecture. BitVMX plays a key role, that makes Bitcoin programmable.
It runs computations off-chain, but gives Bitcoin users a way to successfully
challenge suspicious transactions. One can read more about this topic in
the following
https://iohk.io/en/blog/posts/2025/07/19/smart-contracts-on-bitcoin/[IO blog].

Ethereum provides a Turing-complete(((Turing-complete))) language for the Ethereum virtual
machine (EVM), which is the runtime environment for transaction
execution in Ethereum. It also provides Solidity(((Solidity))), a custom higher-level
programming language that compiles into EVM code. Solidity is an
object-oriented, statically typed programming language designed for
developing smart contracts. It supports inheritance, libraries, and
complex user-defined types. Gas fees must be paid for every smart
contract transaction on Ethereum. A Solidity smart contract is able to
see and access information from the entire global state of the
blockchain. That is the opposite extreme of Bitcoin, where the script
has very little context. This enables Ethereum smart contracts to be
more powerful, but it can also make it difficult to predict their
behavior, leading to potential security issues. During the interval
between a user constructing a transaction and its incorporation into the
blockchain, concurrent events may also occur. In Ethereum, it is possible
that a user has to pay gas fees(((gas fee))) for a transaction that interacts with a
smart contract, although it can eventually fail with an error. Ethereum
employs an account-based model, where each user has an account with a
balance. When funds are transferred between accounts, the balances are
updated accordingly.

Cardano uses the EUTXO model and Plutus(((Plutus))) as its native smart
contract language. Developers can write smart contracts in Plinth or in
other high-level languages that compile to Plutus (see section
<<chapter8-smart-contract-programming-languages,
Smart contract programming languages>>). Section 
<<chapter8-plutus-security, Plutus security>>
covers the security aspect of the Plutus language in more detail.
A Plutus smart contract(((smart contract))), also called a Plutus script or validator, provides
a more flexible view than a Bitcoin script, but does not have a global view as
a Solidity(((Solidity))) smart contract. Plutus scripts cannot see the whole state of the
blockchain, but can see the whole transaction that is being validated.
This means a Plutus script can see the script context that carries information
about the transaction being validated. This includes all transaction inputs and
outputs and other transaction data.

A UTXO can have an arbitrary piece of data attached to it, the datum(((datum))),
that can define the state of the UTXO. When a transaction intends to spend
a UTXO sitting at a script address, the script code can access the information
contained in the datum that is potentially present in the script context. Not
every UTXO necessarily needs to contain a datum. The information in the datum can be used for:

* Indicating who can consume a UTXO, when, and under what conditions
* Representing the current state of the UTXO
* Defining metadata and/or configurations.

The script also sees a piece of arbitrary input data provided by the user
submitting the transaction. This data is the redeemer(((redeemer))), which is also contained
in the script context of a transaction. The information in the redeemer can be used for:

* Indicating the purpose of interacting with a script, eg, placing a bet,
paying a fee, or claiming a reward
* Providing information known only to a specific party, which can be used
to unlock funds held at a script address
* Supplying a value that modifies the current datum value.

Section <<chapter8-script-context-explained,
Script context explained>> details the information
contained in the script context that a transaction interacting with a script
can access. A Plutus script can use all this information to decide whether it
is ok to consume a UTXO or not. It is also possible to use a tool like the
Cardano CLI(((Cardano, CLI))) or an off-chain code library to check whether a transaction will
be validated before on-chain execution. If the transaction is valid, it will be
processed on the network, given that all UTXO inputs are present and the
processing time falls within the transaction's validity interval. In case these
conditions are not met, the transaction will fail without charging the user any fees, unlike in Ethereum, where users must pay gas fees(((gas fees))) for transactions
that can ultimately fail. We say that transactions on Cardano are deterministic.
This does not mean
we know for sure if a transaction will be processed because a UTXO input might
be consumed by another transaction just before our transaction gets processed.
It means that if the transaction gets processed, the effect of the transaction
on the ledger is deterministic and can be computed off-chain.

Ethereum's accounting and Cardano's EUTXO models are equally powerful in
expressing smart contract logic. However, translating a smart contract from
Ethereum to Cardano requires rethinking both the design and implementation.
Rewriting the exact logic of an Ethereum smart contract to Cardano will
likely generate an undesired result. A better approach is to analyze the
original contract and produce a high-level specification of what it does.
Then, create a new EUTXO-based architecture based on that specification
to have the same intended properties as the original contract.

Further comparison between Cardano and Ethereum is outlined in section
<<chapter8-cardano-security,
Cardano security>>, which highlights some of the security advantages that
Cardano's EUTXO model brings over Ethereum's EVM model. You can find
research articles about the technical implementation of Plutus in the
https://iohk.io/en/research/library/[IO library]. A good entry point is the research
paper https://iohk.io/en/research/library/papers/functional-blockchain-contracts/[Functional
Blockchain Contracts], 2019 by Chakravarty et al. The official
https://docs.cardano.org/developer-resources/smart-contracts/plutus/[Plutus
documentation] provides short explainers and various learning
resources. The https://github.com/IntersectMBO/plutus[Plutus]
GitHub repository also provides links to specifications, design documents,
academic papers, and talks.

[[chapter8-plinth-in-comparison-to-aiken]]
==== Plinth in comparison to Aiken

Plinth(((Plinth))) enables developers to write and compile their on-chain
code to Plutus, or more precisely to Untyped Plutus Core(((Plutus core)))
(UPLC), which the Cardano nodes execute. Plinth provides a
compiler(((compiler))) plugin for the Glasgow Haskell Compiler (GHC), which
compiles to Plutus. More details about the Plinth-to-Plutus compilation pipeline
are outlined in section <<chapter8-plutus-security, Plutus security>>.

Plinth lets developers build secure applications, forge new assets, and
create smart contracts in a predictable, deterministic environment with
the highest level of assurance. Furthermore, developers don't have to
run a full Cardano node to test their work. The tools that allow testing
Plinth scripts are outlined in the <<chapter8-plutus-security,
Plutus security>> section. The
https://github.com/IntersectMBO/plutus[Plutus] repository includes the
Plinth compiler (previously called PlutusTx), enabling developers to
write Haskell code that can be compiled to Plutus. The repository also
includes the combined
https://intersectmbo.github.io/plutus/haddock/latest[documentation],
generated using Haddock, for all public Plutus code libraries. The
official https://plutus.cardano.intersectmbo.org/docs/[Plinth user
guide] provides developer-related information on Plutus and Plinth.

https://aiken-lang.org/[Aiken] is another popular Cardano smart
contract language written in Rust, which directly compiles to UPLC(((UPLC))).
This process is illustrated in the diagram below:

image::sc_aiken_compilation.png[width=590,height=410,title="Aiken code transformation, source: https://cardanofoundation.org/blog/aiken-the-future-of-smart-contracts[CF blog]"]

Aiken was developed with the support of https://txpipe.io/[TxPipe]
and the https://cardanofoundation.org/[Cardano Foundation].
Currently, IO is also supporting the development of Aiken.
More information about maintenance and support can be found at the
https://aiken-lang.org/credits[official page]. Aiken takes inspiration
from many modern languages, such as Gleam, Rust, and Elm,
which are known for friendly error messages and an overall excellent
developer experience. It is a purely functional language with strong
static typing and inference. It offers a more accessible and familiar
syntax to developers, which makes it easy to learn. Aiken enables
cost-efficient smart contract development(((smart contract, development)))
and comes with a modern
development environment that has a package manager, helpful error
diagnostics, a language-server protocol (LSP) with auto-formatting, and
popular editor integration (VSCode, NeoVim, Emacs). The language is well
documented and offers a built-in testing framework that ensures proper
and robust smart contract execution with property-based testing. Aiken's
testing framework uses the same underlying virtual machine as in real
smart contract execution, ensuring that memory consumption and contract
behavior during testing are identical to those on the mainnet.

Plinth has a more expressive type system than Aiken. It supports basic
Haskell features such as regular algebraic data types, type classes, higher
order functions, parametric polymorphism, etc. However, it doesn’t support
many of Haskell’s more advanced features. For more information, see the
_Differences from Haskell_ section in the official
https://plutus.cardano.intersectmbo.org/docs/using-plinth/differences-from-haskell[Plinth
user guide].
Previously, Plinth compiled and encoded data types using the
https://en.wikipedia.org/wiki/Mogensen–Scott_encoding[Scott-Encoding] approach
(https://well-typed.com/blog/2022/08/plutus-cores[Haskell example], see
section _In Haskell. Scott encoding_),
which created an upfront cost that caused the difference in
execution costs between Haskell and other frameworks like Aiken. With the
introduction of PlutusV3, sums of products(((sums of products))) allow for encoding data types
in a more compact and cost-effective way. Also, Plutus now provides
a way to deal directly with the [purple]#Data# type for all Plutus script
versions (V1, V2, and V3), allowing for better code optimization.
The https://plutus.cardano.intersectmbo.org/docs/working-with-scripts/optimizing-scripts-with-asData[Plinth user guide]
provides instructions on that. Aiken compiles all its custom data types
into the built-in Plutus type [purple]#Data#. We will look at this data
type in section <<chapter8-simple-validation-scripts,
Simple validation scripts>>.

Both languages are purely functional, which makes it easier for an auditor
to assess the behavior of smart contracts written in them. Because Plinth
is embedded in Haskell, it works well with the
https://wiki.portal.chalmers.se/agda/pmwiki.php[Agda] proof-assistant tools,
making it a good choice for projects that require a high level of security.
You can read more about the topic of formally verifying Haskell code with
the Agda proof assistant in the scientific paper
https://iohk.io/en/research/library/papers/reasonable-agda-is-correct-haskell-writing-verified-haskell-using-agda2hs/[Reasonable
Agda Is Correct Haskell: Writing Verified Haskell using agda2hs]. Since Agda
isn't Haskell-specific, it could also be used with Aiken. However, the gap to
bridge between Aiken and Agda is larger than that between Plinth and Agda.

Both Plinth and Aiken compile to Plutus, so the logic of writing such
smart contracts is very similar, even though the syntax is different.
Learning one language will help a developer understand any other Cardano smart
contract language that compiles to Plutus. To learn the Aiken smart contract
language, one can check out the
https://aiken-lang.org/language-tour/primitive-types[Language tour] on
the official documentation, which also provides a walkthrough of creating a
link:++https://aiken-lang.org/example--hello-world/basics++[Hello World project],
covering the following topics:

* Pre-requisites
* Scaffolding
* Using the standard library(((standard library)))
* The first validator
* Adding traces
* Writing a test
* End-to-end off-chain code (MeshJS and PyCardano).

The https://github.com/aiken-lang/awesome-aiken[Awesome Aiken] repository
provides many links to Aiken libraries, DApps, tutorials, and video lessons.
For those who prefer to learn from a book, the
https://book.io/book/i-can-aiken/[I can Aiken] book, written by John
Greene provides comprehensive information and learning examples.

[[chapter8-setting-up-a-plinth-development-environment]]
==== Setting up a Plinth development environment

For your development environment, you can use one of the following
options:

* Run a Nix(((Nix))) shell that contains all the dependencies
* Run a local Docker(((Docker))) container inside VSCode
* Use an online platform such as https://demeter.run/[Demeter.run]
* Install system dependencies manually.

The https://github.com/IntersectMBO/plinth-template/tree/main[plinth-template]
GitHub repository provides instructions for the above mentioned options.
The smart contract code presented throughout section 
<<chapter8-plutus-smart-contracts, Plutus smart contracts>>
uses features introduced in the Chang hard fork(((hard fork, Chang))), which
enabled PlutusV3. The development environment you will use to run and test
this code needs to support these features. The smart contract code was compiled
with a Nix shell. Nix version `2.25.3` was used and a Nix shell provided by
the https://github.com/IntersectMBO/plinth-template[plinth-template]
repository, commit `b9460088985331bb050f1782a32e4f92c4c00e67`.

The https://demeter.run/[Demeter.Run] online platform offers various
tools and development environments for the Cardano ecosystem. One can
set up development environments for smart contract languages such as
Plinth and Aiken. Also, programming languages like Rust or Python, that
come with useful Cardano tools and libraries are available. The platform
offers backend hosting for DApps and allows
integration testing within its environments. It manages monitoring,
security, and version upgrades. Depending on development needs, the
platform provides various starter kits, including example code
repositories from the community for learning or project initiation. Its
pricing model is based on service usage, with users also able to access
some free working time. Explore _Developer Tools_ and _Infrastructure_ sections
on the https://www.cardanocube.com/cardano-ecosystem-interactive-map[Cardano
developer map] for more options.

To query various Plutus types, one can use the official
https://plutus.cardano.intersectmbo.org/haddock/latest/[Plutus Haddock
documentation], which presents types in Haskell syntax. Press CTRL + S
to search for a keyword, such as a specific data type or function name.
The search engine might provide more options for a single data type, function
or type class you are querying. This is because implementations
of types, functions, and type classes can change with a new Plutus version
and the Haddock documentation keeps track of all of them.
After locating the desired item, click the _Source_ icon next to its
name to open the corresponding Haskell source code.
The software packages for the libraries documented in the Plutus Haddock
documentation are distributed via the
https://github.com/IntersectMBO/cardano-haskell-packages[Cardano
Haskell package repository] (CHaP), which contains packages not hosted
on https://hackage.haskell.org/[Hackage] – the central archive for Haskell packages.
Other compiled languages(((language, compiled))) provide their own libraries
that implement Plutus types. One example is the Aiken
https://aiken-lang.github.io/stdlib/[standard library].

Plinth data types cannot be explored in the standard GHCi REPL. The
GHC compiler(((GHC, compiler))) pipeline first compiles Plinth code to an intermediate
language called GHC Core(((GHC, core))). The Plutus compiler then takes this
GHC Core and with some intermediate steps compiles it to Untyped Plutus Core
(UPLC). The compilation pipeline is further explained in section 
<<chapter8-plutus-security, Plutus security>>.
Additionally, the Plinth libraries are not hosted on Hackage, which means the only way
to query Plinth types from a REPL is to build it with a Cabal file that imports
those libraries.

[[chapter8-simple-validation-scripts]]
==== Simple validation scripts

In this section, we will look at basic Plinth validation scripts. All
validation scripts and data types presented in the 
<<chapter8-plutus-smart-contracts, Plutus smart contracts>>
section are PlutusV3 scripts and data types. An exception are PlutusV1
and V2 data types that were not modified with the introduction of PlutusV3(((PlutusV3)))
and can be still used in PlutusV3 scripts. A validation script(((validation script))) or
validator is the smart contract program that checks whether funds at a
script address(((script, address))) are allowed to be spent by a given transaction. As stated
previously, a validation script in EUTXO cannot see the entire state of
the blockchain; instead, it can view the entire transaction being validated.
The script uses a single parameter: the script context. It returns a value
that indicates whether the validation logic has passed or not. Depending on
the type of the script context, there are two possible implementations of
a Plinth validation script:

* In the low-level implementation, the script context is represented
using the [purple]#BuiltinData# type, and the return value is of type
[purple]#BuiltinUnit#.
* In the high-level implementation, the script context is represented as
a predefined Haskell type, and the return value is of type [purple]#Bool#.

Below you can see two example validation script type signatures, one
low-level and one high-level:

[source,haskell]
----
validatorName :: BuiltinData -> BuiltinUnit
validatorName :: ScriptContext -> Bool
----

Both implementations can be used in smart contract code. The main
difference lies in code performance, with the low-level implementation
offering better performance. Low-level validation scripts are referred
to as _untyped validation scripts(((validation script, untyped)))_,
while high-level scripts are known as
_typed validation scripts(((validation script, typed)))_.

The [purple]#BuiltinData# doesn't have its constructors exposed. The module
that defines [purple]#BuiltinData# contains two conversion functions:
[blue]#builtinDataToData# and [blue]#dataToBuiltinData#, that can
convert [purple]#BuiltinData# back and forth to the [purple]#Data# type. These functions
can be used in off-chain code, but not in on-chain code. The [purple]#Data# type has
its constructor exposed, as illustrated in the code below:

[source,haskell]
----
data Data
    = Constr Integer [Data]
    | Map [(Data, Data)]
    | List [Data]
    | I Integer
    | B BS.ByteString
    deriving stock (Show, Read, Eq, Ord, Generic, Data.Data.Data)
    deriving anyclass (Hashable, NFData, NoThunks)
----

It is a recursive algebraic data type that can represent integers, byte strings,
lists, and maps. Next, we show the Haskell implementation of the script context data type:

[source,haskell]
----
data ScriptContext = ScriptContext
  { scriptContextTxInfo     :: TxInfo
  , scriptContextRedeemer   :: V2.Redeemer
  , scriptContextScriptInfo :: ScriptInfo
  }
  deriving stock (Generic, Haskell.Eq, Haskell.Show)
  deriving anyclass (HasBlueprintDefinition)
----

The script context contains:

* transaction information (inputs, outputs, validity interval, etc.)
* redeemer (arbitrary data defined by the user)
* script information (defines the purpose of the script, such as spending or minting;
for a spending script, the script information potentially contains a datum).

We will look into those data types in more detail in section
<<chapter8-script-context-explained, Script context explained>>.
If a transaction tries to spend multiple UTXOs
at a script address, the spending script is run for every UTXO individually.
The redeemer and the script information(((script, information))) are individually assigned for every
UTXO in that transaction. The transaction information is only one and is
accessible to every script instance that is being triggered by a single transaction.

Let us now examine a simple untyped validator script that always succeeds:

[source,haskell]
----
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveAnyClass             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost        #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE Strict                     #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE ViewPatterns               #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# OPTIONS_GHC -fno-full-laziness #-}
{-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}
{-# OPTIONS_GHC -fno-omit-interface-pragmas #-}
{-# OPTIONS_GHC -fno-spec-constr #-}
{-# OPTIONS_GHC -fno-specialise #-}
{-# OPTIONS_GHC -fno-strictness #-}
{-# OPTIONS_GHC -fno-unbox-small-strict-fields #-}
{-# OPTIONS_GHC -fno-unbox-strict-fields #-}
{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}

module Week02.Validators where

import GHC.Generics                  (Generic)
import PlutusLedgerApi.Common        (FromData (fromBuiltinData),
                                      SerialisedScript,
                                      serialiseCompiledCode)
import PlutusLedgerApi.V3            (Redeemer (getRedeemer),
                                      ScriptContext (..))
import PlutusTx                      (BuiltinData, CompiledCode,
                                      UnsafeFromData (unsafeFromBuiltinData),
                                      compile, makeIsDataSchemaIndexed)
import PlutusTx.Builtins             (unsafeDataAsI)
import PlutusTx.Bool                 (Bool (..))
import PlutusTx.Prelude              (BuiltinUnit, Eq (..), Integer,
                                      Maybe (..), check, traceError,
                                      traceIfFalse, ($), otherwise,
                                      (.))
import PlutusTx.Blueprint            (HasBlueprintDefinition)
import PlutusTx.Blueprint.Definition (definitionRef)
import qualified PlutusTx.Builtins.Internal as BI (
                                      BuiltinList, BuiltinInteger,
                                      head, snd, tail, unitval,
                                      unsafeDataAsConstr)

{- ----------------------------------------------------------------------------- -}
{- --------------------------- Always True validator --------------------------- -}

{-# INLINEABLE mkGiftValidator #-}
mkGiftValidator :: BuiltinData -> BuiltinUnit
mkGiftValidator _ctx = check True

compiledMkGiftValidator :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledMkGiftValidator = $$(compile [||mkGiftValidator||])

serializedMkGiftValidator :: SerialisedScript
serializedMkGiftValidator = serialiseCompiledCode compiledMkGiftValidator
----

The long list of language pragmas, GHC compiler(((compiler))) options, and import statements
is necessary to cover the functionality for all validators presented in the
<<chapter8-simple-validation-scripts, Simple validation scripts>> section.
From the language pragmas, we note that
we add the [purple]#NoImplicitPrelude# extension that prevents the standard
`Prelude` module from being imported. The `PlutusTx` module defines a custom
prelude where all functions use strict evaluation rather than lazy evaluation.
This also applies to all other functions defined in any module used for
Plinth coding. One can read more about GHC language pragmas at the
https://wiki.haskell.org/Language_Pragmas[Haskell wiki], which provides
links to official GHC documentation. The
https://downloads.haskell.org/ghc/latest/docs/users_guide/using-optimisation.html#ghc-flag--ffull-laziness[GHC docs]
also cover various GHC compiler(((compiler))) options. We name our module `Week02.Validators`.
The naming of modules through the <<chapter8-plutus-smart-contracts,
Plutus smart contracts>> code examples section follows the naming from the
https://github.com/input-output-hk/plutus-pioneer-program/tree/fourth-iteration[fourth
iteration] of the Plutus pioneer program.
Next, we import several submodules from the `PlutusLedgerApi` and the `PlutusTx`
modules that define functions for working with PlutusV3 scripts.

Next, the on-chain validator code follows. We name the validator function
[blue]#mkGiftValidator# -- which means _make gift validator_. It is an untyped validator
that always succeeds. It takes in the script context as the only argument, which is
of type [purple]#BuiltinData#, and returns something of type [purple]#BuiltinUnit#.
In the body of the function, the script context is ignored, and we use the [blue]#check#
function which takes a value of type [purple]#Bool#, and returns a value of type
[purple]#BuiltinUnit# if the input argument is true, or raises an error if it is false.

[source,haskell]
----
check :: Bool -> BI.BuiltinUnit
check b = if b then BI.unitval else traceError checkHasFailedError

unitval :: BuiltinUnit
unitval = BuiltinUnit ()

data BuiltinUnit = BuiltinUnit ~() deriving stock Data
----

The [blue]#check# function returns the [blue]#unitval# variable that is a
wrapper around the unit (empty tuple) type. The unit type in Haskell (`()`)
indicates that a function returns no specific meaningful value, similar to `void`
in languages like Java or C++. If an untyped validator returns the [purple]#BuiltinUnit#
type the validation logic passes, and if an error is raised, the validation
logic fails. It is now clear why this validator is called `Gift` – anyone can
claim funds from this address, since the validation will always succeed.

Next, we compile the validator. We use the [blue]#PlutusTx.compile# function
that takes a syntax tree of a function as input, which we can get if we put the
Oxford brackets [blue]#[||mkGiftValidator||]# around the validator function. The
[blue]#compile# function produces another syntax tree written in the Plutus
language. Then the [blue]#$$# symbol, called splice, takes a syntax tree and splices
it back to Haskell source code. The splice operator and the Oxford
brackets can be used because we added the [purple]#TemplateHaskell# language
pragma, which enables this language extension.

It is important to note that normally in Oxford brackets, you cannot
reference anything defined outside of them. This can become an issue
when validator functions are long expressions or when library functions
are called within their body. A workaround is to make the function
inlinable. By adding the [purple]#INLINABLE# pragma statement before or
after the function definition, the GHC compiler(((compiler))) replaces the function call
in the Oxford brackets with the actual function body.

This completes the on-chain code. Next, we use the [blue]#serialiseCompiledCode#
helper function that returns something of type [purple]#ShortByteString#, which
is a compact representation of a [purple]#Word8# vector (8-bit unsigned integer type).
At the end of this section, we present the code that lets us generate
https://cips.cardano.org/cip/CIP-57[Plutus blueprints]
for all the validators presented in this section. Plutus blueprints allow documenting
Plutus validators in `JSON` format and include the compiled validator code that is
represented as a `CBORHEX(((CBORHEX)))`. The https://en.wikipedia.org/wiki/CBOR[Concise Binary
Object Representation] (`CBOR(((CBOR)))`) is a binary data serialization format loosely based
on `JSON`. The `CBORHEX` is a hexadecimal representation of this data format.
For our [blue]#mkGiftValidator# the blueprint will show the following `CBORHEX`:

[source,json]
----
"compiledCode": "450101002499"
----

Since our contract is simple, the `CBORHEX` value is short. For more complex
contracts, this value would increase in length. This compiled code can then be
used in off-chain code when attaching the validator to a transaction. Let us now
explore an example where the validation logic always fails, regardless of the input.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- --------------------------- Always False validator --------------------------- -}

{-# INLINEABLE mkBurnValidator #-}
mkBurnValidator :: BuiltinData -> BuiltinUnit
mkBurnValidator _ctx = traceError "it burns!!!"

compiledMkBurnValidator :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledMkBurnValidator = $$(compile [||mkBurnValidator||])

serializedMkBurnValidator :: SerialisedScript
serializedMkBurnValidator = serialiseCompiledCode compiledMkBurnValidator
----

We call the validator [blue]#mkBurnValidator#, since no funds can be reclaimed from
the contract once sent. The [blue]#traceError# function can produce an
error and log a message displayed by the failed off-chain code transaction
that tries to claim any funds from this script address. Also, in this case, we ignore
the entire script context. Then we compile the validator and serialize it. We could
also use the [blue]#check# function with a `False` argument; in that scenario, the
validation would still fail, but no custom error message would be logged.

Next, we show an example where we make use of the redeemer(((redeemer))) in the validation logic.
The redeemer type is defined as a wrapper around the [purple]#BuiltinData# data type:

[source,haskell]
----
newtype Redeemer = Redeemer {getRedeemer :: BuiltinData}
  deriving stock (Generic, Haskell.Show, Typeable)
  deriving newtype (Haskell.Eq, Haskell.Ord, Eq, ToData, FromData,
                    UnsafeFromData, Pretty)
  deriving anyclass (NFData, HasBlueprintDefinition)
----

We define an untyped validator that says the validation logic passes if the redeemer
is an integer with the value 42; otherwise, it fails:

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- ----------------------- 42 validator untyped large CBOR ---------------------- -}

{-# INLINEABLE mk42ValidatorLarge #-}
mk42ValidatorLarge :: BuiltinData -> BuiltinUnit
mk42ValidatorLarge ctx
    | r == 42   = BI.unitval
    | otherwise = traceError "Expected 42 integer redeemer"
 where
  ctxTyped = case fromBuiltinData ctx of
    Just @ScriptContext c -> c
    Nothing -> traceError "ScriptContext could not be converted from BuiltinData"
  r = case fromBuiltinData $ getRedeemer (scriptContextRedeemer ctxTyped) of
    Just @Integer n -> n
    Nothing -> traceError "Redeemer is not a number"

compiledMk42ValidatorLarge :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledMk42ValidatorLarge = $$(compile [||mk42ValidatorLarge||])

serializedMk42ValidatorLarge :: SerialisedScript
serializedMk42ValidatorLarge = serialiseCompiledCode compiledMk42ValidatorLarge
----

In the example above, we first convert the untyped script context to its
typed form using the [blue]#fromBuiltinData# function. It takes in
a variable of type [purple]#BuiltinData# and returns a [purple]#Maybe# type parameterized
with a type variable. If that type variable is a type that has an instance of the
[purple]#FromData# type class, then the conversion will succeed. Otherwise, the function returns
[purple]#Nothing#. You can find class instances for various Plutus types in the Plutus
https://plutus.cardano.intersectmbo.org/haddock/latest/[Haddock documentation].
There also exists the [blue]#unsafeFromBuiltinData# function that is defined in the
[blue]#UnsafeFromData# type class. This function directly returns a type variable
instead of wrapping it in a [purple]#Maybe# type. If the conversion fails,
the function raises an error, and the validation logic fails. We call it _unsafe_
since the conversion might fail with an error. Below
you can see the [purple]#FromData# and [purple]#UnsafeFromData# type classes.

[source,haskell]
----
class FromData a where
  fromBuiltinData :: BuiltinData -> Maybe a

class UnsafeFromData a where
  unsafeFromBuiltinData :: BuiltinData -> a
----

Once we have the script context in typed form, we can access the redeemer,
a wrapper around the [purple]#BuiltinData# type. Then we again try to convert
that type, in this case to an [purple]#Integer#. Now that the redeemer is in the
correct form, we can simply check if it is equal to 42 and return the [blue]#unitval#
variable or raise an error and log a message. We could also use the [blue]#check#
function as we did in our previous examples. After that, we compile and serialize
the validator.

The reason why we stated _"large CBOR(((CBOR)))"_ in the comment above the code is that
converting the script context into a typed form is a costly operation and produces
a large CBOR. Next, let us look at the same validator in untyped form, where
we decode the script by keeping it in the form of the [purple]#BuiltinData# type.
At the end of this section, we will compare `CBORHEX(((CBORHEX)))` lengths for
all validators presented in this section that check if the redeemer equals 42.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- ----------------------- 42 validator untyped small CBOR ---------------------- -}

{-# INLINEABLE mk42ValidatorSmall #-}
mk42ValidatorSmall :: BuiltinData -> BuiltinUnit
mk42ValidatorSmall ctx
    | redeemerInt == 42 = BI.unitval
    | otherwise         = traceError "Expected 42 integer redeemer"
 where
    -- Lazily decode script context up to redeemer;
    -- is less expensive and results in much smaller tx size
    constrArgs :: BuiltinData -> BI.BuiltinList BuiltinData
    constrArgs = BI.snd . BI.unsafeDataAsConstr

    scriptContextBL :: BI.BuiltinList BuiltinData
    scriptContextBL = constrArgs ctx

    redeemerBD :: BuiltinData
    redeemerBD = BI.head . BI.tail $ scriptContextBL

    redeemerInt :: BI.BuiltinInteger
    redeemerInt = unsafeDataAsI redeemerBD

compiledMk42ValidatorSmall :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledMk42ValidatorSmall = $$(compile [||mk42ValidatorSmall||])

serializedMk42ValidatorSmall :: SerialisedScript
serializedMk42ValidatorSmall = serialiseCompiledCode compiledMk42ValidatorSmall
----

First, we define a function called [blue]#constrArgs# that helps us to
convert the [purple]#BuiltinData# to the [purple]#BuiltinList# type. We
recall that the script context is an algebraic product data type that
combines the transaction information, redeemer, and script information types.
Once we have converted the script context to a built-in list, we can use the
[blue]#tail# and [blue]#head# functions to extract the needed element.
In the case of the script context, the redeemer is in the second place, so
we first apply the [blue]#tail# function and then the [blue]#head# function.
Once we have the redeemer in the form of [purple]#BuiltinData#, we can use
the [blue]#unsafeDataAsI# that converts it to an integer. It is called
_unsafe_ because it raises an error if the conversion fails. Next, we
compile and then serialize the validator.

We note that if the redeemer were a more structured algebraic
data type, we could further decode it with the [blue]#constrArgs#, [blue]#tail#
and [blue]#head# functions, or we could use the [blue]#fromBuiltinData# function
to convert it to its typed form and access the elements we need.

Let us look now at the same validator that is written in a typed form.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- ----------------------------- 42 validator typed ----------------------------- -}

{-# INLINEABLE mk42TypedValidator #-}
mk42TypedValidator :: ScriptContext -> Bool
mk42TypedValidator ctx = traceIfFalse "Redeemer is a number different than 42"
                                      $ 42 == r
 where
  r = case fromBuiltinData $ getRedeemer (scriptContextRedeemer ctx) of
    Just @Integer n -> n
    Nothing -> traceError "Redeemer is not a number"

compiledMk42TypedValidator :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledMk42TypedValidator = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinUnit
  wrappedVal ctxUntyped = check $ mk42TypedValidator (unsafeFromBuiltinData ctxUntyped)

serializedMk42TypedValidator :: SerialisedScript
serializedMk42TypedValidator = serialiseCompiledCode compiledMk42TypedValidator
----

The type signature now changes to `ScriptContext -> Bool`, which means
the validator succeeds if the logic returns `True` and fails if it returns
`False`. We can now access the redeemer directly from the script context
in its typed form and then try to convert the data inside the redeemer from
[purple]#BuiltinData# to [purple]#Integer#. To compile this typed validator,
we need to wrap it with a function that accepts [purple]#BuiltinData# for its
argument. We use the [blue]#unsafeFromBuiltinData# that converts the
script context from its untyped form to typed, and then apply the
[blue]#mk42TypedValidator# and [blue]#check# functions. After that, we can
compile the wrapped validator and serialize it.

At the end, we can look at one final validator example where we define
a custom redeemer type that is a wrapper around an [purple]#Integer# type.
In the body of the validator we again match the integer number to 42.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- -------------------------- 42 validator custom type -------------------------- -}

-- Custom data types for our redeemer
data MySillyRedeemer = MkMySillyRedeemer Integer
  deriving stock (Generic)
  deriving anyclass (HasBlueprintDefinition)

makeIsDataSchemaIndexed ''MySillyRedeemer [('MkMySillyRedeemer, 0)]

{-# INLINEABLE mk42CustomValidator #-}
mk42CustomValidator :: ScriptContext -> Bool
mk42CustomValidator ctx = traceIfFalse "Redeemer is a number different than 42"
                                       $ 42 == r
 where
   r = case fromBuiltinData @MySillyRedeemer . getRedeemer $
                            scriptContextRedeemer ctx of
     Just (MkMySillyRedeemer rInt) -> rInt
     Nothing -> traceError "Redeemer is not of MySillyRedeemer type."

compiledMk42CustomValidator :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledMk42CustomValidator = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinUnit
  wrappedVal ctx = check $ mk42CustomValidator (unsafeFromBuiltinData ctx)

serializedMk42CustomValidator :: SerialisedScript
serializedMk42CustomValidator = serialiseCompiledCode compiledMk42CustomValidator
----

Here, we first define the custom data type [purple]#MySillyRedeemer#
which is a wrapper around the [purple]#Integer# type. Then we use the
[blue]#makeIsDataSchemaIndexed# function that generates the [purple]#ToData#,
[purple]#FromData#, [purple]#UnsafeFromData# and [purple]#HasBlueprintSchema#
instances for our custom type, which contain functions for converting our custom
data type to the [purple]#Data# type back and forth. We use template Haskell,
which requires adding two single quotes in front of the type to refer to the
type itself, allowing Template Haskell to generate the necessary instances.
After we have defined our redeemer type, we write the
validator logic in the same way as in the previous example, just that we now
convert the redeemer from [purple]#BuiltinData# to the [purple]#MySillyRedeemer#
type. We compile and serialize the validator in the same way as in the previous example.

Altogether, we have defined four different variants for the validator that 
matches the redeemer to the number 42. We note that if we were to import the
[purple]#ScriptContext# data type from the
`PlutusLedgerApi.Data.V3` module instead of the `PlutusLedgerApi.V3` module,
the `CBORHEX(((CBORHEX)))` lengths decrease by around 10%. The table below shows compiled
code lengths for the four validators and for the two different `PlutusLedgerApi`
modules we can use.

[cols="30,^25,^30,^15", options="header"]
|===
|42 validator
|PlutusLedgerApi.V3
|PlutusLedgerApi.Data.V3
|Reduction

|Untyped (converting ScriptContext to typed form)
|13842
|12362
|10.7%

|Untyped (decoding ScriptContext as BuiltinData)
|64
|64
|0%

|Typed (Integer type redeemer)
|5887
|5248
|10.8%

|Typed (custom type redeemer)
|6066
|5428
|10.5%
|===

We see that we get, by far, the most compact compiled code if we decode the
[purple]#ScriptContext# in its untyped form and then convert the part we need
to typed form. We call that lazy decoding. This also brings an on-chain code
performance advantage. We get the largest `CBORHEX(((CBORHEX)))` for the untyped
validator, where we convert the entire [purple]#ScriptContext# into typed form
in the body of the validator. The reason is this type carries much information
and converting the whole type into typed form is a costly operation.

The reason the compiled code is shorter if we import the [purple]#ScriptContext#
from the `PlutusLedgerApi.Data.V3` module is that module provides an alternative
interface that works directly with the Plutus Core(((Plutus core))) [purple]#Data#
type under the hood. Due to Plutus updates, data types can now be thin wrappers over the [purple]#BuiltinData#
type, which allows retaining the user-friendliness of the data type version while also
avoiding the upfront cost of decoding the [purple]#BuiltinData# into sums of products.
We call a data type _data-backed_ if it is representationally equivalent to [purple]#BuiltinData#.

Since Plutus now provides a way to deal directly with the [purple]#Data# type
for all Plutus script versions (V1, V2, and V3), developers can move away from sums of
products(((sums of products))) or Scott encoding. The
https://plutus.cardano.intersectmbo.org/docs/working-with-scripts/optimizing-scripts-with-asData[Plinth user guide]
provides instructions on how to optimize scripts with the `PlutusTx.asData`
module that contains Template Haskell (TH) code for encoding algebraic data
types (ADTs) as `Data` objects in Plutus Core(((Plutus core)))
such that they become _data-backed_
types. The `PlutusLedgerApi.Data.V3` module already contains the [purple]#ScriptContext#
in the form of a _data-backed_ type. Also, one can look at the
https://plutus.cardano.intersectmbo.org/docs/working-with-scripts/simplifying-before-compilation[Simplifying code before compilation]
and https://plutus.cardano.intersectmbo.org/docs/working-with-scripts/other-optimization-techniques[Other optimization techniques] guidelines.

We again state the various possibilities that a redeemer can be used for
in smart contracts:

* Indicating the purpose of interacting with a script, e.g., placing a bet,
paying a fee, or claiming a reward
* Providing information known only to a specific party, which can be used
to unlock funds held at a script address
* Supplying a value that modifies the current datum value.

Finally, we show the code for generating Plutus blueprints for two of the
six validators we have defined in this section to shorten the code. We choose
the gift validator and the untyped 42 validator that generates a small CBOR(((CBOR))).

[source,haskell]
----
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DerivingStrategies    #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE TypeApplications      #-}
{-# LANGUAGE UndecidableInstances  #-}

module Main where

import qualified Data.ByteString.Short       as Short
import qualified Data.Set                    as Set
import           PlutusTx.Blueprint
import qualified Week02.Validators           as Week02

{- ------------------------------------------------------------------------------ -}
{- --------------------------------- ENTRY POINT -------------------------------- -}

main :: IO ()
main = writeBlueprint "blueprint.json" blueprint

{- ------------------------------------------------------------------------------ -}
{- ------------------------------------- SHARED --------------------------------- -}

blueprint :: ContractBlueprint
blueprint =
  MkContractBlueprint
    { contractId = Just "plutus-pioneer-program"
    , contractPreamble = preamble
    , contractValidators =
        Set.fromList
          [ mkGiftVal
          , mk42ValSmall
          ]
    , contractDefinitions =
        deriveDefinitions
          @[ ()
           , Integer
           ]
    }

preamble :: Preamble
preamble =
  MkPreamble
    { preambleTitle = "Plutus Pioneer Program Blueprint"
    , preambleDescription = Just "Blueprint for the Plutus Pioneer Program validators"
    , preambleVersion = "1.0.0"
    , preamblePlutusVersion = PlutusV3
    , preambleLicense = Just "MIT"
    }
----

We first define all language pragmas and import the necessary modules, including the
`Week02.Validators` module, where we have defined our validators from this section.
In the [blue]#main# function, we write the blueprint to a `JSON` file, and after
that, the blueprint definition. It contains the contract ID, the preamble
that defines some general information, the contract validators, defined next, and the contract definitions. The definitions include a list of types
that we have used in the validator code. After that, we see the [blue]#preamble#
definition. Next, we show the validator blueprint(((validator blueprint)))
definitions for two validators that we have chosen.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- ----------------------------- VALIDATORS - WEEK02 ---------------------------- -}

mkGiftVal :: ValidatorBlueprint referencedTypes
mkGiftVal =
  MkValidatorBlueprint
    { validatorTitle = "Always True Validator"
    , validatorDescription = Just "Validator that always returns True (always succeeds)"
    , validatorParameters = []
    , validatorRedeemer =
        MkArgumentBlueprint
          { argumentTitle = Just "Redeemer"
          , argumentDescription = Just "Redeemer for the always true validator"
          , argumentPurpose = Set.fromList [Spend, Mint, Withdraw, Publish]
          , argumentSchema = definitionRef @()
          }
    , validatorDatum = Nothing
    , validatorCompiledCode =
        Just . Short.fromShort $ Week02.serializedMkGiftValidator
    }

mk42ValSmall :: ValidatorBlueprint referencedTypes
mk42ValSmall =
  MkValidatorBlueprint
    { validatorTitle = "42 Validator untyped - small CBOR"
    , validatorDescription = Just "Validator that returns true only
                                   if the redeemer is 42"
    , validatorParameters = []
    , validatorRedeemer =
        MkArgumentBlueprint
          { argumentTitle = Just "Redeemer"
          , argumentDescription = Just "Redeemer for the 42 validator"
          , argumentPurpose = Set.fromList [Spend, Mint, Withdraw, Publish]
          , argumentSchema = definitionRef @Integer
          }
    , validatorDatum = Nothing
    , validatorCompiledCode =
        Just . Short.fromShort $ Week02.serializedMk42ValidatorSmall
    }
----

For every validator we can use boilerplate code to define a blueprint. The
blueprint defines the validator title, description, parameters that are defined
if we have a parameterized validator, redeemer information, datum information,
and the compiled code, which we reference from the `Week02.Validators` module
that we have imported. One can extend the blueprint code such that it generates
the data and compiled code for all six validators that we defined in this section.
All validators presented in section <<chapter8-plutus-smart-contracts,
Plutus smart contracts>> can be found at the
https://github.com/input-output-hk/plutus-pioneer-program/tree/plinth-plutusV3[plinth-plutusV3]
branch of the Plutus pioneer program, which also contains a `blueprint.json` file
with all compiled validator code. Below is an example blueprint for the blueprint
code we have defined in this section. The compiled validator code is contained in
the `"compiledCode"` fields.

[source,json]
----
{
  "$id": "plutus-pioneer-program",
  "$schema": "https://cips.cardano.org/cips/cip57/schemas/plutus-blueprint.json",
  "$vocabulary": {
    "https://cips.cardano.org/cips/cip57": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true
  },
  "preamble": {
    "title": "Plutus Pioneer Program Blueprint",
    "description": "Blueprint for the Plutus Pioneer Program validators",
    "version": "1.0.0",
    "plutusVersion": "v3",
    "license": "MIT"
  },
  "validators": [
    {
      "title": "Always True Validator",
      "description": "Validator that always returns True (always succeeds)",
      "redeemer": {
        "title": "Redeemer",
        "description": "Redeemer for the always true validator",
        "purpose": {
          "oneOf": [
            "spend",
            "mint",
            "withdraw",
            "publish"
          ]
        },
        "schema": {
          "$ref": "#/definitions/Unit"
        }
      },
      "compiledCode": "450101002499",
      "hash": "acec2df7c07075dc7618ffc17c4d86aa786509e646057bd2bdab4cfc"
    },
    {
      "title": "42 Validator untyped - small CBOR",
      "description": "Validator that returns true only if the redeemer is 42",
      "redeemer": {
        "title": "Redeemer",
        "description": "Redeemer for the 42 validator",
        "purpose": {
          "oneOf": [
            "spend",
            "mint",
            "withdraw",
            "publish"
          ]
        },
        "schema": {
          "$ref": "#/definitions/Integer"
        }
      },
      "compiledCode": "581e010100255333573466e1d2054375a6ae84d5d11aab9e3754002229308b01",
      "hash": "6828334183fe0deb5576416c73448fdf40cf1c158195b8a24fe9bc45"
    }
  ],
  "definitions": {
    "Integer": {
      "dataType": "integer"
    },
    "Unit": {
      "dataType": "constructor",
      "fields": [],
      "index": 0
    }
  }
}
----

We also show the `cabal.project` and `.cabal` files we use to compile the code.
Let's look at the `cabal.project` file.

[source,haskell]
----
repository cardano-haskell-packages
  url: https://chap.intersectmbo.org/
  secure: True
  root-keys:
    3e0cce471cf09815f930210f7827266fd09045445d65923e6d0238a6cd15126f
    443abb7fb497a134c343faf52f0b659bd7999bc06b7f63fa76dc99d631f9bea1
    a86a1f6ce86c449c46666bda44268677abf29b5b2d2eb5ec7af903ec2f117a82
    bcec67e8e99cabfa7764d75ad9b158d72bfacf70ca1d0ec8bc6b4406d1bf8413
    c00aae8461a256275598500ea0e187588c35a5d5d7454fb57eac18d9edb86a56
    d4a35cd3121aa00d18544bb0ac01c3e1691d618f462c46129271bccf39f7e8ee

index-state:
  -- Bump both the following dates if you need newer packages from Hackage
  , hackage.haskell.org 2024-09-10T13:49:28Z
  -- Bump this if you need newer packages from CHaP
  , cardano-haskell-packages 2024-09-10T13:49:28Z

packages:
  ./.
----

In the file, we define the
https://github.com/IntersectMBO/cardano-haskell-packages[CHAP repository]
that contains all Haskell packages used by Cardano that are not hosted on
https://hackage.haskell.org/[Hackage], the Haskell community's central package
archive. When compiling the project, the `cabal(((cabal)))` tool can then
download the Plutus packages defined in the `.cabal` file. Next, we look at the
`.cabal` file.

[source,haskell]
----
cabal-version:   3.0
name:            plinth-plutusV3
version:         0.1.0.0
license:
build-type:      Simple
extra-doc-files: README.md

common options
  ghc-options: -Wall
  default-language: Haskell2010

library scripts
  import:         options
  hs-source-dirs: src
  exposed-modules:
    Week02.Validators

  build-depends:
    , base
    , plutus-core        ^>=1.34
    , plutus-ledger-api  ^>=1.34
    , plutus-tx          ^>=1.34

  if !(impl(ghcjs) || os(ghcjs))
    build-depends: plutus-tx-plugin

executable gen-blueprint
  import:           options
  hs-source-dirs:   app
  main-is:          GenBlueprint.hs
  build-depends:
    , base
    , bytestring
    , containers
    , plutus-core ^>=1.34.0.0
    , plutus-ledger-api ^>=1.34.0.0
    , plutus-tx ^>=1.34.0.0
    , plutus-tx-plugin ^>=1.34.0.0
    , scripts
----

In `.cabal`, we define our compiler(((compiler))) options, the library where our validator
code resides, and the build dependencies that list Plutus packages needed by our validator
code. At the end, we define the executable project, which tells Cabal which file is the
entry point for compiling the project, and we also list the build dependencies. We name
the file with the code for generating blueprints `GenBlueprint.hs`. Our project should
be structured in the following way:

[source,console]
----
.
├── app
│   └── GenBlueprint.hs
├── src
│   └── Week02
│       └── Validators.hs
├── cabal.project
├── validators.cabal
└── blueprint.json
----

The `blueprint.json` file will only be there after we have compiled the project.
We can do this by running the following commands from the top of our project directory:

[source,console]
----
cabal update
cabal run
----

At the end, we note that the `.cabal` file shown here lists all Plutus libraries
needed to compile any Plutus code presented in the <<chapter8-plutus-smart-contracts,
Plutus smart contracts>>
section. It can be reused when compiling code from other sections that we will
present next. One only needs to add the module names under the `exposed-modules:`
section and update the `GenBlueprint.hs` file with additional blueprint
definitions. As already mentioned, all Plinth validator code presented in this
chapter, including blueprint and cabal configuration files, can be found at the
https://github.com/input-output-hk/plutus-pioneer-program/tree/plinth-plutusV3[plinth-plutusV3]
branch of the Plutus pioneer program.

[[chapter8-script-context-explained]]
==== Script context explained

In this section, we will examine the [purple]#ScriptContext# data type in more detail.
All data types contained in the script context will be presented as Haskell data types.
Let us recall the implementation of the script context data type.

[source,haskell]
----
data ScriptContext = ScriptContext
  { scriptContextTxInfo     :: TxInfo
  , scriptContextRedeemer   :: V2.Redeemer
  , scriptContextScriptInfo :: ScriptInfo
  }
  deriving stock (Generic, Haskell.Eq, Haskell.Show)
  deriving anyclass (HasBlueprintDefinition)
----

It contains transaction information, the redeemer, and script information(((script, information))).
To reiterate: if a transaction attempts to spend multiple UTXOs at a script address, the spending
script is executed separately for each UTXO. The redeemer and script information
are assigned individually to each UTXO, whereas the transaction information
is shared across all scripts triggered by that transaction.

In the previous code examples, the validation logic did not use the transaction and script
information. However, in most validator scripts, they are
used. First, we look at the script information data type.

[[chapter8-script-information]]
===== Script information

The [purple]#ScriptInfo# data type is defined as:

[source,haskell]
----
data ScriptInfo
  = MintingScript V2.CurrencySymbol
  | SpendingScript V3.TxOutRef (Haskell.Maybe V2.Datum)
  | RewardingScript V2.Credential
  | CertifyingScript
      Haskell.Integer
      TxCert
  | VotingScript Voter
  | ProposingScript
      Haskell.Integer
      ProposalProcedure
  deriving stock (Generic, Haskell.Show, Haskell.Eq)
  deriving anyclass (HasBlueprintDefinition)
  deriving (Pretty) via (PrettyShow ScriptInfo)
----

The script information(((script, information))) contains information about the
script's purpose. If a transaction tries to mint a native asset, the script info
contains the [purple]#MintingScript# data constructor that carries the
[purple]#CurrencySymbol# data type.

[source,haskell]
----
newtype CurrencySymbol = CurrencySymbol {unCurrencySymbol :: PlutusTx.BuiltinByteString}
  deriving stock (Generic, Data)
  deriving anyclass (NFData, HasBlueprintDefinition)
  deriving newtype (Haskell.Eq, Haskell.Ord, Eq, Ord,
                    PlutusTx.ToData, PlutusTx.FromData,
                    PlutusTx.UnsafeFromData)
  deriving (Haskell.Show, Pretty)
    via LedgerBytes
----

The currency symbol data type is wrapped around a [purple]#BuiltinByteString#
which represents the hash of the minting policy(((minting policy))) that gets
triggered when minting a native asset. We will talk more about native assets
and minting in section <<chapter8-minting-policies-and-native-tokens,
Minting policies and native tokens>>.

If a transaction tries to spend a UTXO at a script address, the script
info contains the [purple]#SpendingScript# data constructor that carries
a transaction output reference(((transaction, output reference)))
[purple]#TxOutRef# and a [purple]#Maybe V2.Datum#.

[source,haskell]
----
data TxOutRef = TxOutRef
  { txOutRefId  :: TxId
  , txOutRefIdx :: Integer
  }
  deriving stock (Show, Eq, Ord, Generic)
  deriving anyclass (NFData, HasBlueprintDefinition)
----

The transaction output reference contains the transaction ID(((transaction, ID))),
which is a SHA-256 hash of the transaction and the transaction index, which is an integer number.
Each UTXO that a transaction creates gets a transaction index assigned starting with
0 and increasing by 1. Because a transaction hash(((transaction, hash))) (ID) is unique,
together with the output index it uniquely defines a UTXO.
The reason transaction hashes are unique is because a new transaction hash includes
the hash of the transaction that created the UTXO being consumed. Every transaction consumes
at least one UTXO as it needs to pay some fees. By a simple inductive
argument, it follows that two identical transaction hashes can never exist.
We also rely on the fact that the probability of a hash collision is negligible.

The [purple]#TxId# data type that represents an SHA-256 hash(((SHA-256 hash)))
of the transaction is a wrapper around a [purple]#BuiltinByteString#.

[source,haskell]
----
newtype TxId = TxId {getTxId :: PlutusTx.BuiltinByteString}
  deriving stock (Eq, Ord, Generic)
  deriving anyclass (NFData, HasBlueprintDefinition)
  deriving newtype (PlutusTx.Eq, PlutusTx.Ord, ToData, FromData, UnsafeFromData)
  deriving (IsString, Show, Pretty)
    via LedgerBytes
----

For PlutusV3 scripts, a datum(((datum))) is no longer necessary to be attached to a UTXO
when creating it at a script address, as was the case for PlutusV2 scripts.
For this reason, the script info for a spending script contains a maybe datum.

[source,haskell]
----
newtype Datum = Datum {getDatum :: BuiltinData}
  deriving stock (Generic, Typeable, Haskell.Show)
  deriving newtype (Haskell.Eq, Haskell.Ord, Eq, ToData, FromData,
                    UnsafeFromData, Pretty)
  deriving anyclass (NFData, HasBlueprintDefinition)
----

The [purple]#Datum# type is the same as the [purple]#Redeemer# type, a wrapper
around the [purple]#BuiltinData# type. The datum allows information to be
attached to a UTXO that can then be accessed within the validation script
logic. We note that the redeemer is defined when we construct a spending
transaction that consumes one or more UTXOs at a script address, and the
datum is defined when we construct a producing transaction that creates
one or more UTXOs at a script address. We will see examples of how to
construct producing and spending transactions in section
<<chapter8-off-chain-code-with-meshjs, Off-chain code with MeshJS>>.

The third option for script purposes is rewarding, which is used to
withdraw staking rewards. The rewarding constructor carries the
[purple]#Credential# data type.

[source,haskell]
----
data Credential =
    PubKeyCredential PubKeyHash
  | ScriptCredential ScriptHash
    deriving stock (Eq, Ord, Show, Generic, Typeable)
    deriving anyclass (NFData, HasBlueprintDefinition)
----

This data type either contains a public key hash or a script hash(((script, hash))). In
the case of a public key hash, the owner of the private key(((private key))) corresponding
to the public key needs to sign the transaction to be able to spend the
staking rewards. In the case of a script hash the transaction must include
or reference the validation script that will be used to decide whether
the staking rewards can be withdrawn by the transaction.

Both the [purple]#PubKeyHash# and [purple]#ScriptHash# data types are wrappers
around the [purple]#BuiltinByteString# data type.

Other possibilities for the [purple]#ScriptInfo# data type cover the
following script purposes:

* Certifying - for issuing certificates
* Voting and proposing - used when government actions are involved.

In the <<chapter8-plutus-smart-contracts, Plutus smart contracts>> section,
we will focus on the spending and minting script purposes.

[[chapter8-decoding-the-script-information-in-untyped-form]]
===== Decoding the script information in untyped form

Before we move on to explaining the transaction information data type we look
at another validator example that shows how to decode the [purple]#ScriptInfo#
data type in untyped form. Our validator follows the same logic as the 42
validator in the previous section, except that we now match the number 42
to the value of the datum(((datum))) instead of the redeemer.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- ------------------------- Datum 42 validator untyped ------------------------- -}

{-# INLINEABLE datum42Validator #-}
datum42Validator :: BuiltinData -> BuiltinUnit
datum42Validator ctx
    | datumInt == 42 = BI.unitval
    | otherwise      = traceError "Datum is a number different than 42"
 where
    -- Lazily decode script context up to datum
    constrArgs :: BuiltinData -> BI.BuiltinList BuiltinData
    constrArgs = BI.snd . BI.unsafeDataAsConstr

    scriptInfoBD :: BuiltinData
    scriptInfoBD = BI.head . BI.tail . BI.tail $ constrArgs ctx

    maybeDatumBD :: BuiltinData
    maybeDatumBD = BI.head . BI.tail $ constrArgs scriptInfoBD

    datumBD :: BuiltinData
    datumBD = BI.head $ constrArgs maybeDatumBD

    datumInt :: BI.BuiltinInteger
    datumInt = unsafeDataAsI datumBD

compiledDatum42Validator :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledDatum42Validator = $$(compile [||datum42Validator||])

serializedDatum42Validator :: SerialisedScript
serializedDatum42Validator = serialiseCompiledCode compiledDatum42Validator
----

As we have already explained in the previous section, we need to define the
[blue]#constrArgs# helper function that helps us to convert the [purple]#BuiltinData#
to the [purple]#BuiltinList# type. The script information(((script, information)))
is contained in the third place in the script context. To exctract an element from
the third place in the list, we can apply two times the [blue]#tail# function
and one time the [blue]#head# function.

Since we are working with a spending script the script info contains the spending
constructor followed by the transaction output
reference(((transaction, output reference))) and a maybe datum. We use
once the [blue]#tail# function and the [blue]#head# function to extract it. Because
we now have something of type [purple]#Maybe V2.Datum# we cannot directly convert
it to an integer. We again use the [blue]#constrArgs# function and then only once
the [blue]#head# function since there should be only one element in the list which
is the datum. After that we have the datum in untyped form, and we can apply the
[blue]#unsafeDataAsI# function to convert it to an integer number.

In case the datum was not attached to the UTXO or the datum has a different format
this validator will fail without a used defined error message. If we do manage to
extract an integer the validator will pass if it is 42 or fail with a user-defined
message. We note also in this example in case the datum would be a more structured
data type we could use the [blue]#fromBuiltinData# function that would convert it
to typed form where extracting any information can be done in a simpler way.

We again state the various possibilities that a datum can be used for
in smart contracts:

* Indicating who can consume a UTXO, when, and under what conditions
* Representing the current state of the UTXO
* Defining metadata and/or configurations.

[[chapter8-transaction-information]]
===== Transaction information

Let us look at the transaction information(((transaction, information)))
[purple]#TxInfo# data type.

[source,haskell]
----
data TxInfo = TxInfo
  { txInfoInputs                :: [TxInInfo]
  , txInfoReferenceInputs       :: [TxInInfo]
  , txInfoOutputs               :: [V2.TxOut]
  , txInfoFee                   :: V2.Lovelace
  , txInfoMint                  :: V3.MintValue
  , txInfoTxCerts               :: [TxCert]
  , txInfoWdrl                  :: Map V2.Credential V2.Lovelace
  , txInfoValidRange            :: V2.POSIXTimeRange
  , txInfoSignatories           :: [V2.PubKeyHash]
  , txInfoRedeemers             :: Map ScriptPurpose V2.Redeemer
  , txInfoData                  :: Map V2.DatumHash V2.Datum
  , txInfoId                    :: V3.TxId
  , txInfoVotes                 :: Map Voter (Map GovernanceActionId Vote)
  , txInfoProposalProcedures    :: [ProposalProcedure]
  , txInfoCurrentTreasuryAmount :: Haskell.Maybe V2.Lovelace
  , txInfoTreasuryDonation      :: Haskell.Maybe V2.Lovelace
  }
  deriving stock (Generic, Haskell.Show, Haskell.Eq)
  deriving anyclass (HasBlueprintDefinition)
----

It contains several fields that carry information about the transaction
being validated. In the beginning, it contains a list of transaction inputs
and reference inputs(((reference inputs))). Reference inputs are inputs accessible by the script
context but not consumed by the transaction. They are only referenced, hence
the name. A transaction may need access to a UTXO without consuming it
because the UTXO can contain important information in the datum that
scripts can access. This information can be arbitrary data contained in
the datum or an attached reference script, which is a serialized smart
contract compiled to Plutus. The advantage of reference scripts is that
instead of appending a script to a transaction that wants to spend funds
at the script address, we simply reference this script from the UTXO
that carries it. This lowers the transaction size and reduces the
transaction cost. A code example of this is presented in section
<<chapter8-off-chain-code-with-meshjs, Off-chain code with MeshJS>>.
Another advantage of reference inputs is
that several transactions in the same block can use the same UTXO as a
reference input, since it is not being consumed by any of those transactions.
Transaction inputs and reference inputs are lists of type transaction input
info [purple]#TxInInfo# that defines the input of a pending transaction.

[source,haskell]
----
data TxInInfo = TxInInfo
  { txInInfoOutRef   :: V3.TxOutRef
  , txInInfoResolved :: V2.TxOut
  }
  deriving stock (Generic, Haskell.Show, Haskell.Eq)
  deriving anyclass (HasBlueprintDefinition)
----

The transaction input information(((transaction, input information)))
contains a transaction output reference(((transaction, output reference)))
that we have previously explained. It defines the input UTXO, and it also
contains resolved transaction input information
in form of the transaction output [purple]#TxOut# data type.

[source,haskell]
----
data TxOut = TxOut
  { txOutAddress         :: Address
  , txOutValue           :: Value
  , txOutDatum           :: OutputDatum
  , txOutReferenceScript :: Maybe ScriptHash
  }
  deriving stock (Show, Eq, Generic)
  deriving anyclass (NFData, HasBlueprintDefinition)
----

A transaction output of a UTXO contains the address at which this UTXO resides,
the value it contains, the output datum and possibly a script hash(((script, hash))).
We look first at the [purple]#Address# type.

[source,haskell]
----
data Address = Address
  { addressCredential        :: Credential
  , addressStakingCredential :: Maybe StakingCredential
  }
  deriving stock (Eq, Ord, Show, Generic, Typeable)
  deriving anyclass (NFData, HasBlueprintDefinition)
----

As explained in section <<chapter8-cardano-security, Cardano addresses>>,
an address is composed of
two parts: the payment part and the optional staking part. The payment part,
defined with the [purple]#Credential# data type, contains either a public
key hash or a script hash as we have explained when talking about rewarding
in the <<chapter8-script-information, Script information>> section.

The optional staking part is defined with the [purple]#StakingCredential#
data type that can be either a staking hash or a staking pointer.

[source,haskell]
----
data StakingCredential =
      StakingHash Credential
    | StakingPtr
        Integer -- ^ the slot number
        Integer -- ^ the transaction index (within the block)
        Integer -- ^ the certificate index (within the transaction)
    deriving stock (Eq, Ord, Show, Generic, Typeable)
    deriving anyclass (NFData, HasBlueprintDefinition)
----

The second piece of information contained in a transaction output is the
[purple]#Value# type that defines an amount of ada and/or native tokens.

[source,haskell]
----
newtype Value = Value { getValue :: Map CurrencySymbol (Map TokenName Integer) }
    deriving stock (Generic, Data, Typeable, Haskell.Show)
    deriving anyclass (NFData)
    deriving newtype (PlutusTx.ToData, PlutusTx.FromData, PlutusTx.UnsafeFromData)
    deriving Pretty via (PrettyShow Value)
----

Every native token is defined with a currency symbol and a token name(((token name))). They are
both wrappers around a [purple]#BuiltinByteString#. The currency symbol is computed
as the hash of the minting policy, and the token name can be an arbitrary string
(but should not be longer than 32 bytes). The `ada` token is defined by an empty
byte string both for currency symbol and token name, which means one cannot mint ada.

The third part of a transaction output is the [purple]#OutputDatum# data type.

[source,haskell]
----
data OutputDatum
    = NoOutputDatum
    | OutputDatumHash DatumHash
    | OutputDatum Datum
  deriving stock (Show, Eq, Generic)
  deriving anyclass (NFData, HasBlueprintDefinition)
----

A UTXO can either contain no datum, a datum hash or a datum. A datum hash
contains a string of type [purple]#BuiltinByteString# and the datum type is a
wrapper around the [purple]#BuiltinData# type -- just like the [purple]#Redeemer# type.

The last data for the [purple]#TxOut# data type defines a [purple]#Maybe ScriptHash#.
A script hash(((script, hash))) is also a wrapper around a [purple]#BuiltinByteString#.

Next in the [purple]#TxInfo# data type are the transaction
outputs(((transaction, output))) which the
transaction aims to create. A transaction output is defined with the [purple]#TxOut#
data type that we have already shown. After that comes the data for fees and
minting. Fees are defined with the [purple]#Lovelace# data type that is a
wrapper around an [purple]#Integer# type.

[source,haskell]
----
newtype Lovelace = Lovelace { getLovelace :: Integer }
  deriving stock (Generic, Typeable)
  deriving (Pretty) via (PrettyShow Lovelace)
  deriving anyclass (HasBlueprintDefinition)
  deriving newtype (Haskell.Eq, Haskell.Ord, Haskell.Show, Haskell.Num,
                    Haskell.Real, Haskell.Enum, PlutusTx.Eq, PlutusTx.Ord,
                    PlutusTx.ToData, PlutusTx.FromData, PlutusTx.UnsafeFromData,
                    PlutusTx.AdditiveSemigroup, PlutusTx.AdditiveMonoid,
                    PlutusTx.AdditiveGroup, PlutusTx.Show)
----

Minting is defined with the [purple]#MintValue# type that is structured the same
as the [purple]#Value# type.

[source,haskell]
----
newtype MintValue = UnsafeMintValue (Map CurrencySymbol (Map TokenName Integer))
  deriving stock (Generic, Data, Typeable, Haskell.Show)
  deriving anyclass (NFData)
  deriving newtype (ToData, FromData, UnsafeFromData)
  deriving (Pretty) via (PrettyShow MintValue)
----

Following fees and minting, is the data that handles certificates, which is defined
by a list of the [purple]#TxCert# data type.

[source,haskell]
----
data TxCert =
    TxCertRegStaking V2.Credential (Haskell.Maybe V2.Lovelace)
  | TxCertUnRegStaking V2.Credential (Haskell.Maybe V2.Lovelace)
  | TxCertDelegStaking V2.Credential Delegatee
  | TxCertRegDeleg V2.Credential Delegatee V2.Lovelace
  | TxCertRegDRep DRepCredential V2.Lovelace
  | TxCertUpdateDRep DRepCredential
  | TxCertUnRegDRep DRepCredential V2.Lovelace
  | TxCertPoolRegister
      -- | poolId
      V2.PubKeyHash
      -- | pool VFR
      V2.PubKeyHash
  | TxCertPoolRetire V2.PubKeyHash Haskell.Integer
  | TxCertAuthHotCommittee ColdCommitteeCredential HotCommitteeCredential
  | TxCertResignColdCommittee ColdCommitteeCredential
  deriving stock (Generic, Haskell.Show, Haskell.Eq, Haskell.Ord)
  deriving anyclass (HasBlueprintDefinition)
  deriving (Pretty) via (PrettyShow TxCert)
----

The [purple]#TxCert# data type has eleven constructors representing the
following certificates:

[arabic]
. Register staking credential with an optional deposit amount
. Unregister staking credential with an optional refund amount
. Delegate staking credential to a Delegatee
. Register and delegate staking credential to a Delegatee in one certificate
  (deposit is mandatory)
. Register a DRep with a deposit value
. Update a DRep
. Unregister a DRep with mandatory refund value
. A digest of the PoolParams
. The retirement certificate and the Epoch in which the retirement will take place
. Authorize a Hot credential for a specific Committee member's cold credential
. Resign committee member's cold credential.

After certificates comes the data that manages withdrawals of staking rewards.
The data is contained in a [purple]#Map# of credentials to lovelace. Next follows
the transaction validity range, which is defined with the [purple]#POSIXTimeRange#
data type.

[source,haskell]
----
type POSIXTimeRange = Interval POSIXTime

data Interval a = Interval { ivFrom :: LowerBound a, ivTo :: UpperBound a }
    deriving stock (Haskell.Show, Generic)
    deriving anyclass (NFData)
----

The [purple]#POSIXTimeRange# data type contains an [purple]#Interval# type,
parameterized with the [purple]#POSIXTime# type. The [purple]#Interval# type
holds data about the lower and upper bounds of the validity interval for the
specified transaction. The lower and upper bound types are structured in the
same way. They hold the [purple]#Extended# and [purple]#Closure# types.

[source,haskell]
----
data LowerBound a = LowerBound (Extended a) Closure
    deriving stock (Haskell.Show, Generic)
    deriving anyclass (NFData)
----

The [purple]#Closure# type is just a wrapper for a Boolean which indicates
whether the boundary is included in the interval or not. The extended type
has three possible constructor values, which represent negative infinity,
positive infinity, or a finite bound parameterized, in our case, by a
[purple]#POSIXTime# type.

[source,haskell]
----
newtype POSIXTime = POSIXTime {getPOSIXTime :: Integer}
  deriving stock (Haskell.Eq, Haskell.Ord, Haskell.Show, Generic, Typeable)
  deriving anyclass (NFData, HasBlueprintDefinition)
  deriving newtype (AdditiveSemigroup, AdditiveMonoid, AdditiveGroup, Eq,
                    Ord, Enum, PlutusTx.ToData, PlutusTx.FromData,
                    PlutusTx.UnsafeFromData, Haskell.Num, Haskell.Enum,
                    Haskell.Real, Haskell.Integral)
----

[purple]#POSIXTime# is a wrapper for an integer, representing the number of
milliseconds that have passed since 1 January, 1970, at 00:00.

The module `PlutusLedgerApi.V1.Interval` defines the following helper functions
that work with time intervals:

* [blue]#member#: checks whether a value is in an interval
* [blue]#interval#: takes two parameters as input and constructs an interval
with included boundaries
* [blue]#from#: takes a value and returns an interval that includes all values
greater than or equal to the given value
* [blue]#to#: takes a value and returns an interval that includes all values
that are smaller than or equal to the given value
* [blue]#always#: an interval that covers every possible time
* [blue]#never#: an interval that is empty
* [blue]#singleton#: takes a value and returns an interval that only contains
the single value
* [blue]#hull#: takes two intervals as input and returns the smallest interval
containing both intervals
* [blue]#intersection#: takes two intervals as input and returns the largest
interval contained in both of the intervals, if it exists
* [blue]#overlap#: checks whether two intervals have a value in common and
returns a Boolean
* [blue]#contains#: checks whether the second interval is contained in the
first one, and returns a Boolean
* [blue]#isEmpty#: checks whether an interval is empty and returns a Boolean
* [blue]#before#: checks whether a given time is before the given interval and
returns a Boolean
* [blue]#after#: checks whether a given time is after the given interval and
returns a Boolean.

Following the validity range in the [purple]#TxInfo# data type, is the list
of public key hashes that represent transaction signatories. We note again
that the [purple]#PubKeyHash# data type is a wrapper around the
[purple]#BuiltinByteString# data type.

Next are the redeemers and datums. As stated before, a transaction can spend
multiple UTXOs that get individual redeemers assigned. In case any of these
UTXOs have only a datum hash attached, the transaction also needs to contain
the datums that belong to those hashes. Data for both redeemers and datums is
packaged inside a [purple]#Map# object. The keys for the redeemer data are
of type [purple]#ScriptPurpose#.

[source,haskell]
----
data ScriptPurpose
  = Minting V2.CurrencySymbol
  | Spending V3.TxOutRef
  | Rewarding V2.Credential
  | Certifying
      Haskell.Integer
      TxCert
  | Voting Voter
  | Proposing
      Haskell.Integer
      ProposalProcedure
  deriving stock (Generic, Haskell.Show, Haskell.Eq, Haskell.Ord)
  deriving anyclass (HasBlueprintDefinition)
  deriving (Pretty) via (PrettyShow ScriptPurpose)
----

The [purple]#ScriptPurpose# data type is structured in the same way as the
[purple]#ScriptInfo# data type except that the constructor names are different
and the _Spending_ constructor holds only a transaction output
reference(((transaction, output reference))) without a maybe datum.
The keys for the datums are datum hashes that map to actual datums.

Next comes the transaction ID(((transaction, ID))) of type
[purple]#TxId# which represents the
hash of the transaction being validated. As already stated this type is a
wrapper around the [purple]#BuiltinByteString# data type.

Next, are the votes and proposal procedures that are used when
dealing with government actions. The last two pieces of data contained in
the transaction information are the current treasury amount(((treasury, amount))) and treasury
donation. Both are of type [purple]#Maybe V2.Lovelace#. Learn more about
governance features, including the topics of voting and proposal submission
in chapter <<chapter5-cardano-governance, Cardano governance>>.

[[chapter8-time-dependent-and-parameterized-validators]]
==== Time-dependent and parameterized validators

This section demonstrates a smart contract representing a vesting
schema. In this scenario, a person sends a gift of ada to the smart
contract, and the beneficiary can reclaim this gift after a set deadline
has passed. Such a contract can take two approaches, depending on how the
validator accesses the beneficiary and deadline information:

* From the datum that is attached to the UTXO we are creating at this script address
* From a parameter that is added as an input variable to the validator script.

First, we present the approach when the validator uses the datum of the UTXO.

[source,haskell]
----
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveAnyClass             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost        #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE Strict                     #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE ViewPatterns               #-}
{-# OPTIONS_GHC -fno-full-laziness #-}
{-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}
{-# OPTIONS_GHC -fno-omit-interface-pragmas #-}
{-# OPTIONS_GHC -fno-spec-constr #-}
{-# OPTIONS_GHC -fno-specialise #-}
{-# OPTIONS_GHC -fno-strictness #-}
{-# OPTIONS_GHC -fno-unbox-small-strict-fields #-}
{-# OPTIONS_GHC -fno-unbox-strict-fields #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}

module Week03.Vesting where

import           GHC.Generics                  (Generic)
import           PlutusLedgerApi.Common        (FromData (fromBuiltinData),
                                                SerialisedScript,
                                                serialiseCompiledCode)
import           PlutusLedgerApi.Data.V3       (POSIXTime, PubKeyHash)
import           PlutusLedgerApi.V1.Interval   (contains, from)
import           PlutusLedgerApi.V3            (ScriptContext (..),
                                                ScriptInfo (..),
                                                TxInfo (txInfoValidRange),
                                                getDatum)
import           PlutusLedgerApi.V3.Contexts   (txSignedBy)
import           PlutusTx                      (BuiltinData, CompiledCode,
                                                UnsafeFromData
                                                 (unsafeFromBuiltinData),
                                                compile,
                                                makeIsDataSchemaIndexed,
                                                makeLift)
import           PlutusTx.Blueprint            (HasBlueprintDefinition)
import           PlutusTx.Blueprint.Definition (definitionRef)
import           PlutusTx.Bool                 (Bool (..), (&&))
import           PlutusTx.Prelude              (BuiltinUnit, Maybe (..), check,
                                                traceError, traceIfFalse, ($),
                                                (.))

{- ------------------------------------------------------------------------------ -}
{- ----------------------------------- TYPES ------------------------------------ -}

data VestingDatum = VestingDatum
  { beneficiary :: PubKeyHash
  , deadline    :: POSIXTime
  }
  deriving stock (Generic)
  deriving anyclass (HasBlueprintDefinition)

makeIsDataSchemaIndexed ''VestingDatum [('VestingDatum, 0)]

{- ------------------------------------------------------------------------------ -}
{- --------------------------------- VALIDATOR ---------------------------------- -}

{-# INLINEABLE vestingVal #-}
vestingVal :: ScriptContext -> Bool
vestingVal ctx =
  traceIfFalse "Is not the beneficiary" checkBeneficiary
    && traceIfFalse "Deadline not reached" checkDeadline
 where
  checkBeneficiary :: Bool
  checkBeneficiary = txSignedBy info (beneficiary vestingDatum)

  checkDeadline :: Bool
  checkDeadline = from (deadline vestingDatum) `contains` txInfoValidRange info

  vestingDatum :: VestingDatum
  vestingDatum = case scriptContextScriptInfo ctx of
    SpendingScript _txRef (Just datum) ->
      case (fromBuiltinData @VestingDatum . getDatum) datum of
        Just d  -> d
        Nothing -> traceError "Expected correctly shaped datum"
    _ -> traceError "Expected SpendingScript with datum"

  info :: TxInfo
  info = scriptContextTxInfo ctx

{- ------------------------------------------------------------------------------ -}
{- ---------------------------------- HELPERS ----------------------------------- -}

compiledVestingVal :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledVestingVal = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinUnit
  wrappedVal ctx = check $ vestingVal (unsafeFromBuiltinData ctx)

serializedVestingVal :: SerialisedScript
serializedVestingVal = serialiseCompiledCode compiledVestingVal
----

In the beginning, we add all necessary language pragmas and import
statements. The functions, types and type classes we import are necessary
to cover the functionality for both validators presented in this section.
We name the module `Week03.Vesting` since the idea for the vesting contract
comes from the _Week03_ examples from the Plutus pioneer program.

Then we define our [purple]#VestingDatum# datum type. It contains the
beneficiary's public key hash and the deadline in the form of [purple]#POSIXTime#
after which the funds can be claimed. Because we are defining a custom data
type, we need to use the [blue]#makeIsDataSchemaIndexed# function that generates
the [purple]#ToData#, [purple]#FromData#, [purple]#UnsafeFromData#, and
[purple]#HasBlueprintSchema# instances for our custom type. As stated in
a previous section, we use Template Haskell, which requires adding two single
quotes in front of the type to return the type's name.

Next comes the code for the validator. The validation logic says
that the funds can be unlocked only when the deadline has been
reached and the transaction is signed by the beneficiary. The helper
variables [blue]#checkBeneficiary# and [blue]#checkDeadline#
are of type [purple]#Bool#. In the first variable, we use the helper
function [blue]#txSignedBy# that takes a transaction info and a public key
hash and checks whether this transaction has been signed with the correct key
that belongs to the hash. In the second variable, we access the transaction
validity range and check whether it is contained inside the interval
starting with the deadline and going to infinity. As a side note we state
when the validity range for a transaction is being defined,
the transaction gets submitted by a node only if the time of submission
for this transaction falls into the validity range of the transaction.

In the validator code, the datum gets extracted from the script context and
converted to typed form. In case the script purpose is incorrect, the datum
is not attached or has an incorrect form we raise an error and log a message.
At the end we wrap the validator function, compile and serialize it.

In the examples we have seen so far, the validators took in a single parameter,
the script context and returned a [purple]#Bool# or a [purple]#BuiltinUnit#. If
there is any variability in the contract, we model that by using the datum as in
the vesting example, which contained the beneficiary and the deadline. An alternative
approach is to use parameterized contracts(((parameterized contract))),
where variability is integrated into the contract
by adding a parameter variable to the validator function. The code below shows this,
containing a modified version of the previous vesting code example.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- ---------------------------- PARAMETERIZED TYPES ----------------------------- -}

data VestingParams = VestingParams
  { beneficiaryParam :: PubKeyHash
  , deadlineParam    :: POSIXTime
  }
  deriving stock (Generic)
  deriving anyclass (HasBlueprintDefinition)

makeLift ''VestingParams
makeIsDataSchemaIndexed ''VestingParams [('VestingParams, 0)]

{- ------------------------------------------------------------------------------ -}
{- -------------------------- PARAMETERIZED VALIDATOR --------------------------- -}

{-# INLINEABLE paramVestingVal #-}
paramVestingVal :: VestingParams -> ScriptContext -> Bool
paramVestingVal vp ctx =
  traceIfFalse "Is not the beneficiary" checkBeneficiary
    && traceIfFalse "Deadline not reached" checkDeadline
 where
  checkBeneficiary :: Bool
  checkBeneficiary = txSignedBy info (beneficiaryParam vp)

  checkDeadline :: Bool
  checkDeadline = from (deadlineParam vp) `contains` txInfoValidRange info

  info :: TxInfo
  info = scriptContextTxInfo ctx

{- ------------------------------------------------------------------------------ -}
{- ---------------------------------- HELPERS ----------------------------------- -}

compiledParamVestingVal :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinUnit)
compiledParamVestingVal = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinData -> PlutusTx.Prelude.BuiltinUnit
  wrappedVal params ctx = check $ paramVestingVal (unsafeFromBuiltinData params)
                                                  (unsafeFromBuiltinData ctx)

serializedParamVestingVal :: SerialisedScript
serializedParamVestingVal = serialiseCompiledCode compiledParamVestingVal
----

First, we create the [purple]#VestingParams# type, which was previously called
[purple]#VestingDatum#. It holds the beneficiary's public key hash and the
deadline after which the beneficiary can claim the funds. Then we again use
Template Haskell and generate the necessary instances for our custom type.
We also use the [blue]#makeLift# function that generates for our custom data
type an instance of the [purple]#Lift# type class. This line only compiles if
the [purple]#MultiParamTypeClasses# and [purple]#ScopedTypeVariables# language
extensions are enabled. An instance of the [purple]#Lift# type class is needed
so that a validator containing a parameter can be compiled even though the
parameter is not known at the time of compilation.

[source,haskell]
----
class Lift uni a where
    -- | Get a Plutus IR term corresponding to the given value.
    lift :: a -> RTCompile uni fun (Term TyName Name uni fun ())
----

It contains only the [blue]#lift# method, but we will not use that directly.
There are a lot of instances for existing Plutus type in this type class such as
[purple]#BuiltinData#, [purple]#BuiltinString#, [purple]#BuiltinInteger# and
[purple]#Bool#. However, this is not used for functions, as they cannot be
used to compile Haskell to Plutus validators.
The reason it is possible to compile a parameterized validator in Plutus is
that the input parameter is not some arbitrary Haskell function, it is static
data that you can pass at runtime to a script function if you create an instance
of the [purple]#Lift# type class.

Next comes the validator code. The type signature of the validator function
changes such that it takes the additional vesting parameter. We note that a
validator function can take any number of parameters. Our example uses only one
parameter. In the body of the validator function, we now read the deadline and
the beneficiary's public key hash from the vesting parameter. Apart from that,
the logic of the validator stays the same. Then the validator gets compiled and
serialized. When compiling the validator, another type parameter needs to be
added to the type signatures, and we also need to apply the [blue]#unsafeFromBuiltinData#
function to the vesting parameter in order to wrap the validator before compiling it.

This concludes the procedure of writing a parameterized contract. Next, we look at
off-chain code that interacts with the validators presented in this section.

[[chapter8-off-chain-code-with-meshjs]]
==== Off-chain code with MeshJS

The blockchain is passive – it only acts when a user interacts with it.
The code that queries the blockchain, builds, and submits transactions
is called off-chain code(((off-chain code))). Off-chain code does not need to have the same
performance and security standards as on-chain code. In this section,
we will showcase how to write off-chain code for the on-chain code example
presented in the previous section.

After the Alonzo era(((era, Alonzo))), when smart contracts became available on Cardano,
the https://github.com/IntersectMBO/plutus-apps[Plutus application platform]
provided a way to write off-chain code.
Developed by IO and implemented as a set of Haskell libraries, it
allowed users to write and submit transactions using the Contract monad.
A single Haskell file could contain on-chain and off-chain code.
Currently, the platform is in maintenance mode and no longer under
active development.

Another way for constructing off-chain transactions is by using the
https://github.com/IntersectMBO/cardano-cli[Cardano CLI]. You can
find examples and read more about the Cardano CLI(((Cardano, CLI))) on the
https://developers.cardano.org/docs/get-started/cardano-cli/get-started/[Cardano developers]
webpage. There are also several community-built tools for writing off-chain code in
various programming languages. Some of them are listed at the end of
section <<chapter8-smart-contract-programming-languages,
Smart contract programming languages>>, where
off-chain code is briefly covered. For those using Plinth and interested
in writing off-chain code in Haskell, the https://atlas-app.io/[Atlas] application backend,
developed by https://www.geniusyield.co/[GeniusYield],
provides a solution. It
allows code-sharing between the on-chain and off-chain components while
enabling the creation of a backend for decentralized applications.

This section explores the https://meshjs.dev/[MeshJS] tool, developed by
the https://meshjs.dev/about[Mesh team]. It can be used as a NodeJS package
to construct and submit transactions interacting with a smart contract by
writing JavaScript or TypeScript code. To run the off-chain code in this and
other sections, you can use https://deno.com/[Deno] -- which is a runtime
environment for JavaScript and TypeScript. All off-chain code presented in
this chapter was tested with Deno version `2.1.9` and
MeshSDK packages version `1.9.0-beta.3`. To install the MeshSDK packages
that are needed by the off-chain code, the
https://docs.npmjs.com/downloading-and-installing-node-js-and-npm[npm]
package manager for the Node.js(((NodeJS))) JavaScript runtime environment
can be used. To specify a package version, one can create the `package.json`
file before installing the packages. Below is an example of this file.

[source,json]
----
{
  "dependencies": {
    "@meshsdk/core": "1.9.0-beta.3",
    "@meshsdk/common": "1.9.0-beta.3",
    "@meshsdk/core-cst": "1.9.0-beta.3",
    "deno": "2.1.9" }
}
----

The package that installs other MeshSDK packages required by
our code is `@meshsdk/core`. The official
https://www.npmjs.com/package/@meshsdk/core[npm page] for this package
lists the MeshSDK packages that will get installed as dependencies.
To install all MeshJS packages locally, `cd` to the root location of your
project, create the `package.json` file and run:

[source,console]
----
npm install @meshsdk/core
----

If no `package.json` file is present, `npm(((npm)))` will create one and install
the latest version of MeshSDK packages. For more information on how to
install npm packages and manage the `package.json` file one can read the
https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry[Getting
packages from the registry] and
https://docs.npmjs.com/creating-a-package-json-file[Creating
a package.json file] npm documentation pages. The `deno` tool can be
installed globally. From the location of the `package.json` file run:

[source,console]
----
npm install -g deno
----

Let us look now at off-chain code that interacts with the vesting smart
contract `vestingVal` that we have defined in the previous section. Our code
will reside in a TypeScript file to leverage some of the type system's features.

[source,typescript]
----
import {
    BlockfrostProvider,
    MeshWallet,
    Transaction,
    PlutusScript,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    deserializeAddress,
    resolveSlotNo,
    mConStr0,
    Action
  } from "@meshsdk/core";
import { UTxO } from "@meshsdk/common";
import { secretSeed } from "./seed.ts";

// Define blockchain provider and wallet
const provider: BlockfrostProvider = new BlockfrostProvider("<blockfrost-key>");
const wallet: MeshWallet = new MeshWallet({
    networkId: 0, //0=testnet, 1=mainnet
    fetcher: provider,
    submitter: provider,
    key: {
        type: "mnemonic",
        words: secretSeed
    }
});
----

First, we import the necessary components from the `@meshsdk/core` and
the `@meshsdk/common` libraries. Then we import the seed phrase(((seed phrase))) of our
Cardano wallet. The `seed.ts` file should be in the following form:

[source,typescript]
----
export const secretSeed = ["seed1", "seed2", ... ];
----

For instructions on how to create a wallet and generate a seed phrase,
see chapter <<wallets-in-the-world-of-cardano, Wallets in the world of Cardano>>.
Next, we define a provider which helps us to query the blockchain and
submit transactions. We use https://blockfrost.io/[BlockFrost]. For the
code to work, one has to provide their blockfrost key, which users can get
for free at the official webpage. The key is tied to a specific network
(mainnet, preprod, preview or SanchoNet). The off-chain code we will
present in this and other sections was tested on the preview network.
There is a daily limit of how many request a user can make with a free
BlockFrost account. Currently, it is set to 50.000. One can also pick
another provider. MeshJS can connect to various providers. Examples
can be found at the MeshJS https://meshjs.dev/providers[Providers]
documentation page.

After we have defined our provider, we initiate a Mesh wallet where we
input the provider and our secret seed. We also define on which network
we will work (0 stands for testnet which is both preview or preprod).
Mesh also allows providing the key in other forms. One can define the
type of the key as `"root"` and then provide the root key in `bech32`
format. Another option is also to define the type of key as `"cli"`
and then provide the payment and staking keys. To see all options
you can look at the source code in the official mesh GitHub repository
that defines the
https://github.com/MeshJS/mesh/blob/main/packages/mesh-wallet/src/mesh/index.ts[MeshWallet]
class. Next we read out some wallet information and define our vesting
script.

[source,typescript]
----
// Define address and public key hash of it
const walletAddress: string = await wallet.getChangeAddress();
const signerHash: string = deserializeAddress(walletAddress).pubKeyHash;

// Set the vesting deadline
const deadlineDate: Date = new Date("2025-03-05T12:30:10Z")
const deadlinePOSIX: bigint = BigInt(deadlineDate.getTime());

// Defining our vesting script
const vestingScript: PlutusScript = {
    code: applyCborEncoding("590ed20101003232323232323232323232323232259..."),
    version: "V3"
};
const vestingAddr: string = resolvePlutusScriptAddress(vestingScript, 0);
----

First, we define the wallet address and the public key hash that
belongs to that address. We will set the beneficiary to our own
public key hash so we can claim the funds back ourselves. Then we define
the deadline, which sets the time after which the funds can be claimed
from the script address. We set the time in ISO UTC format and then
convert it to `POSIX` time in milliseconds.

After we have defined our data that we will attach in the datum, we can
define our vesting script and compute the address of this script. We
note that we have to apply the function [blue]#applyCborEncoding# that
takes the raw script `CBORHEX(((CBORHEX)))` from the blueprint and formats it in
the correct way. The compiled code in our code snippet is shortened.
When running this off-chain code, the full compiled code of the validator
has to be provided. That can be found in the `blueprint.json` file at the
https://github.com/input-output-hk/plutus-pioneer-program/tree/plinth-plutusV3[plinth-plutusV3]
branch of the Plutus pioneer program repository. Now we can send some
funds to the vesting script.

[source,typescript]
----
// Function for creating UTXO at vesting script
async function sendFunds(amount: string): Promise<string> {
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preview")
        .sendLovelace(
        { address: vestingAddr,
          datum: {value: mConStr0([signerHash, deadlinePOSIX]), inline: true }},
        amount)
        .setChangeAddress(walletAddress);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash
}
----

The [blue]#sendFunds# function takes an amount of lovelace provided as a string,
and creates a transaction that sends the specified amount to the vesting
script address. When creating a transaction, we use the [purple]#Transaction#
class where we provide our wallet as initiator. Then we set the network.
The Mesh source code states that setting the network is mainly used to know the
cost models to be used to calculate script integrity hash. After that we
use the [blue]#sendLovelace# function, where we specify our script address,
the datum that we want to attach, if we want to inline it, and in the end
the amount we want to send. We create the datum with the [blue]#mConStr0#
function that helps us to create a Mesh Data index 0 constructor object.
At the end of the transaction we set the change address to our address -- which
means that the lovelace change amount of the UTXOs we will spend will go back
to our wallet. Once we have our transaction we build it, sign it and submit it.
The [blue]#sendFunds# function in the end then returns the transaction hash
of the submitted transaction.

Let us look again at the custom vesting data type we use in our validator code:

[source,haskell]
----
data VestingDatum = VestingDatum
  { beneficiary :: PubKeyHash
  , deadline    :: POSIXTime
  }
  deriving stock (Generic)
  deriving anyclass (HasBlueprintDefinition)

makeIsDataSchemaIndexed ''VestingDatum [('VestingDatum, 0)]
----

We imagine for a moment that we define the above data type as an algebraic
sum data type such that it flips the order of the arguments for the second
data constructor.

[source,haskell]
----
data VestingDatumMix = VestingDatum1 { beneficiary1 :: PubKeyHash,
                                       deadline1 :: POSIXTime }
                     | VestingDatum2 { deadline2 :: POSIXTime,
                                       beneficiary2 :: PubKeyHash }
                     deriving stock (Generic)
                     deriving anyclass (HasBlueprintDefinition)

makeIsDataSchemaIndexed ''VestingDatumMix [('VestingDatum1, 0), ('VestingDatum2, 1)]
----

When we make the data schema, we then assign the numbers 0 and 1 to the data
constructors in the same order we have defined them. Now that we have our datum
type, we can modify our validator such that it can work with this type.

[source,haskell]
----
{-# INLINEABLE vestingValMix #-}
vestingValMix :: ScriptContext -> Bool
vestingValMix ctx =
  traceIfFalse "Is not the beneficiary" checkBeneficiary
    && traceIfFalse "Deadline not reached" checkDeadline
 where
  checkBeneficiary :: Bool
  checkBeneficiary = txSignedBy info beneficiaryMix

  checkDeadline :: Bool
  checkDeadline = from deadlineMix `contains` txInfoValidRange info

  vestingDatum :: VestingDatumMix
  vestingDatum = case scriptContextScriptInfo ctx of
    SpendingScript _txRef (Just datum) ->
      case (fromBuiltinData @VestingDatumMix . getDatum) datum of
        Just d  -> d
        Nothing -> traceError "Expected correctly shaped datum"
    _ -> traceError "Expected SpendingScript with datum"

  variables :: (PubKeyHash, POSIXTime)
  variables@(beneficiaryMix, deadlineMix) = case vestingDatum of
    VestingDatum1 b d  -> (b, d)
    VestingDatum2 d b  -> (b, d)

  info :: TxInfo
  info = scriptContextTxInfo ctx
----

If we construct a transaction that creates a UTXO at the script address
of the above script, we now have two options to attach the datum. In the
case of the [purple]#VestingDatum1# data constructor, we would attach
the datum the same way as we have shown in the [blue]#sendFunds# function. For
the second case, if we would want to provide the datum as the second option where
the arguments are flipped, we would do that the following way:

[source,typescript]
----
mConStr1([deadlinePOSIX, signerHash])
----

Notice that, besides flipping the arguments, we use now the function [blue]#mConStr1#
instead of [blue]#mConStr0#. With it, we create a Mesh Data index 1 constructor object
that corresponds to the second data constructor [purple]#VestingDatum2#. If our vesting
type would have a third data constructor, we could use the function [blue]#mConStr2#.
The MeshJS library currently provides these functions up to [blue]#mConStr3#.

Next we define the functions needed to claim the vested funds.

[source,typescript]
----
// Returns a UTXO at a given address that contains the given transaction hash
async function getUtxo(scriptAddress: string, txHash: string): Promise<UTxO> {
const utxos = await provider.fetchAddressUTxOs(scriptAddress);
    if (utxos.length == 0) {
        throw 'No listing found.';
    }
    let filteredUtxo = utxos.find((utxo: any) => {
        return utxo.input.txHash == txHash;
    })!;
    return filteredUtxo
}

// Function for claiming funds
async function claimFunds(txHashVestedUTXO: string): Promise<string> {
    const assetUtxo: UTxO = await getUtxo(vestingAddr, txHashVestedUTXO);
    const redeemer: Pick<Action, "data"> = { data: { alternative: 0, fields: [] } };
    const slot: string = resolveSlotNo('preview', Date.now() - 40000);

    const tx = new Transaction({ initiator: wallet, fetcher: provider })
        .setNetwork("preview")
        .redeemValue({ value: assetUtxo,
                       script: vestingScript,
                       redeemer: redeemer})
        .setTimeToStart(slot)
        .sendValue(walletAddress, assetUtxo)
        .setRequiredSigners([walletAddress]);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash
}

// Function calls
//console.log(await sendFunds("5000000"));
//console.log(await claimFunds("<txHash>"));
----

First, we define the [blue]#getUtxo# function. It takes in a script address
and a transaction hash both of type [purple]#string#. It then checks if,
at the given address, a UTXO exists that contains the provided transaction
hash and then returns this UTXO. After that we define our function for
claiming funds from the vesting script address.

The [blue]#claimFunds# function takes in a transaction hash, which should
correspond to the UTXO we want to claim at the vesting address. We then
first look up that UTXO. Then we define an empty redeemer. We note that
if the redeemer would need to represent a custom data type that has more
than one data constructor we would state which data constructor we are
using with the number provided in the `"alternative:"` field, and we
would input the actual data in the list that follows the `"fields:"`
keyword. You can find an additional explanation of how to define a
redeemer for a custom data type at the
https://meshjs.dev/apis/transaction/smart-contract#redeemer[Using redeemer]
MeshJS docs section that also showcases a code example.

In the case that the redeemer does not represent a custom data type,
but a Plutus supported type as e.g. an [purple]#Integer# we would define
the redeemer as:

[source,typescript]
----
const redeemer: Pick<Action, "data"> = { data: BigInt(42) };
----

The number is, of course, code specific. You can find off-chain code for
the 42 validator example we have presented in a previous section at the
https://github.com/input-output-hk/plutus-pioneer-program/tree/plinth-plutusV3[plinth-plutusV3]
branch.

After we have defined the redeemer, we define the start slot for
the transaction. We use the [blue]#resolveSlotNo#, which takes in the
network we work on and a timestamp in milliseconds. We use the
current time and subtract 40.000 milliseconds. Then we define our
transaction. We first set the network and then use the [blue]#redeemValue#
function to redeem our vested UTXO. It takes in the UTXO we want to
redeem, the script at which the UTXO is residing and the redeemer.
The redeemer is optional and could be skipped. The same goes for
the datum, which we haven't provided here because we have inlined
the datum to the UTXO we are claiming.

Next, we set the validity interval for the transaction with the
[blue]#setTimeToStart# function. We provide the slot we have previously
defined, and the function sets the validity interval from this slot
onwards to infinity. There is also a [blue]#setTimeToExpire# function
that sets the time until which slot the transaction is still considered valid.
After that, we define that the lovelace carried by our vested UTXO should
go to our own address. Finally, we add the required signers for
the transaction and input our own wallet address that is linked
with the public key hash we have set in the datum of the vested UTXO.

Once we have created our transaction, we again have to build it,
sign it and submit it. Then we return the transaction hash. At the
end, we define the function calls for the [blue]#sendFunds# function
that we call with 5 ada, and the [blue]#claimFunds# function that
we call with the transaction hash the previous function call returns
and gets logged to the console. For a user to test this code, one
should first uncomment the first function call and run the code.
After the transaction is successfully submitted, we comment
the first command again, copy the logged transaction hash to the second
command, uncomment it and run the code again. If we name our file
that contains the off-chain code `vesting.ts` we can run the code
with the command below.

[source,console]
----
deno run -A vesting.ts
----

After the transactions completes, the transaction hash is shown in the
console and can be used to check transaction details on the
http://preview.cardanoscan.io/[preview.cardanoscan.io] webpage.

Now that we have seen the off-chain code for the vesting validator,
we can also look at the off-chain code that works with the parameterized vesting
validator `paramVestingVal` that we have also defined in the previous section.

[source,typescript]
----
import {
    BlockfrostProvider,
    MeshWallet,
    Transaction,
    PlutusScript,
    resolvePlutusScriptAddress,
    applyCborEncoding,
    deserializeAddress,
    resolveSlotNo,
    Data,
    MeshTxBuilder,
    Action
  } from "@meshsdk/core";
import { applyParamsToScript } from "@meshsdk/core-cst";
import { UTxO } from "@meshsdk/common";
import { secretSeed } from "./seed.ts";

// Define blockchain provider and wallet
const provider: BlockfrostProvider = new BlockfrostProvider("<blockfrost-key>");
const wallet: MeshWallet = new MeshWallet({
    networkId: 0, //0=testnet, 1=mainnet
    fetcher: provider,
    submitter: provider,
    key: {
        type: "mnemonic",
        words: secretSeed
    }
});
----

We first define the list of imports, which in addition contains the
[purple]#Data# type, [purple]#MeshTxBuilder# class and the [blue]#applyParamsToScript#
function. Then we define our blockchain provider and initialize our wallet.
Next, we define the vesting parameters and scripts we will use.

[source,typescript]
----
// Define address and public key hash of the wallet
const walletAddress: string = await wallet.getChangeAddress();
const beneficiaryPKH: string = deserializeAddress(walletAddress).pubKeyHash;

// Set the vesting deadline
const deadlineDate: Date = new Date("2025-03-05T12:30:10Z")
const deadlinePOSIX: bigint = BigInt(deadlineDate.getTime());

// Defining the parameter for the script
const scriptParameter: Data = { alternative: 0, fields: [beneficiaryPKH, deadlinePOSIX] };

// Defining our vesting script
const vestingParamScript: PlutusScript = {
    code: applyParamsToScript(
            applyCborEncoding("590e3801010032323232323232323232323232322259..."),
            [scriptParameter]),
    version: "V3"
};
const vestingParamAddr: string = resolvePlutusScriptAddress(vestingParamScript, 0);

// Defining burn address
const burnScript: PlutusScript = {
    code: applyCborEncoding("450101002601"),
    version: "V3"
};
const burnAddr: string = resolvePlutusScriptAddress(burnScript, 0);
----

As before, we define our wallet address, public key hash and
the deadline in POSIX milliseconds time. Then we define the script parameter
that we will apply to the parameterized script and that contains our own
public key hash and the deadline we have defined. Next we define our
parameterized vesting script. We again shorten the
`CBORHEX(((CBORHEX)))` compiled
code. The full compiled code can be found in the `blueprint.json` file that resides at the
https://github.com/input-output-hk/plutus-pioneer-program/tree/plinth-plutusV3[plinth-plutusV3]
branch. We now use the function [blue]#applyParamsToScript# and add the
script parameter we have previously defined. If there were more
than one parameter, we would enter all of them in the list in the
correct order. Then we compute the script address. We also define
the burn script, from which no funds can be retrieved. The reason for
this is that we will later show in the code how to deploy our vesting
script to a UTXO that we create at the burn script. And we will then
reference the script from that UTXO when claiming our vested funds.
Next, we can send some funds to the parameterized vesting script.

[source,typescript]
----
// Function for creating UTXO at vesting script
async function sendFunds(amount: string): Promise<string> {
    const tx = new Transaction({ initiator: wallet })
        .setNetwork("preview")
        .sendLovelace({ address: vestingParamAddr }, amount)
        .setChangeAddress(walletAddress);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash
}
----

We define the [blue]#sendFunds# function similar to the previous
vesting example. The difference is that this time we don't specify a
datum in the [blue]#sendLovelace# function. This means we will create
a UTXO without a datum. After that, we can deploy our parameterized
vesting script to a UTXO.

[source,typescript]
----
// Deploy a reference script
async function deployRefScript(lovelaceAmount: string): Promise<string> {
    const utxos = await wallet.getUtxos();
    const txBuilder = new MeshTxBuilder({
      fetcher: provider
    });

    const unsignedTx = await txBuilder
      .txOut(burnAddr, [{ unit: "lovelace", quantity: lovelaceAmount }])
      .txOutReferenceScript(vestingParamScript.code, vestingParamScript.version)
      .changeAddress(walletAddress)
      .selectUtxosFrom(utxos)
      .complete();

    const signedTx = await wallet.signTx(unsignedTx);
    const txHash = await wallet.submitTx(signedTx);
    return txHash
}
----

The [blue]#deployRefScript# function takes in a lovelace amount in the form of a
string which will be used to deploy the reference script. First we look
up the UTXO at our wallet. Then we define a transaction builder(((transaction, builder))) that we
will use to build the transaction. After that we define our transaction.
We first specify that we want to deploy our vesting script at the burn
address and the amount of lovelace we will spend. Then we specify the
parameterized script we want to deploy and its Plutus version. After
that we define our change address and from which UTXOs we want to
select our funds. We complete the transaction, sign and submit it
and return the transaction hash. Next, we can define our functions
for claiming the vested funds.

[source,typescript]
----
// Returns a UTXO at a given address that contains the given transaction hash
async function getUtxo(scriptAddress: string, txHash: string): Promise<UTxO> {
    const utxos = await provider.fetchAddressUTxOs(scriptAddress);
    if (utxos.length == 0) {
        throw 'No listing found.';
    }
    let filteredUtxo = utxos.find((utxo: any) => {
        return utxo.input.txHash == txHash;
    })!;
    return filteredUtxo
}

// Function for claiming funds
async function claimFunds(txHashVestedUTXO: string,
                          txHashRefUTXO: string): Promise<string> {
    const assetUtxo: UTxO = await getUtxo(vestingParamAddr, txHashVestedUTXO);
    const refScriptUtxo: UTxO = await getUtxo(burnAddr, txHashRefUTXO);
    const redeemer: Pick<Action, "data"> = { data: { alternative: 0, fields: [] } };
    const slot: string = resolveSlotNo("preview", Date.now() - 40000);

    const tx = new Transaction({ initiator: wallet, fetcher: provider })
        .setNetwork("preview")
        .redeemValue({ value: assetUtxo,
                       script: refScriptUtxo,
                       redeemer: redeemer})
        .setTimeToStart(slot)
        .sendValue(walletAddress, assetUtxo)
        .setRequiredSigners([walletAddress]);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash
}

// Function calls
//console.log(await sendFunds("3000000"));
//console.log(await deployRefScript("20000000"));
//console.log(await claimFunds("<tx-hash>", "<tx-hash>"));
----

The [blue]#getUtxo# function is defined the same way as in our previous off-chain
code example. The [blue]#claimFunds# function is defined in a similar way
as in the previous code. It takes in the transaction hash of our
UTXO we have vested at the script, and also the transaction
hash of the UTXO that contains our deployed vesting script. In the body
of the function, we first define our UTXO that we want to claim. Then
we define the UTXO that contains our script. After that we again define
the redeemer and slot, as in the previous off-chain code.

The transaction to claim the funds is also structured similarly
to the previous example. The only difference is that now the [blue]#redeemValue#
function takes in the reference UTXO that contains the parameterized vesting
script instead of the actual script. We again set the validity interval
and the required signature to the transaction. After that we build, sign
and submit the transaction and return the transaction hash.

At the end, we define the function calls by logging their return values.
We send 3 ada to the parameterized vesting script. Then we deploy the
script to the burn address and use 20 ada for that. The amount cannot
be too low and depends on the script size we are deploying. Lastly we
claim the funds. There we have to input the transaction hashes that the
previous two function calls returned. As in our previous off-chain code
example, we have to uncomment only one line at a time and execute the
code. If we name our file `vesting-param.ts` we can again execute it
with Deno as:

[source,console]
----
deno run -A vesting-param.ts
----

We can again check the transaction details by inputing the hashes at the
http://preview.cardanoscan.io/[preview.cardanoscan.io] webpage.

We note that the reason that it would make sense to deploy a script to
an unredeemable UTXO, is that referencing a script from a UTXO is cheaper
than attaching it to the transaction. Of course, the upfront cost is
larger because we need to pay fees for deploying the script. So this
use case pays off if we need to reference this script many times, which
could be the case for a DApp. Also, if the UTXO is created at a script
address where funds are burned, it becomes unspendable and permanently
accessible.

We make an important distinction between off-chain and on-chain code.
Because Cardano uses the hard fork combinator(((HFC))) technology, all Plutus
script versions are supported by the blockchain (read more in section
<<cardano-node-layers, Cardano node layers>>). Once you have written on-chain code that works,
it will work indefinitely. That is not the case for off-chain code.

Because the ledger rules can be updated, it can happen that conditions which
a transaction needs to fulfill may change. An example is the required ada fee
when attaching a reference script to a transaction. Some off-chain code libraries
may calculate this fee automatically. This calculation then holds true for a
specific Cardano era and may not work in future eras if blockchain parameters change.
For this reason, it is good practice to upgrade the off-chain code library versions
your code is using and test the code when upgrades to the Cardano ledger happen.

More information about MeshJS is available at:

* https://meshjs.dev/guides[MeshJS guides]
* https://docs.meshjs.dev/[MeshJS documentation]
* https://github.com/MeshJS/examples/tree/main[MeshJS examples repository]
* https://pbl.meshjs.dev/course/mesh[Mesh project based learning page]

In the next section, we show how to write a minting policy and off-chain code
that interacts with the policy.

[[chapter8-minting-policies-and-native-tokens]]
==== Minting policies and native tokens

In Plutus, a minting policy(((minting policy))) or minting script defines the
conditions under which native tokens(((native tokens))) can be minted. Each UTXO has an
address, a value, and potentially a datum. In previous examples, the
value was always ada. To include native tokens in a UTXO, they must be
explicitly created.
The https://iohk.io/en/blog/posts/2025/05/09/native-tokens-in-the-extended-utxo-model/[IO
blog on native tokens] states that on many blockchains, creating custom tokens
traditionally requires writing and deploying smart contracts – code that
defines how the token behaves and how it can be transferred, created (minted),
or destroyed (burned). This approach makes these user-defined tokens
non-native, meaning the underlying blockchain’s fundamental structure
does not directly support them, -- which can lead to inefficiencies, higher
costs, and increased complexity. In Cardano all tokens are native, which
means developers can create and manage their own tokens without relying
on complex smart contracts. These tokens are treated as first-class
citizens by the ledger, enabling secure and efficient handling of many
token types directly at the protocol level. The blog further states
that the key advantages of native tokens in Cardano over traditional
smart contract-based approaches are:

* Efficiency and lower costs. Because native tokens are supported at the
ledger level, their creation, transfer, and management require no custom
contract logic. This reduces transaction size, increases throughput, and
significantly lowers fees. Operations are faster and consume fewer resources
compared to tokens built with smart contracts.
* Security and simplicity. Native tokens inherit the same security properties
as ada. There is no additional contract logic to audit or maintain, reducing
the risk of vulnerabilities and exploits. This makes native tokens simpler
and safer to use in DApps.
* Developer experience and compatibility. Creating and managing native tokens
is more straightforward than writing and deploying custom contracts. Native
tokens integrate seamlessly with wallets, tools, and the wider ecosystem.

One can read more about the security advantages of native tokens on Cardano
in the <<chapter8-cardano-security, Cardano security>> section.
Before we look at an example of a minting
policy, let us look again at the Haskell definition of the [purple]#Value# type.
This type is defined in the module `PlutusLedgerApi.V1.Value` and defines an
amount of ada and/or native tokens.

[source,haskell]
----
newtype Value = Value { getValue :: Map CurrencySymbol (Map TokenName Integer) }
    deriving stock (Generic, Data, Typeable, Haskell.Show)
    deriving anyclass (NFData)
    deriving newtype (PlutusTx.ToData, PlutusTx.FromData, PlutusTx.UnsafeFromData)
    deriving Pretty via (PrettyShow Value)
----

The Value type is a map object that connects a currency symbol to
another map, which uses token names as its keys. Both token names and
currency symbols are wrappers for the type [purple]#BuiltinByteString#,
representing a byte string. As said before, the currency symbol represents
the hash of the minting policy and the `ada` token is defined by an empty
byte string both for currency symbol and token name, which means one
cannot mint ada. These two byte strings define a native token
or coin, while the integer represents the token's amount. Additionally,
there is another type called [purple]#AssetClass#.

[source,haskell]
----
newtype AssetClass = AssetClass
    { unAssetClass :: (CurrencySymbol, TokenName)
    }
    deriving stock (Generic, Data, Typeable)
    deriving newtype
      ( Haskell.Eq
      , Haskell.Ord
      , Haskell.Show
      , Eq
      , Ord
      , PlutusTx.ToData
      , PlutusTx.FromData
      , PlutusTx.UnsafeFromData
      )
    deriving anyclass (NFData, HasBlueprintDefinition)
    deriving (Pretty) via (PrettyShow (CurrencySymbol, TokenName))
----

It combines the currency symbol and token name to define an asset class,
which can represent a native token or ada. Because the value type is a map,
it can contain different tokens and amounts, including ada. To construct a
value, we can use the function [blue]#assetClass#, which takes a currency
symbol and token name, and returns a variable of type asset class. We can
then use the function [blue]#assetClassValue#, which takes an asset class
and integer, and returns a variable of type value. With the [blue]#assetClassValueOf#
function, we can check how many tokens of a specific asset class are contained
in a value type variable. Below, you can see the type signatures of these functions.

[source,haskell]
----
assetClass :: CurrencySymbol -> TokenName -> AssetClass
assetClassValue :: AssetClass -> Integer -> Value
assetClassValueOf :: Value -> AssetClass -> Integer
----

To construct a value variable and check the amount of tokens in it for a
specific asset class, we can do as follows from Prelude that we have
build with the required Plutus libraries.

[source,console]
----
Prelude> import PlutusLedgerApi.V1.Value
Prelude PlutusLedgerApi.V1.Value> :set -XOverloadedStrings
Prelude PlutusLedgerApi.V1.Value> myAssetClass = assetClass "a507ff33" "MyToken"
Prelude PlutusLedgerApi.V1.Value> myTokenValue = assetClassValue myAssetClass 77
----

To construct an asset class for ada, we can use the [blue]#adaSymbol# and
[blue]#adaToken# variables provided by the `PlutusLedgerApi.V1.Value` module.

[source,console]
----
Prelude PlutusLedgerApi.V1.Value> ada = assetClass adaSymbol adaToken
Prelude PlutusLedgerApi.V1.Value> adaValue = assetClassValue ada 100000000
----

We can also combine different variables of type value with the semigroup
operator [blue]#<># as the value type has an instance of the semigroup type
class. Using the [blue]#assetClassValueOf# function, we can get the quantity of
a given asset class contained in a value.

[source,console]
----
Prelude PlutusLedgerApi.V1.Value> combined = myTokenValue <> adaValue
Value (Map [(,Map [("",100000000)]),(a507ff33,Map [("MyToken",77)])])
Prelude PlutusLedgerApi.V1.Value> assetClassValueOf combined myAssetClass
77
----

We can also extract information from a value type variable as a list of
triples using the [blue]#flattenValue# function.

[source,console]
----
Prelude PlutusLedgerApi.V1.Value> :t flattenValue
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
Prelude PlutusLedgerApi.V1.Value> flattenValue combined
{empty}[(,"",100000000),(a507ff33,"MyToken",77)]
----

So far, we have focused on the spending constructor of the
[purple]#ScriptInfo# type variable that defines the purpose of the
currently-executing script. The [purple]#TxInfo# data type contains the
[purple]#MintValue# type that is structured the same way as the [purple]#Value#
type. Minting policies are triggered if this field contains a non-zero
value. Each currency symbol defined in this variable activates the
corresponding minting policy, linking them through the policy's hash.

A minting policy, like a spending validation script, only requires
one input: the script context. If for the currently-executing script the
[purple]#ScriptInfo# data type defines the minting constructor that is
parameterized with a currency symbol, then the corresponding minting policy
gets triggered. The minting constructor does not contain a maybe datum like
the spending constructor does, because datums can exist at UTXOs sitting
at script addresses, and minting scripts do not consume these UTXOs; they
only produce new ones.

A single transaction may trigger several different minting policies if
multiple native tokens with distinct currency symbols are minted. Each policy
receives its own script info and redeemer as input, and they share the same
transaction information data type. All minting policies within a transaction
must pass for the transaction to succeed; otherwise it fails.

Now, let us examine an example of a minting policy where only the owner
of a specific public key, who signs the transaction, is permitted to
mint or burn tokens. This key could represent a project or company
acting like a central bank in traditional finance, responsible for
minting and burning fiat currencies. Our minting policy will be
parameterized, accepting an additional public key hash as a parameter.

[source,haskell]
----
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveAnyClass             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost        #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE Strict                     #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE ViewPatterns               #-}
{-# OPTIONS_GHC -fno-full-laziness #-}
{-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}
{-# OPTIONS_GHC -fno-omit-interface-pragmas #-}
{-# OPTIONS_GHC -fno-spec-constr #-}
{-# OPTIONS_GHC -fno-specialise #-}
{-# OPTIONS_GHC -fno-strictness #-}
{-# OPTIONS_GHC -fno-unbox-small-strict-fields #-}
{-# OPTIONS_GHC -fno-unbox-strict-fields #-}
{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}

module Week05.Minting where

import           PlutusLedgerApi.Common      (SerialisedScript,
                                              serialiseCompiledCode)
import           PlutusLedgerApi.V1.Value    (flattenValue)
import           PlutusLedgerApi.V3          (ScriptContext (..), TokenName,
                                              TxInInfo (txInInfoOutRef),
                                              TxInfo (txInfoInputs, txInfoMint),
                                              TxOutRef (TxOutRef), TxId (TxId),
                                              PubKeyHash)
import           PlutusTx                    (BuiltinData, CompiledCode,
                                              UnsafeFromData (unsafeFromBuiltinData),
                                              compile)
import           PlutusLedgerApi.V3.Contexts (txSignedBy)
import           PlutusTx.Bool               (Bool (..), (&&))
import           PlutusTx.Prelude            (BuiltinUnit, Eq ((==)), any, check,
                                              traceIfFalse, ($))

{- ------------------------------------------------------------------------------ -}
{- --------------------------------- VALIDATOR ---------------------------------- -}

{-# INLINABLE signedVal #-}
signedVal :: PubKeyHash -> ScriptContext -> Bool
signedVal pkh ctx = traceIfFalse "missing signature" $
                                 txSignedBy (scriptContextTxInfo ctx) pkh

{- ------------------------------------------------------------------------------ -}
{- ---------------------------------- HELPERS ----------------------------------- -}

compiledSignedVal :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinUnit)
compiledSignedVal = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinData -> BuiltinUnit
  wrappedVal pkh ctx = check $ signedVal
                                 (unsafeFromBuiltinData pkh)
                                 (unsafeFromBuiltinData ctx)

serializedSignedVal :: SerialisedScript
serializedSignedVal = serialiseCompiledCode compiledSignedVal
----

First, we add all the necessary language pragmas. We then name the
module `Week05.Minting` since the idea for the code examples is taken
from the 5th week of the 4th Plutus pioneer program. After that, we
import the modules we need. Next we define our minting policy. It
is parameterized with a public key hash and the validation checks if
the correct signature is present. We do not check if the currently
executing script has a minting purpose specified. In that sense, this
validation logic could also be used as a spending script. Then we
compile the minting policy as in the examples before, and serialize
it. Now that we have our minting policy, we can look at the off-chain
code that interacts with it.

[source,typescript]
----
import {
    BlockfrostProvider,
    MeshWallet,
    Transaction,
    PlutusScript,
    applyCborEncoding,
    deserializeAddress,
    Mint,
    Action
  } from "@meshsdk/core";
import { applyParamsToScript } from "@meshsdk/core-cst";
import { secretSeed } from "./seed.ts";

// Define blockchain provider and wallet
const provider: BlockfrostProvider = new BlockfrostProvider("<blockfrost-key>");
const wallet: MeshWallet = new MeshWallet({
    networkId: 0, //0=testnet, 1=mainnet
    fetcher: provider,
    submitter: provider,
    key: {
        type: "mnemonic",
        words: secretSeed
    }
});

// Define address and public key hash of it
const walletAddress: string = await wallet.getChangeAddress();
const signerHash: string = deserializeAddress(walletAddress).pubKeyHash;

// Defining our minting policy
const mintingPolicy: PlutusScript = {
    code: applyParamsToScript(
            applyCborEncoding("590b490101003232323232323232323232322259..."),
            [signerHash]),
    version: "V3"
};
----

First, we import all necessary MeshJS classes and functions, then
we define our blockchain provider and wallet, same as before. Next we
read out our wallet address and the public key hash. Then we
define our minting policy, where we apply the public key hash as
a parameter. Then follows the code for minting tokens.

[source,typescript]
----
// Defining our token
const token: Mint = {
    assetName: 'MyTokens',
    assetQuantity: '2',
    recipient: { address: walletAddress }
  }

// Minting our tokens
async function mintTokens(): Promise<string> {
    const redeemer: Pick<Action, "data"> = { data: { alternative: 0, fields: [] } }

    const tx = new Transaction({ initiator: wallet, fetcher: provider })
        .setNetwork("preview")
        .mintAsset(mintingPolicy, token, redeemer)
        .setRequiredSigners([walletAddress]);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash
}

// Function calls
console.log(await mintTokens());
----

We first define the tokens we want to mint where we specify the token
name, amount of tokens, and the address where the tokens should be created.
In Plutus, a token name can be an arbitrary byte string which is limited
to 32 bytes. If a human-readable name is set, wallets also display it in
that form. The number of tokens has to be a positive integer. After setting
the tokens we want to mint, we define our minting function. In it, we first
define an empty redeemer. Next, we create our transaction. In the transaction
we set the network, say which tokens we want to mint with which minting
policy, add the redeemer, and sign the transaction with our wallet key.
At the end we build, sign and submit the transaction and return the
transaction hash. Now we can make our function call and mint the tokens.
If we name our file `signed-minting.ts`, we can mint our tokens as:

[source,console]
----
deno run -A signed-minting.ts
----

We can then check the transaction details again on the
http://preview.cardanoscan.io/[preview.cardanoscan.io] webpage.
This was an example of minting fungible tokens. Fungibility(((fungible))) means
that one token is interchangeable with another token of the same type,
meaning each unit has the same value as any other unit.

Plutus also allows the minting of non-fungible tokens (NFTs), which are
unique tokens that can only be minted once. The key to writing such a
minting policy is referencing something unique on the blockchain,
and for that, we use UTXOs. UTXOs can exist only once, and once consumed
as input to a transaction, they can never exist again. UTXOs are defined
by transaction hashes, which are unique, and by output indices. The reason
every transaction has a unique hash was explained in section
<<chapter8-script-context-explained, Script context explained>>.

When minting an NFT, the idea is to include a specific parameter in the
minting policy – namely, a UTXO transaction hash and ID – and have the policy
check that the transaction performing the minting consumes that specific UTXO.
Let us look at an example of such a minting policy.

[source,haskell]
----
{- ------------------------------------------------------------------------------ -}
{- ------------------------------- NFT VALIDATOR -------------------------------- -}

{-# INLINEABLE nftVal #-}
nftVal :: TxOutRef -> TokenName -> ScriptContext -> Bool
nftVal oref tn ctx =
  traceIfFalse "UTxO not consumed" checkHasUTxO &&
  traceIfFalse "You can only mint one!" checkMintedAmount
 where
  checkHasUTxO :: Bool
  checkHasUTxO = any (\i -> txInInfoOutRef i == oref) $ txInfoInputs info

  checkMintedAmount :: Bool
  checkMintedAmount = case flattenValue (txInfoMint info) of
    [(_, tn', amt)] -> tn' == tn && amt == 1
    _               -> False

  info :: TxInfo
  info = scriptContextTxInfo ctx

{- ------------------------------------------------------------------------------ -}
{- ---------------------------------- HELPERS ----------------------------------- -}

compiledNftVal :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData ->
                                BuiltinData -> BuiltinUnit)
compiledNftVal = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinData -> BuiltinData ->
                BuiltinData -> BuiltinUnit
  wrappedVal tid idx tn ctx =
    let oref :: TxOutRef
        oref = TxOutRef
          (TxId $ unsafeFromBuiltinData tid)
          (unsafeFromBuiltinData idx)
    in check $ nftVal
                 oref
                 (unsafeFromBuiltinData tn)
                 (unsafeFromBuiltinData ctx)

serializedNFTVal :: SerialisedScript
serializedNFTVal = serialiseCompiledCode compiledNftVal
----

The language pragmas and import of modules from the previous minting
policy example also cover the functionality needed in this minting policy.
Our script will be parameterized by two inputs: the transaction output
reference - [purple]#TxOutRef# - of the UTXO we are spending and the token
name. The condition we check is that the minting transaction consumes the
specified transaction reference passed to the script. The [blue]#any# function
is used to check this. It takes a Boolean-returning function and applies
it to a list, returning true if at least one element satisfies the condition.
We also ensure that only one token with the specified name is minted by using
the [blue]#flattenValue# function, which converts a value type into a list
of triples. These checks ensure only one coin is minted with the currency
symbol tied to a specific parameterized script.

After we have defined our minting policy, we compile it. The transaction
output reference is made up of two types, which are the transaction hash
and output index. Before we compile our script in untyped form, we can change
it such that it takes in the transaction hash and output index as two separate
parameters. We do that in the [blue]#wrappedVal# helper function. It takes
in four parameters that are all of the type [purple]#BuiltinData# and converts them
to their custom data types before applying them to our typed minting policy.
After we compile our untyped minting policy, we serialize it. In principle,
we could also leave our policy such that it takes in the transaction output
reference as a whole and then model that in our off-chain code. In our code,
we wanted to show how to split up such a variable and correctly apply
the [blue]#unsafeFromBuiltinData# to individual parts. Next, we present the
off-chain code that interacts with our NFT minting policy(((NFT, minting policy))).

[source,typescript]
----
import {
    BlockfrostProvider,
    MeshWallet,
    Transaction,
    PlutusScript,
    applyCborEncoding,
    UTxO,
    Action,
    Mint
  } from "@meshsdk/core";
import { applyParamsToScript } from "@meshsdk/core-cst";
import { secretSeed } from "./seed.ts";

// Define blockchain provider and wallet
const provider: BlockfrostProvider = new BlockfrostProvider("<blockfrost-key>");
const wallet: MeshWallet = new MeshWallet({
    networkId: 0, //0=testnet, 1=mainnet
    fetcher: provider,
    submitter: provider,
    key: {
        type: "mnemonic",
        words: secretSeed
    }
});

// Define address and public key hash of it
const walletAddress: string = await wallet.getChangeAddress();

// Defining the UTXO we want to spend
const utxos: UTxO[] = await wallet.getUtxos();
const utxo: UTxO = utxos[0];

// Defining our NFT policy
const nftPolicy: PlutusScript = {
    code: applyParamsToScript(
            applyCborEncoding("590bf50101003232323232323232323232323232222259..."),
            [utxo.input.txHash, BigInt(utxo.input.outputIndex), "My NFT"]),
    version: "V3"
};
----

First, we again import all necessary MeshJS classes and functions
and define our provider and wallet. After that we set our wallet
address and read out the first UTXO sitting at our wallet address.
We will use this UTXO to parameterize our minting policy and also
spend it when creating the minting transaction. Next we define our
NFT minting policy(((NFT, minting policy))). We again shortened the
compiled code and parameterize
the code with the transaction hash and output index of the UTXO we
selected. We also provide the name of our NFT we want to mint. Now
we can look at the function that mints the NFT.

[source,typescript]
----
// Defining our NFT token
const nftToken: Mint = {
    assetName: 'My NFT',
    assetQuantity: '1',
    recipient: { address: walletAddress }
  }

// Minting our NFT
async function mintNFT(): Promise<string> {
    const redeemer: Pick<Action, "data"> = { data: { alternative: 0, fields: [] } }

    const tx = new Transaction({ initiator: wallet, fetcher: provider })
        .setNetwork("preview")
        .setTxInputs([utxo])
        .mintAsset(nftPolicy, nftToken, redeemer);

    const txUnsigned = await tx.build();
    const txSigned = await wallet.signTx(txUnsigned);
    const txHash = await wallet.submitTx(txSigned);
    return txHash
}

// Function calls
console.log(await mintNFT());
----

We define our token that we want to mint and provide the
token name, token quantity (which should be one), and set the
recipient address to our own address. Then we define our minting
function. We set an empty redeemer and create the transaction,
similar to the previous minting policy. The difference is
that in this example we specify the UTXO we want to spend,
and we do not need to add the required signature linked to
our wallet as we did in the previous minting example. At the
end we build, sign and submit the transaction and return
the transaction hash. When we call the minting function,
we again log the hash such that it can be used at the
http://preview.cardanoscan.io/[preview.cardanoscan.io] webpage
to inspect our transaction that minted the NFT.

If we run this code multiple times, we would create tokens with
the same name but different currency symbols because we would parameterize
the minting script each time with a different UTXO. This difference in
currency symbols ensures that each token is truly an NFT, as the asset
class is defined by both the token name and its unique currency symbol.

It is also possible to associate an image with a token or NFT. It can be
referenced from the https://ipfs.tech/[InterPlanetary file system] or
embedded as a https://en.wikipedia.org/wiki/Base64[base64] encoded string
into the datum metadata of the token or NFT. For more information, see
https://cips.cardano.org/cip/CIP-68[CIP-68]
that defines the datum metadata standard.
The https://meshjs.dev/apis/txbuilder/minting#mintingCip68[MeshJS docs] provide
an example of how to mint assets with the CIP-68(((CIP-68))) metadata standard.

At the end of this section, we note that the utility of a token can be determined by its use
case, the market, or the community that issues and adopts it. Tokens can be
used for various purposes such as issuing a new cryptocurrency, representing access
rights, or enabling in-app transactions. Native tokens(((native tokens))) enable a wide range of
applications by combining secure on-chain logic with the flexibility of custom
asset creation. From the
https://iohk.io/en/blog/posts/2025/05/09/native-tokens-in-the-extended-utxo-model/[IO
blog on native tokens] we get the following use cases for native tokens:

* Digital collectibles and credentials. NFTs(((NFTs))) can represent ownership of digital
art, in-game assets, event tickets, or even academic credentials – benefiting
from the security and transparency of the Cardano ledger.
* Supply chain and asset tracking. Tokens can represent physical items and track
their journey across a supply chain. Because native tokens can be uniquely defined
and managed without smart contracts, this approach is more efficient and secure.
* Algorithmic stablecoins(((algorithmic stablecoin))).
Native tokens can represent assets with values tied to
external references. Forging policy scripts define the rules that keep these tokens
stable, enabling automated monetary policies and more robust decentralized finance
(DeFi) primitives.
* Tokenized roles and permissions. Roles within a decentralized system – such as
operator, validator, or participant – can also be represented by unique native tokens.
Holding a token grants permission to perform specific actions, allowing for modular
and transferable system designs.
* Access control and licensing. A token could grant access to a service, event,
or dataset. For example, holding a specific token could unlock premium features
in a DApp or grant entry to a token-gated community.
* Decentralized governance. Native tokens can represent voting rights or stake
in decision-making processes. This enables on-chain governance systems with
transparent and auditable participation.

To learn more about native tokens, see:

* https://docs.cardano.org/developer-resources/native-tokens/[Native
tokens] overview on Cardano Docs
* https://developers.cardano.org/docs/native-tokens/[Discover native
tokens] section on the Developer Portal
* https://cardano-ledger.readthedocs.io/en/latest/explanations/index.html[Ledger
explanations] page, which also covers native tokens
* https://iohk.io/en/research/library/papers/native-custom-tokens-in-the-extended-utxo-model/[Native
Custom Tokens in the Extended UTXO Model] scientific paper.

[[chapter8-plutusv3-features]]
==== PlutusV3 features

PlutusV3(((PlutusV3))) focuses on performance throughput, smart contract size,
platform capabilities, and interoperability with other blockchains.
Specifically, PlutusV3 brings:

* Bitwise primitives
* Cryptographic primitives
* Sums of products(((sums of products))).

Bitwise primitives allow for the manipulation of data at the lowest
level of bits. Those operations are the fundamental building blocks of
many algorithms and data structures. There are numerous applications,
ranging from efficient representation and manipulation of sets of
integers to the implementation of cryptographic primitives(((cryptographic, primitives)))
and fast searches. In particular, PlutusV3 enables converting integers to byte
strings, which allows, for example, to hash arbitrary data, which hasn't
been possible in the past.

Cryptographic primitives form the foundation of blockchain technology.
The choice of primitives significantly influences a blockchain's
capabilities. Because other blockchains choose different primitives from
Cardano, it is challenging to interoperate with them. An example of
interoperability is checking Ethereum signatures in Plutus, which is
possible with PlutusV3. There are three groups of new cryptographic
primitives in PlutusV3:

* BLS12-381(((BLS12-381))) is about elliptic curve pairing and including 17 primitives
that support cryptographic curves. Use cases include sidechains(((sidechains))),
ZKP(((ZKP))), Hydra(((Hydra))), Mithril(((Mithril))) and ATALA
* Blake2b_224(((Blake2b_224))) is a cryptographic hash function(((cryptographic, hash function)))
that enables hashing of public keys and scripts within Plutus, facilitating various interesting
applications
* Keccak-256(((Keccak-256))) is another cryptographic hash function(((cryptographic, hash function))) that supports Ethereum signature verification within Plutus scripts.

These cryptographic primitives(((cryptographic, primitives))) bring new possibilities,
unlock better ways to achieve scalability, and allow for better interoperability with
Ethereum and EVM-based blockchains(((blockchain, EVM-based))).
The https://www.youtube.com/watch?v=oFgJg_DulKw&t=69s[PlutusV3
Overview] video demonstrates how to lock ada in a Plutus validator that
can only be unlocked by the owner of an ETH wallet. The demonstration
starts at 4:10. You can also read more about PlutusV3 and the features
that it brings in the IO blog
https://iohk.io/en/blog/posts/2024/02/12/unlocking-more-opportunities-with-plutus-v3/[Unlocking
more opportunities with PlutusV3]. The official documentation provides
further information on the
https://docs.cardano.org/about-cardano/evolution/upgrades/chang/[Chang
hard fork] that enables PlutusV3.

The last feature PlutusV3 brings is sums of products(((sums of products))).
One common method for encoding data types in Plutus Core(((Plutus core)))
is the Scott approach(((Scott approach))). With the
introduction of PlutusV3, sums of products allow for encoding data types
more compactly and cost-effectively than Scott encoding, so the latter
is no longer required. The sums of products method is designed to enhance
script efficiency and optimize code generation for Plutus Core compilers.
This involves implementing new term constructors for packing fields into
constructor values and enabling efficient tag inspection for case branches.
As a result, programs may experience a performance increase of up to 30%,
marking a significant optimization that streamlines operations and
ensures faster execution of smart contracts. For further details, refer
to https://cips.cardano.org/cip/CIP-0085[CIP-85]. Sums of products do
not change built-in functions available in Plutus, but change the Plutus
language itself. Also, Plutus now provides a way to deal directly with the
[purple]#Data# type for all Plutus script versions (V1, V2 and V3) that
allows for better code optimization. This is discussed further in section
<<chapter8-simple-validation-scripts, Simple validation scripts>>. The
https://plutus.cardano.intersectmbo.org/docs/working-with-scripts/optimizing-scripts-with-asData[Plinth user guide] also provides information on that.

[[chapter8-smart-contract-security]]
=== Smart contract security

[[chapter8-cardano-security]]
==== Cardano security

The security of smart contracts is an important topic, since these programs
can manage significant amounts of funds. Coindesk's(((Coindesk))) estimate of
the loss of funds due to various attacks and hacks, including scams, was over
$3.2bn in 2021 and over $3.7bn in 2022 (source:
https://www.coindesk.com/tech/2023/05/24/attackers-left-empty-handed-as-crypto-hacks-drop-70-in-q1-2023/[CoinDesk]).
If we look at hacks to blockchain smart contracts and bridges only, up to
October 2023 they have totaled $4.28bn (source:
https://www.emurgo.io/press-news/why-your-web3-dapp-needs-a-smart-contract-audit/[Emurgo]).
The graph below displays the cumulative amount of lost funds in audited
and unaudited codebases for Web3(((Web3))) projects in a three-year period (data
taken from the https://rekt.news/leaderboard/[Rekt leaderboard]). Out
of 137 compromised projects, 58 were audited, and 79 were not, meaning
that unaudited Web3 projects account for a substantially larger
cumulative loss of funds, even though their number is not significantly
higher than the number of audited projects.

image::sc_loss_of_funds.png[width=630,height=420,title="Loss of funds, source: https://www.cyfrin.io/blog/competitive-vs-private-audits-comparison[Cyfrin blog]"]

Nevertheless, a $1.1bn loss in audited projects is still high. This
implies that an audit by itself may not always ensure a project's
safety. Other factors, such as the auditing methodology and the security
features of the underlying blockchain also influence the safety of a project.

A software audit is a type of software review where one or more auditors
(usually third parties) conduct an examination of a software product to
assess compliance with specifications, standards, contractual
agreements, and other criteria (source:
https://en.wikipedia.org/wiki/Software_audit_review[Wikipedia]).
Blockchain auditing can be defined as the systematic process of
reviewing and analyzing a blockchain's codebase and its specifications.
It involves code revision to ensure no hidden or unwanted design flaws
or bugs that may lead to production issues. Besides security guarantees,
an audit can also prove compliance with industry standards and best
practices and increase trust and credibility. Audits can be grouped into
manual auditing(((auditing, manual))), where each line of code is analyzed by the auditors,
and automated auditing(((auditing, automated))), where auditors use software auditing tools. A
combination of both is also possible. Auditing of smart contracts is
further discussed in the <<chapter8-plutus-security, Plutus security>> section.

Cardano(((Cardano))) was designed with security in mind from the beginning.
Input | Output (IO) has invested much effort into academic research, and its
research team has written and collaborated on more than
https://iohk.io/en/research/library/[250 scientific papers].
Some of the important research areas that IO targets are cryptography,
software engineering, distributed systems(((distributed system))),
networks, formal verification, and programming languages. Ouroboros(((Ouroboros))),
Cardano's consensus protocol, is explained in detail in section
<<OuroborosConsensus, Ouroboros consensus>>. Ouroboros represents the outcome of long
research presented in multiple papers. It is the first blockchain
consensus protocol developed through peer-reviewed research with
mathematically proven security features that guarantee the protocol is
secure as long as 51% of the active stake (ada locked in for an epoch
snapshot) is held by honest participants. The extended UTXO (EUTXO)
model, explained in section <<chapter4-the-eutxo-model, The EUTXO model>>, was also
developed through extensive research and is well-tested by the
community. There have been no major security breaches, and the Cardano
mainnet has not experienced any downtime. An event happened in January
2023 that affected the functionality of around half of all Cardano
nodes(((Cardano, node))). During this event, the network was still
processing transactions, and within minutes, nodes started to recover
by being manually restarted by stake pool operators(((stake pool, operator))) or by
system management software. After the
restart, the nodes that were down managed to continue growing the chain
and producing blocks. The consensus algorithm worked, and the network
never split, which was due to Cardano's robust design. The issue was
later identified and fixed. Details can be found in
https://www.314pool.com/post/cardano-post-mortem-1[this] and
https://cardanospot.io/news/cardano-node-outage-what-we-know-0[this]
post-mortem.

In EUTXO, transactions can be validated _before_ they are submitted to the
blockchain. Given that the inputs are present at the time of submission and
that the validity interval contains the time of transaction processing,
a valid transaction will _always_ succeed with a predictable outcome.
There is no global state and a smart contract only sees data contained
in the script context that provides access to the datum if present, the
redeemer, all inputs and outputs and other transaction information. Section
<<chapter8-plutus-smart-contracts, Plutus smart contracts>> explains
these concepts in detail. We say that
transactions are deterministic in EUTXO since their effect on the ledger is
predictable. If the inputs to a valid transaction are not present at the
time of submission, the submitted transaction will not be processed, and
the user will not be charged any fees. Because of determinism(((determinism))) in EUTXO,
multiple transactions that target the same validator can be processed inside
the same block if the transactions consume different inputs. Besides this,
https://iohk.io/en/blog/posts/2022/04/13/boosting-cardano-s-throughput-with-script-referencing/[reference
inputs] enable multiple transactions referencing the same UTXO, which
is possible because none of those transactions consumes the referenced
UTXO. These things make Cardano suitable for parallelism and
concurrency(((concurrency))). One can read more about these topics in this
https://iohk.io/en/blog/posts/2021/09/10/concurrency-and-all-that-cardano-smart-contracts-and-the-eutxo-model/[IO blog].

In Ethereum(((Ethereum))), transactions that target the same validator can be processed
within the same block, but they both do not necessarily succeed, since the
first transaction could alter the state such that the second transaction fails.
Because the state can change between when a user submits a transaction and
when it is processed, this means an Ethereum transaction can fail after
the user pays the transaction fee. We note that in Cardano, it is possible
that a user forces an invalid transaction to be processed, which will fail.
In such a case, the user will be charged fees because an attacker could try
to flood the network with invalid transactions to congest it, and the fees
make such an attack very expensive.

This https://iohk.io/en/blog/posts/2021/09/06/no-surprises-transaction-validation-on-cardano/[IO
blog] explains in more detail the determinism(((determinism))) of transaction and script
validation in Cardano. The blog states that account-based blockchains
like Ethereum are indeterministic, which means that they cannot guarantee
the predictability of the transaction's effect on-chain. It further explains
the key points that make the outcomes of script and transaction validation
predictable on Cardano, which are:

[arabic]
. The script interpreter will always terminate and return the same
validation result when applied to the same arguments
. A transaction necessarily fixes all arguments that will be passed to
the script interpreter during validation
. A transaction specifies all the actions it is taking that require
script validation
. Compulsory signatures on a transaction ensure that it cannot be
altered by an adversary in a way that causes scripts to fail
. Applying a transaction in the EUTXO ledger model is deterministic.

Also, transaction fees are deterministic in Cardano. A user knows how much a
transaction will cost before they submit it. The reason for this is that protocol
parameters, rather than network traffic, govern pricing on Cardano.
Determinism of fees and transactions can also be advantageous in Web3(((Web3)))
applications, such as decentralized exchanges (DEXs). On DEXs, users trade
with the help of smart contracts that eliminate the need for a central entity.
Liquidity providers that provide token pairs to DEXs, such that normal
users can trade those tokens, face the issue of impermanent loss on DEXs
that use the https://www.coindesk.com/learn/what-is-an-automated-market-maker/[Automated
market maker] (AMM) design model. In an AMM-style DEX, smart contracts
enable automated trading of cryptocurrency pairs, which are often a
fungible token or a native cryptocurrency together with a stablecoin.

To explain how impermanent loss(((impermanent loss))) works, let us consider
an example of an AMM DEX where the deposited token pair is ETH and USDT (Tether),
a stablecoin pegged to the value of the USD. If the price of 1 ETH is
1,000 USD and a liquidity provider wants to add 1 ETH to the pool,
he must also add 1,000 USDT. Then, over time, the price of ETH rises
to 3,000 USD, which is three times larger than the initial price.
During this time,
https://www.coindesk.com/learn/crypto-arbitrage-trading-how-to-make-low-risk-gains/#:~:text=In%20its%20simplest%20form%2C%20crypto,involves%20little%20or%20no%20risks[arbitrage traders]
add USDT to the pool and remove ETH from it to take advantage of small
price differences across two different markets. The pool reserves change
such that the initial amount of ETH that the liquidity provider added, gets
divided by 1.732 (the square root of 3), and the USDT amount gets multiplied
by 1.732. That means that now every ETH in the pool is backed by 3,000 USDT.
If the liquidity provider now wants to withdraw his funds, he gets around
0.5774 ETH and 1,732 USDT, which at the current market price
of ETH adds up to around 3,464 USD. But if the trader had held on to the
initial funds of one ETH and 1,000 USDT, he would now have 4,000 USD,
meaning, his impermanent loss was around 536 USD. The reason it pays
off to be a DEX liquidity provider is that they get a percentage of
the trading fees. Arbitrage and normal traders that both use the pool
pay for every transaction they make. The percentage of trading fees that
liquidity providers(((liquidity provider))) get can be larger than the
amount of impermanent loss. This
https://iohk.io/en/blog/posts/2022/05/27/everything-you-always-wanted-to-know-about-impermanent-loss-and-were-afraid-to-ask/[IO
blog] states that the EUTXO accounting model is a suitable
environment for DEXs using the order book model(((model, order book))).
An order book model
simply lists the buy/sell orders, and if there is supply and demand, the
asset can be traded. An advantage of this design is concentrated
liquidity (liquidity allocated within a custom price range). This
minimizes the effects of impermanent loss, creating a more stable
environment for liquidity providers.
The blog explains in more detail how impermanent loss affects DEXs
built on the account-based accounting models compared to EUTXO.

Cardano's design also makes front-running invasion
attacks(((attack, front-running invasion))) that could
target transactions on a decentralized exchange harder to
carry out. The Cardano node is designed such that it processes transactions in the
same order as they arrive into the mempool independent of the transaction
fees associated with them. This is not the case for all blockchains where
a node might favor transactions that carry higher fees. It is still
possible for an adversary that operates a stake pool to inspect transactions
that arrive in the mempool(((mempool))) since they are not encrypted.
They could then create their own
transaction with similar parameters and insert it in front of the transaction
that was received in the pool. In reality, this is hard to achieve because
Cardano's mainnet has a high number of block producing nodes (around 3000
at the time of writing) and also because of Cardano's design, none of these
nodes controls a significant amount of staked ada. You can read more about
this topic in chapter
<<stake-pools-and-stake-pool-operation, Stake pools and stake pool operation>>.
We also note that for transactions that interact with the same validator and spend
different UTXOs, rearranging them is inconsequential because there is no
global state that would affect both of the transactions. You can read more
about the mempool and front-running invasion attacks on Cardano in the following
https://cexplorer.io/article/understanding-the-cardano-mem-pool[Cexplorer blog].

Since Cardano transactions are deterministic, their interaction with
smart contracts is also deterministic, meaning the outcome of the validation
logic is predictable. In Ethereum, a smart contract function could, in
the short term, give up control of a transaction when it calls another
contract. This other contract could then make recursive withdrawal calls
to the first contract and drain its funds before the first contract
updates its state. This is known as a reentrancy attack(((attack, reentrancy))). The following
https://www.geeksforgeeks.org/reentrancy-attack-in-smart-contracts/[geeksforgeeks post]
provides more information on such types of attacks and also lists
examples of such attacks. Because such attacks are possible in Ethereum,
the interaction of transactions with smart contracts is sometimes hard to
predict. A reentrancy attack happened to the
https://en.wikipedia.org/wiki/The_DAO[DAO smart contract] that was
https://www.coindesk.com/learn/understanding-the-dao-attack/[hacked in
2016]. On that occasion, 3.6m ETH (worth around 50 million USD at the time)
was affected. Such attacks are not possible in Cardano due to the design
of the EUTXO accounting model. EUTXO's determinism(((determinism))) doesn't allow the
outputs to be different from what the user signed. Even if a validator
is dependent on the decision of another validator, that is predetermined
and known in advance before submitting a transaction. Such a case is
possible for instance if we want to make sure that a transaction runs
a minting policy in tandem with a spending script. We can check in the
spending script that tokens from that policy are being minted. And in
the minting policy, we can check that a UTXO from that spending address
is being consumed in the transaction. Those validators are not _calling_
each other, but we know they have to be both triggered by a single
transaction, since we enforce this condition inside those validators.
When we build a transaction, we have to specify all the validators that
run and all their inputs and outputs, so there's no way that an untrusted
validator can take over that transaction, since it's not part of it.

The EUTXO model also treats its tokens as native, meaning they are
treated the same way as ada. For this reason, they get the same security
and transfer logic as ada does. Some other blockchains use smart
contracts to manage tokens and to set the allowed transaction logic,
as Ethereum does with https://en.wikipedia.org/wiki/Ethereum#ERC20[ERC-20 tokens].
Buying or selling these tokens requires interaction with a smart contract, which
incurs higher transaction costs. Such tokens also carry a higher risk
because the security of the token is based on the smart contract's
correctness and security.
This https://www.emurgo.io/press-news/why-crypto-projects-built-on-cardano-are-more-secure/[Emurgo
blog] states that blockchains that use smart contracts to
manage native tokens can sometimes require smart contracts to have a
hierarchy of permissions, as in a DEX, for example. If in such a DEX,
the web of authority delegations has a complex structure, design
mistakes can happen. This can cause an attacker to be able to exploit
the system, potentially resulting in a user who wants to swap his tokens
to lose their funds. So, a user who wants to use such a DEX must be sure
that all the contracts are safe. Another security advantage of native
tokens is that over- and under-flow vulnerabilities are not present,
as Cardano's scripting language does not have fixed-size integers and
the ledger itself tracks the movement of tokens. The table below summarizes
some of the security features of Cardano native tokens.

[cols="40,60", options="header"]
|===
|Cardano native tokens
|Comment

|No user errors in copying standard code
|All shared functionality is provided by the ledger

|No over-/under-flow vulnerabilities
|Cardano's scripting languages don't have fixed-size integers

|No unprotected functions
|An untrusted validator can not take control over the transaction
|===

As in the <<chapter8-minting-policies-and-native-tokens,
Minting policies and native tokens>> section we again state
that further information on Cardano native tokens can be found at:

* https://docs.cardano.org/developer-resources/native-tokens[Official Cardano docs]
* https://developers.cardano.org/docs/native-tokens/[Cardano developers docs]
* https://cardano-ledger.readthedocs.io/en/latest/explanations/[Cardano ledger docs]
* The https://iohk.io/en/research/library/papers/native-custom-tokens-in-the-extended-utxo-model/[Native
Custom Tokens in the Extended UTXO Model] scientific paper.

Cardano also enables smooth upgrades to its protocol using a hard fork
combinator (HFC). Hard forks introduce radical changes to the blockchain
protocol. They might cause downtime, a chain restart, or compatibility
loss. In Cardano, the HFC is designed to enable the combination of
several protocols without having to make significant adjustments. It
allows Cardano nodes to run multiple protocol versions and enables
smooth transitions during hard forks. If a hard fork upgrades the Plutus
language to a new major version, smart contracts using an older version
of Plutus can still be processed. You can read more about the HFC in
<<cardano-node-layers, Cardano node layers>> section, subsection
_Consensus and storage layer_.

Cardano smart contracts see a predictable number of inputs and can only
produce a set number of outputs that are always the same given the same
inputs. Because of that, they are also perfect for audits. The job of a
smart contract auditor(((smart contract, auditor)))
is also more straightforward because outcomes
that cannot be foreseen are minimized by the design of the EUTXO model.
A smart contract auditor only needs to follow the logic of the validator
to assess if all possible outcomes are desirable and does not need to be concerned
with a global state that might influence the final output. Besides
auditing smart contracts, off-chain code and other parts of a DApp may
also be audited to assess the security of the entire application.

Further learning resources about the EUTXO(((EUTXO))) model in addition to section
<<chapter4-the-eutxo-model, The EUTXO model>> can be found at:

* https://ucarecdn.com/6d3813f2-6886-4c61-833f-e78ba5f887d7/EUTXOhandbook_for_EC.pdf[The EUTXO Handbook]
* https://iohk.io/en/research/library/papers/the-extended-utxo-model/[The Extended UTXO Model] scientific paper
* https://docs.cardano.org/about-cardano/learn/eutxo-explainer[EUTXO explained on Cardano Docs]
* https://www.essentialcardano.io/infographic/eutxo-v-account-based-models[EUTXO vs account-based models infographic]
* https://iohk.io/en/blog/posts/2025/01/08/six-reasons-why-eutxo-wins/[Six reasons why EUTXO wins] blog.

In this section, we presented some of Cardano's security features. The
security features of the Plutus and Marlowe smart contract languages are
further discussed in the remaining sections of the 
<<chapter8-smart-contract-security, Smart contract security>> section.

[[chapter8-plutus-security]]
==== Plutus security

Cardano offers Plinth(((Plinth))), previously called PlutusTx, which is a
Turing-complete(((Turing-complete)))
smart contract language realized on top of Haskell(((Haskell))), a high-assurance,
pure functional programming language(((language, purely functional)))
with a strong type system. You can
read more about the characteristics and advantages of the Haskell
programming language in section 
<<chapter1-features-and-benefits-of-haskell, Features and benefits of Haskell>>.
The Glasgow Haskell Compiler (GHC), which is the most well-established Haskell
compiler(((compiler))), is used to compile Plinth code. On-chain code is compiled into
Untyped Plutus Core(((Plutus core))) (known simply as Plutus), which is the scripting
language used by Cardano to implement the EUTXO model. Cardano nodes execute
the compiled Plutus scripts during transaction validation with the help
of the Plutus virtual machine (VM). A VM(((VM))) is a virtual environment that
executes code securely inside a node, when talking in context of a blockchain.
When a Cardano node executes validator code compiled to Untyped Plutus
Core, this code does not access the computer's resources directly as a
normal computer program would. For security reasons,
VMs offer a safe execution environment. Every Cardano node has a
built-in Plutus virtual machine that is written in Haskell. There
is also a plan to develop a Cardano node written in the Rust language.
The project is managed by the https://pragma.io/[Pragma] member-based
organisation (MBO) and is called https://github.com/pragma-org/amaru[Amaru].

Plutus is a simple, functional language similar to Haskell, and a large
subset of Haskell can be used to write Plutus scripts. Its simple and
deterministic design allows careful cost control of program execution.
Plutus is also a variant of
https://en.wikipedia.org/wiki/Lambda_calculus[lambda calculus],
specifically, https://en.wikipedia.org/wiki/System_F[System F]. Lambda
calculus is a formal system in mathematical logic for expressing
computation based on function abstraction. GHC's internal language (GHC
Core) is also based on System F(((System F))), but it does differ from Plutus in some
ways. The Plutus language was designed with the following requirements in mind:

* minimalism
* safety
* formalization
* size
* extensibility
* multiple source languages.

You can read a short explanation of each of the above requirements in the
https://plutus.cardano.intersectmbo.org/resources/plutus-report.pdf[Plutus
Platform] technical report, and you can read more about the design
details of the Plutus language in its
https://plutus.cardano.intersectmbo.org/resources/plutus-core-spec.pdf[formal
specification] document. The https://github.com/IntersectMBO/plutus[Plutus]
GitHub page features links to related materials.

Plutus scripts can be generated using Plinth, a GHC plug-in that runs
during the GHC compilation process. It modifies the program that GHC is
compiling however it likes. Under the hood, though, the compilation
process is more complex. The image below shows the compilation process
of the on-chain validation code.

image::sc_plutus_compilation.png[width=667,height=100,title="Plutus compilation pipeline"]

We start with Plinth, a subset of Haskell representing the high-level
language developers use to code the smart contract. Compiling this code
goes through several steps:

* First, it transforms into the GHC core(((GHC core))), part of the GHC compilation
pipeline.
* Second, it gets compiled into the Plutus Intermediate Representation(((PIR)))
(PIR). From now on, it will be independent of GHC and Haskell and have
total control of the compilation pipeline.
* Third, it transforms it into Plutus Core(((Plutus core))) (Plutus). This is an
intermediate form that the compiler(((compiler))) uses to statically check the
program.
* Fourth, we get to Untyped Plutus Core, which the Cardano node
runs to validate the transaction. This language is hard to code directly, and it
is usually stored in binary representation.

It is wise to break down compilation pipelines by introducing intermediate
languages to ensure no step is too large, and to test each step independently.
For more information about the compilation process, refer to this
https://iohk.io/en/blog/posts/2021/02/02/plutus-tx-compiling-haskell-into-plutus-core/[IO
blog].

You can also use a different high-level language if you have a compiler
that compiles to Untyped Plutus Core. Some projects are doing this by
replacing parts -- or all -- of the compilation pipeline. Validators can be
coded in pre-existing languages like Typescript
(https://github.com/HarmonicLabs/plu-ts[Plu-ts]) and Python
(https://opshin.dev/[OpShin]), or they can be coded in new
languages like https://aiken-lang.org/[Aiken]. A comparison of Aiken, which
is the most used smart contract language in the Cardano ecosystem as of 2023,
and Plinth is presented in section 
<<chapter8-plinth-in-comparison-to-aiken, Plinth in comparison to Aiken>>.

Haskell was also chosen as a programming language to implement the
Cardano node -- which contains the ledger, consensus and network layer(((network layer)))
protocols that define Cardano. You can read more about these protocols
in chapter <<how-cardano-works, How Cardano works>>.
The choice of Haskell enabled the research and engineering teams that
work on Cardano to reuse the existing Haskell infrastructure, libraries,
and tools that enable developers to build high-assurance software. To
assess the security of the Plutus language, formal methods were used
which are the most stringent form of reasoning about code correctness.
Formal methods(((formal methods))) are mathematically rigorous techniques for
the https://en.wikipedia.org/wiki/Formal_specification[specification],
development, https://en.wikipedia.org/wiki/Program_analysis[analysis],
and https://en.wikipedia.org/wiki/Formal_verification[verification] of
software and hardware systems. They are not well suited for any
arbitrary programming language but work well with pure functional
programming languages such as Haskell. With formal methods, one can
mathematically prove that the software under evaluation is correct and
does exactly what it is supposed to do.

In the process of formalizing Plutus, first starting with the paper
specification of the language, the semantics of the language were
formalized, and then the properties of the language were proven to
indicate that the design of the language was correct. Semantics are
given first by describing the reduction semantics of the language with
https://en.wikipedia.org/wiki/Operational_semantics#Structural_operational_semantics[Structural
Operational Semantics] (SOS). Then, the semantics on an abstract
machine (the https://en.wikipedia.org/wiki/CEK_Machine[CEK machine])
are given and shown as equivalent to the SOS. Other properties are also
shown. For example, the soundness and correctness of the typing system.
From this formal specification, an executable is produced by compiling
the specification into Haskell. This executable is a
_reference implementation(((reference implementation)))_
that behaves correctly (by definition), but it's not
efficient enough to be used in production. Then, real (efficient)
implementations can compare their results against those of the reference
implementation. This is done by automated testing in the conformance
test suite. The production code is tested against the reference
implementation. The https://github.com/IntersectMBO/plutus[Plutus]
repository contains the formalization of Plutus in Agda. The project is
located in the _plutus-metatheory_ folder. You can read more about
formal methods and functional programming(((programming, functional))) in section
<<FormalMethodsAndTheImportanceOfProgramCorrectness,
Formal methods and the importance of program correctness for cryptocurrency ledgers>>.

Besides formal methods, property-based testing is also used to deliver
high-assurance software for Cardano. For Haskell code, property-based
tests can be written using Haskell libraries such as
https://hackage.haskell.org/package/QuickCheck[QuickCheck] or
https://hackage.haskell.org/package/hedgehog[Hedgehog], which allow
developers to state properties that should always be in a program. Those
libraries use sophisticated algorithms to generate test cases and search
for minimal counterexamples that violate those properties. This
https://iohk.io/en/blog/posts/2020/04/09/merging-formal-methods-and-agile-to-build-cardano/[IO blog]
further explains that for code interacting with the external
world, particularly network applications such as the Cardano node, it
can be hard to find minimal counterexamples. This is attributed to the
fact that the execution order is not deterministic because it can change
every time the software runs. In other words, the same code can be run
hundreds of times and only fail once. The blog explains that a way
to get around this is by using simulations with deterministic execution
order. Running tests in such a simulation allows developers to reliably find and
fix a class of bugs in testing that would otherwise only occur
randomly in production.

Formal verification(((formal verification))) and property-based testing can also be used to
secure the development of smart contracts. While Haskell is a great
programming language for implementing reliable software, it cannot
catch all possible mistakes a programmer can make, so the code still
needs to be tested. One can write property-based tests for PlutusV3
Plinth smart contracts by combining the following tools:

* https://atlas-app.io/[Atlas] a Plutus application backend developed by
GeniusYield(((GeniusYield)))
* https://mlabs-haskell.github.io/clb-docs[Cardano ledger backend] (CLB) library
developed by MLabs(((MLabs)))
* https://hackage.haskell.org/package/QuickCheck[QuickCheck] Haskell library.

This https://www.mlabs.city/blog/testing-dapps-on-cardano-with-clb-emulator[MLabs
blog] shows how to use Atlas(((Atlas))) with the CLB to test Plinth scripts.
The Atlas application backend is an open-source tool that covers all
functionalities needed to work with
Plinth smart contracts and enables writing the complete server-side code
in Haskell. It is the Haskell alternative to TypeScript off-chain tools such
as MeshJS and Evolution-SDK(((Evolution-SDK))). It was developed by the company
https://www.geniusyield.co/[GeniusYield] in collaboration with other
companies such as MLabs, Well-Typed(((Well-Typed))), and Plank. It significantly
abstracts away the complexity of building Cardano transactions and
interacting with Plinth smart contracts. Different data providers can be
configured to power the Atlas framework. It streamlines the process of
building transactions and executing smart contracts. One can read more
about the benefits that the Atlas application backend provides at their
https://atlas-app.io/introduction#features[documentation page].
Another tool one can use for testing Plinth smart contracts or any other
smart contract language that compiles to Untyped Plutus Core(((Plutus core))) is the
https://github.com/tweag/cooked-validators[Cooked validators] library
developed by Tweag(((Tweag))). Aiken, a standalone smart contract language,
comes with its own built-in toolkit for testing. You can read more
about it at the https://aiken-lang.org/language-tour/tests[Aiken documentation].

For testing smart contracts, third-party auditing companies can write
the tests as part of their auditing process of DApp smart contracts and
server-side code. Their auditing services may also include formal
verification. For Cardano DApps, companies such as Tweag,
MLabs, Runtime Verification, Hachi, Vacuumlabs, FYEO Inc.,
Anastasia Labs, TxPipe, and
some others, offer Cardano auditing services. IO is also working with
some of these companies on a certification program for DApps running on
Cardano. The program creates three levels of certification for DApps in
a store.

* Level 1: automated tooling
* Level 2: in-depth audit
* Level 3: formal verification.

The below descriptions were originally included in this
https://iohk.io/en/blog/posts/2021/10/25/new-certification-levels-for-smart-contracts-on-cardano/[IO
blog]:

* _Automated tooling_ will give continual assurance about a range of
properties for smart contracts. It covers the discovery of different
types of issues or bugs and is characterized as low cost, low effort,
and accessible to everyone while providing a substantial level of
assurance. It can be applied repeatedly and automatically, so each time
there is a release or a sub-release of an application, the application
can be tested to confirm it still has the properties that we expect.
* _In-depth audit_ looks at the technology and processes that led to it
being produced. It involves a manual audit and verification of smart
contracts within the DApp itself. The testing is performed at a much
deeper level and involves more manual effort than can address a DApp in
its entirety, even if it is written in a variety of languages.
* _Formal verification_ is more specialized,
where the auditor aims to provide full assurance of critical aspects of applications through
formal verification of smart contracts. Formal verification(((formal verification))) involves
ensuring that a smart contract serves the specific business or technical
requirements defined at the outset.

When using formal verification for smart contracts, the general
procedure is to first define the model that serves as an exact
representation of the smart contract behavior. Then, the smart
contract's specifications are defined in a language that both the model
and the verification tools can comprehend. After that, the process of
verification can start, where mathematical tools and logic are used to
prove the correctness of the defined assumptions. In the end, the results
of the verification process are analyzed, and issues are addressed.

IO is also developing a new formal verification tool for Cardano smart
contracts. Proof assistants such as Agda and Rocq (previously Coq), offer
strong guarantees, but require experienced developers to use. This new tool
combines the power of the Lean4 proof system and SMT solvers, such as Z3,
to automatically check that contracts behave as intended. The goal is to
eliminate the need for developers to write any formal proofs themselves.
It will work by simply clicking a button and the targeted smart contract
will be formally verified. This tool can be integrated directly into the
CI/CD pipeline and contracts can be formally verified on every commit –
instantly, continuously, and affordably. The tool still remains under
development at the time of writing. One can read more about the tool in this
https://iohk.io/en/blog/posts/2025/07/17/a-new-era-of-smart-contract-verification-on-cardano/[IO blog].

In case a company decides to pursue an audit, no matter the audit type, the company
requesting it has to provide a standard set of documents and information:

* General specification and design documents that unambiguously describe
the architecture, interfaces, and requirements characterizing the DApp.
* On-chain specification that clearly specifies the smart contract
properties.
* Off-chain specification that describes the expected behavior
(assumptions, constraints, and requirements) for all interfacing
components of the DApp.
* A description of how the DApp has been tested, together with the
results of the tests, and details of how those test results can be
replicated.
* A final version of the source code together with versioning
information.

You can read further details of the above points in
https://cips.cardano.org/cip/CIP-52[CIP-0052],
which defines guidelines and best practices for auditing DApps built on
Cardano. Furthermore, https://cips.cardano.org/cip/CIP-57[CIP-0057]
defines a language specification or so-called blueprint for documenting Plutus contracts
through the form of a JSON schema that sets the vocabulary and
validation rules to specify the Plutus contract interface. This enables
a better understanding of Plutus smart contracts written in any of the
high-level languages that compile to Plutus. It allows for the
development of tools that generate contract API references and
documentation. DApp developers also make their contracts easier to audit
as they can specify the expected behavior, and the auditing information
is provided in a more standardized way.

Different companies may use different approaches to perform smart
contract audits. Sometimes, auditing companies publicly disclose their
methodology. This
https://www.tweag.io/blog/2023-05-11-audit-smart-contract/[Tweag
blog] presents the auditing process in their company. Beside
auditing smart contracts, other parts of a DApp can be audited as
the off-chain code. After the audit process, the vulnerabilities
are usually identified and grouped into categories:

* _Critical vulnerabilities_ that pose a big risk for the DApp
* _High vulnerabilities_ that may affect a large portion of the DApp's
security
* _Medium vulnerabilities_ are issues that affect the proper working
of a DApp but are not security threats that would need immediate action
* _Low vulnerabilities_ that may affect things such as performance
but pose no risk to security.

We state at the end of this section that good practice in writing Plutus
smart contracts is to avoid common security vulnerabilities which are:

* other redeemer
* other token name
* arbitrary datum
* unbounded datum
* unbounded value
* unbounded inputs
* multiple satisfaction
* missing UTXO authentication
* UTXO contention(((UTXO, contention)))
* cheap spam
* insufficient staking key control.

This https://library.mlabs.city/common-plutus-security-vulnerabilities[MLabs
guide] describes each vulnerability by a property statement, test, impact,
and provides an explanation of it. Audit reports are often made publicly
available for the community to read because they are a great tool for
learning what mistakes not to make when developing a DApp. Below are links
to repositories from the auditing companies Tweag(((Tweag))) and Vacuumlabs that
made some of their audit reports freely available to the public:

* https://github.com/tweag/tweag-audit-reports[Tweag audit reports]
* https://github.com/vacuumlabs/audits[Vacuum Labs audit reports].

Other auditing companies that might not have their auditing reports grouped
into a single repository, are also worth exploring.

[[chapter8-marlowe-best-practices-and-security]]
==== Marlowe security and best practices

[[chapter8-marlowe-security]]
===== Marlowe security

In the design process of the Marlowe(((Marlowe))) smart contract language, trade-offs
were made in regard to how powerful the language should be. In computer
science, the https://en.wikipedia.org/wiki/Halting_problem[Halting
problem] states that it is impossible to write a program that takes as
input another program written in a Turing-complete(((Turing-complete))) programming language,
and decides whether that program will stop or not. Such programming
languages are so powerful that it is difficult or impossible to
automatically analyze programs written in them. You always have to write
tests or use other methods, such as formal verification, to check certain
properties of such programs. In practice, for a large class of programs,
it may be possible to have automated tools, but there can be no general
tools that decide whether the program stops or not. This is only one
example of undecidability. More often, the security properties of the
program need to be checked and it must be proven that the program behaves as
expected. On the other hand, if you are willing to give up
Turing-completeness, you can have simple but powerful program analysis
tools and program language built-in security features. Powerful analysis
tools also exist for Turing-complete programs; they are just more
complex to build, and such programs have fewer built-in security features.

Marlowe is not a Turing-complete language, so you cannot express
arbitrary logic in it. This gives the option to statically analyze how
long a contract will run. All Marlowe contracts are guaranteed to have a
finite lifetime. There are other things Marlowe contracts take care of,
such as ensuring that no funds are forever locked in a contract. In
Cardano's implementation of Marlowe, there is an edge case where it is
possible to lock funds by creating a contract that exceeds the
limitations of the blockchain, for example, by making too many external
payments in the same transaction. The chapter _Tools for Detecting
Potential Locking/Blocking of Marlowe_ in the
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe/best-practices.md#tools-for-detecting-potential-lockingblocking-of-marlowe-on-cardano[Marlowe
best practices] page explains how to prevent such a scenario. In the
real world, you can enforce contracts by using the legal system or
financial regulations. However, due to the decentralized nature of the
blockchain, this may not be possible. When you use Marlowe to create a
smart contract, you can't force anyone to make a payment that fulfills a
contract. Marlowe considers that and implements a finite lifetime
mechanism to wait for someone to make a payment. If the contract is
waiting for an action, like a payment, and that action does not happen,
the finite lifetime mechanism enables a timeout mechanism that always
says what action can happen when the timeout is reached. Marlowe
provides the following safety guarantees:

* Execution always terminates
* Contracts expire eventually and deterministically
* No assets retained when the contract reaches its final state
* Conservation of value.

The safety-first principle used in Marlowe's design has limited its
functionality for a good reason. There are two additional limitations
considered when a Marlowe contract is created:

{empty}(1) the number of participants in a contract is limited to the
predetermined amount when the contract was designed;

{empty}(2) existing Marlowe contract logic cannot be revised. To ensure
the above-mentioned safety guarantees, the following programming
language constructs are absent from the Marlowe language to ensure
Marlowe's safety:

* Recursion is not allowed.
* Looping is not supported.
* Functions or macros may not be defined.
* Timeouts must be numeric constants.
* Only `Case` continuations may be Merkleized. The Faustus(((Faustus))) programming
language relaxes some of the limitations above, yet it compiles to safe
Marlowe. Besides, you can 'relax' the above limitations if you
embed Marlowe into another language (JavaScript, for example). By using
the TS-SDK, you can have JavaScript functions and loops that unfold a
larger Marlowe contract.

Merkleization is the process of constructing
https://en.wikipedia.org/wiki/Merkle_tree[Merkle trees] that can be
used to verify any kind of data stored, handled, and transferred in and
between computers. It enables large smart contracts to be concisely
represented on-chain. Instead of storing gigabytes of data representing
a huge contract, only the hash of that contract needs to be represented
on-chain. You can learn more about Merkleization in Marlowe in
https://www.youtube.com/watch?v=e6vdq5GN5Q8[this video] from IO Academy.
Merkleization is hidden through the Marlowe object concept, and you can
read about the marlowe-object package in its frontend
https://github.com/marlowe-lang/marlowe-ts-sdk/tree/main/packages/marlowe-object[documentation]. The
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe-object/doc/object-format.md[Marlowe
Object Format] is a way to describe a Marlowe contract as a set of
labeled objects that reference one another, which can be linked to
create a Marlowe contract. The term comes from the object files produced
by a compiler(((compiler))), which can be linked to create an executable program.

Marlowe also contains additional constraints imposed by Cardano:

[arabic]
. No more than one Marlowe contract may be run in a single Marlowe
transaction
. Token names are limited to 32 bytes
. An invalid initial state will prevent a Marlowe contract from
executing properly on Cardano. Some of the smart contract execution
paths may be blocked
. Each transaction output on the Cardano ledger must include a minimum
lovelace value in the UTXO
. Because the Cardano ledger contains a rule that the size (in words) of
the bytes storing the information about native tokens in a UTXO cannot
exceed the protocol parameter maxValueSize, there is a limit to the
number of different types of tokens that can be held in a single UTXO
. The size (in bytes) of a transaction is limited by a Cardano ledger
rule specified by the protocol parameter maxTxSize
. If a Marlowe contract does too much computation or uses too much
memory in a transaction, it may violate the rule that execution costs in
Plutus are limited to specific usage of 'memory' and CPU 'steps'.

You can look up the Marlowe
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe/best-practices.md[best
practices guide] to read more about these limitations. While
Marlowe contracts might run on the Playground, they would not run
on-chain if the contract violates the
https://cardano-ledger.readthedocs.io/en/latest/[Cardano ledger
restrictions]. You can check a Marlowe contract for compatibility with
the Cardano ledger rules by using the _marlowe-cli run analyze_ command.
The Marlowe CLI(((Marlowe, CLI)))
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe-cli/ReadMe.md[GitHub
page] provides additional information about this topic.

The following properties regarding the safety of Marlowe were proven
using formal methods:

* Conservation of funds
* Contracts always terminate
* Positivity of account balances
* Quiescence
* Idempotency of reductions
* Composition of inputs.

The formal specification and proofs for the Marlowe language were made
using the Isabelle proof assistant(((proof assistant, Isabelle))),
which can be used for formal verification of software.
The proofs were audited and can be found in the
https://github.com/marlowe-lang/marlowe[Marlowe GitHub repository].
This repository also contains the
https://github.com/marlowe-lang/marlowe/tree/master/marlowe-spec-test[marlowe-spec]
software tool, with which a Marlowe interpreter written in any smart
contract language can be validated for compliance with the Marlowe
formal specifications. The specifications can be found in the
marlowe-cardano
https://github.com/marlowe-lang/marlowe-cardano/tree/main/marlowe/specification[GitHub repository]
that contains the official Cardano implementation of
Marlowe. The Marlowe interpreter and the role-payout validator are
implemented as Plinth scripts and can be found in the
marlowe-plutus https://github.com/marlowe-lang/marlowe-plutus[GitHub
repository], which also provides instructions on how to compile the
scripts.

The auditing company Tweag(((Tweag))) performed an audit of the Marlowe high-level
language and the implementation of Marlowe on Cardano before Marlowe's
deployment on mainnet. The audit discovered significant issues,
including handling of negative deposits, prevention of 'double
satisfaction', enforcement of state invariants, an implementation
difference between formal specification versus the Plinth
implementation, and the proof of money preservation theorem. The issues
were addressed before deploying Marlowe on mainnet. The full
https://github.com/tweag/tweag-audit-reports/blob/main/Marlowe-2023-03.pdf[audit
report] can be found at Tweag's GitHub page. IO also issued a report on the
https://github.com/marlowe-lang/marlowe/blob/master/response-to-audit-report.md[Marlowe
GitHub page] explaining the actions taken. You can read a short
description of the issues and how they were addressed in this
https://iohk.io/en/blog/posts/2023/06/27/a-comprehensive-guide-to-marlowes-security-audit-outcomes-built-in-functional-restrictions-and-ledger-security-features/[IO
blog], which also talks about the security of Marlowe and Cardano.

[[chapter8-marlowe-best-practices]]
===== Marlowe best practices

Marlowe contracts can be designed in many ways. Once you have designed
your contract, it is good practice to simulate it on the Playground
first and create a walkthrough of all possible execution paths. The
Playground also offers a set of tools that can perform a static analysis(((static analysis)))
of the contract. No matter the Playground programming language you
choose, the tools can be accessed from the bottom bar in the Static
Analysis tab. Once you click on it, the analysis console opens up,
displaying a section on the right-hand side where you can set the
contract input parameters. Then, you can make three possible analyses:

* Analyze for warnings
* Analyze reachability
* Analyze for refunds on Close.

The analysis for warnings action analyzes the contract for potential
mistakes a smart contract designer could make. An example of a warning
would be that a contract would try to pay an amount of ada to a party
that exceeds the total amount of ada that the contract is holding at the
time of the payment action. The analysis will produce a description of
the warning, and it will display an _offending sequence_ that shows the
contract actions leading to the warning. The reachability analysis
action analyzes if any unreachable subcontracts exist. In other words,
it checks if an execution path of the smart contract exists that cannot
be reached with any possible transaction. The analysis for refunds on
Close action analyzes if any of the Close constructs refund any money.
That means it checks if all refunds are explicitly stated in the
contract or if some happened because funds remain in the contract when
it reaches the end of any possible execution path. Even if funds remain,
this does not represent an issue since its owners can redeem the funds
because no funds are locked by the contract indefinitely.

Besides being a smart contract programming language, Marlowe is also an
ecosystem of tools to enable the deployment, interaction, and analysis
of Marlowe smart contracts. Formal proofs, extensive testing, and
analysis tools provide strong assurances for the safety of Marlowe
contracts. Marlowe Runtime(((Marlowe, runtime))), which is used under the hood by the TS-SDK,
provides off-chain services that discover Marlowe's contract history and
build transactions that apply input to Marlowe's contracts. If a project
using the TS-SDK decides to deploy its own instance of Marlowe Runtime(((Marlowe, runtime))),
precautions should be taken if there is an interest in examining the
Marlowe transactions produced by the Runtime. If Marlowe Runtime is
deployed as part of a web service, then one must be aware of the
possibility of person-in-the-middle, cross-site scripting, and other
attacks. Marlowe Runtime contains a registry of known Marlowe script
versions that it uses to create new Marlowe transactions. One should
only use Marlowe Runtime to create contracts if one trusts the script
hashes in that registry. The Marlowe test suite verifies that the script
registry has not been inadvertently or maliciously altered. Of course,
this does not guarantee that the test itself has not been altered.

Another Marlowe tool is the Marlowe CLI(((Marlowe, CLI))), which includes
capabilities for analyzing the suitability of a Marlowe contract for
execution on Cardano. As mentioned in the previous section, the
_marlowe-cli run analyze_ command enables a smart contract designer to
check that his contract does not violate any of the
https://cardano-ledger.readthedocs.io/en/latest/[Cardano ledger
restrictions]. Its command line interface allows the user to select
which checks to perform, and its output highlights the causes and
location of violations. It is important to realize that the tool tests
whether or not it is _possible_ to avoid violating the ledger rules in
executing a contract. This does not mean that it is _trivial_ to
construct every valid transaction for the contract. Further details can
also be found in the
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe/best-practices.md[Marlowe
best practices guide], which explains how to avoid protocol limits when
designing Marlowe contracts in the following cases:

[arabic, start=1]
. Choose role and token names that are no longer than 32 bytes
. Ensure that the contract's initial state is valid
. Ensure that the initial value in the contract contains sufficient lovelace
. Avoid contracts that use an excessive number of native token types
. Avoid or break up complex logic in the contract
. Use reference scripts and merkleization to reduce on-chain size
. Be parsimonious in the use of the contract's internal state.

Look up the
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe/debugging-cookbook.md[Marlowe
debugging cookbook] for technical approaches on how to debug Marlowe
contracts on Cardano. Some types of contracts are not well suited for
using Marlowe on Cardano, including:

* Contracts that contain timeouts spaced close to the Cardano block
production rate
* Contracts that require floating point arithmetic
* Contracts that require many bound values in their internal state
* Contracts that make many differently named choices by many parties
* Contracts that have many alternative and simultaneous actions
possible. For example, a distributed exchange (DEX), order book, market
maker, or token marketplace would be poorly suited for Marlowe unless
the Marlowe contracts were supervised by Plinth contracts or
semi-centralized off-chain infrastructure.

Also, security and best practices should be taken into account when
constructing transactions targeting a Marlowe contract. A user should be
able to answer the following questions before signing a Marlowe
transaction:

* Does the transaction operate a Marlowe contract?
* What is the current contract and what is its state?
* What input is being applied to the contract?
* What else is occurring in the transaction?

The
https://github.com/marlowe-lang/marlowe-cardano/blob/main/marlowe/security.md[Marlowe
security guide] answers all these questions in detail. In conclusion,
when developing a Marlowe smart contract, one should:

* Use the https://playground.marlowe-lang.org/#/[Marlowe Playground] to
simulate the contract and perform static analysis(((static analysis)))
* Use the _marlowe-cli run analyze_ tool to check if the contract can
run on the Cardano network and does not violate any of the Cardano
ledger rules
* Read and understand the Marlowe guides referenced in this section and
check if the Marlowe smart contract satisfies all criteria
* Test off-chain code by running all execution paths of the contract on
a Cardano testnet(((Cardano testnet))). You can read more about the
Cardano testnet(((Cardano testnet))) at
https://docs.cardano.org/cardano-testnet/overview[Cardano docs].
