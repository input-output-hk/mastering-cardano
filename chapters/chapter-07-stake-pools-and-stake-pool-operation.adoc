
:imagesdir: ../images

[[stake-pools-and-stake-pool-operation]]
== Stake pools and stake pool operation

[[spo-introduction]]
=== Introduction

The strength of the Cardano network lies in its widespread and diverse distribution of stake pools, stake pool operators (SPOs), delegators, builders, and community members at large. The ethos of this well-distributed network(((distributed network))) and broader ecosystem has found its way into the creation of this chapter.

As you read through this chapter, you may notice varying tones in different sections. This is not by accident. Since the Cardano(((Cardano))) network is supported by an exceptional global community, it felt appropriate for this chapter to feature contributions from some of the best community members in the Cardano ecosystem.

This chapter aims to deliver a thorough technical and conceptual overview of stake pool operations. For those new to Cardano, this chapter will give insight into what it takes to run and maintain a global, distributed network like Cardano.

It is recommended that prospective SPOs read through this chapter, understand the concepts, and then participate and practice operations on one or more of the publicly available testnets(((testnet))) until they gain sufficient expertise before spinning up on mainnet. Seasoned pool operators can use this guide as a refresher, address potential knowledge gaps, and, best of all, contribute where needed.

A list of tools and guides is provided <<spo-guides, here>> to assist with both learning how to operate stake pools and maintaining efficient long-term operations on mainnet(((mainnet))).

[[spo-what-is-a-stake-pool]]
=== What is a stake pool?

A Cardano stake pool is a collection of server-based infrastructure(((infrastructure, server-based))) that maintains and runs the Cardano blockchain by validating transactions and adding blocks. While a stake pool can run on a single node, it is more common for it to utilize a collection of nodes connected to the broader Cardano network – a distributed network of interconnected stake pools and full nodes. Typically, a stake pool includes a block-producing node and multiple relay nodes (relays).

To become an active block producer, a node requires the following cryptographic files:

* the __verified random function (VRF) signing key__ (vrf.skey)
* the __operational certificate__ (op.cert)
* the __key evolving signature (KES) signing key__ (kes.skey)

When a full node is not started with these files, it is referred to as a passive node, or when connected to a block producer, a __relay__. A relay sits between the open Cardano network and block producing node of a stake pool. Its purpose is to allow a block producing node to interact with the network securely as the block producing node should only be connected and known to the specific relays the stake pool operator (SPO) controls. This separation of concerns reduces the attack surface of a stake pool and allows the block producing node to focus on minting blocks and propagating these to a small set of well-known relays, which will in turn propagate the blocks to the wider network. Relays are typically publicly known as they are registered with the pool, so other relays can find them in a peer-to-peer manner. Relays may also be run privately with static topologies(((static topologies))) listing other relays.

Cardano uses a proof of stake (PoS) consensus mechanism(((consensus mechanism))). Network participants holding ada (Cardano’s native token) can delegate their stake to a stake pool, effectively pooling their resources and increasing the pool’s chances of being selected to validate a block and earn rewards.

Stake pools are run by SPOs, who are responsible for maintaining the pool’s infrastructure and ensuring that the pool operates reliably. The rewards earned by the pool are then distributed among the stakeholders who have delegated their ada to the pool, proportional to their stake.

In this way, Cardano’s consensus mechanism incentivizes a distributed network of participants to maintain the security and integrity of the network, rather than relying on a single entity to validate transactions.

==== Stake pool roles

In the Cardano blockchain network, several roles are essential to stake pool(((stake pool))) operation:

* _SPO_ — the individual or organization responsible for running and maintaining the stake pool infrastructure. The SPO determines and sets the pool’s operational parameters, such as the fee structure. While the protocol pays rewards directly, the SPO can influence the amount of rewards by adjusting fee parameters. However, they do not control the reward distribution itself.
* _Owner_ — the owner is defined by the contribution of pledge to the pool – a type of delegation specific to stake pools. This role can be conducted either by the SPO or a separate entity.
* _Delegator_ — a network participant holding ada and delegating their stake to a pool. By doing so, they participate in the validation of transactions and earn rewards.

These roles work together to ensure the reliable and secure operation of the Cardano network and its consensus mechanism(((consensus mechanism))).

==== Keys

Cardano cryptographic keys are made up of ed25519 key pairs(((ed25519, key pairs))), which include a public verification key file and a private key file. The public key filename is commonly formatted as `public.vkey`, whereas the private key filename is typically formatted as `private.skey`. The private key file, used to sign transactions, is highly sensitive and must  be properly protected. Under all circumstances, this entails limiting third-party access to your private keys. The most effective way to prevent private key exposure is to ensure that it is never stored on any internet-connected device for any length of time. Please note the key pair file names are examples and may be named differently.

==== Wallet keys

`root.skey` -  the most sensitive private key of any wallet. An attacker can use this key to derive the Cardano wallet payment.skey and stake.skey. In case of a hardware wallet(((hardware wallet))) malfunction, the wallet’s 12 or 24 word seed phrase can be converted to a root.skey. The payment and stake keys can be recovered by using the CLI and root.skey. A root.skey can thus not only be used to generate private keys for Cardano, but also for other blockchains such as Bitcoin.

`payment.skey` - a highly sensitive Cardano payment address(((address, payment))) private signing key file. This file provides access to tokens in the payment address and should be kept safe at all times.

`payment.vkey` - the public verification key(((verification, key))) file for the payment address. It is not sensitive and can be shared publicly.

`stake.skey` - a sensitive Cardano stake address private signing key file(((address, staking))). This file gives you access to any rewards held in the stake address, as well as the ability to delegate the wallet to a pool.

`stake.vkey` - stake address public verification key file, which is not sensitive and can be shared publicly.

==== VRF hot keys

VRF keys control participation in the slot leader selection process(((slot leader selection process))):

`vrf.skey` -  a private signing key file for a Cardano stake pool’s VRF key. This key is required to start a stake pool’s block producing node. It is sensitive but must be placed on a hot node to start a stake pool.

`vrf.vkey` - a public verification key(((verification, key))) file for a Cardano stake pool’s vrf.skey. It is not sensitive and is not required to start a stake pool’s block producing node.

==== KES hot keys

KES keys are operational node keys(((operational node keys))) that authenticate the rightful operator of a pool:

`kes.skey` -  a private signature key file(((private signature key file))) for the stake pool’s KES key. It is needed to start the stake pool’s block-producing node. This key is sensitive, however, it must be placed on a hot node to start a stake pool and be rotated regularly. KES keys are required to establish a stake pool’s operational certificate, which expires 90 days after the certificate’s defined KES period has passed. As a result, fresh KES keys must be generated along with a new certificate every 90 days or sooner for a Cardano stake pool to continue minting blocks.

`kes.vkey` - a public verification key file for the pool’s corresponding kes.skey. This key is not sensitive and is not required to start a block-producing node(((block-producing node))).

==== Stake pool keys and supporting files

Stake pool keys and some supporting files include:

`cold.skey` -  a private, offline signing key file for a Cardano stake pool, which is  very sensitive. The cold.skey is required to:

* register a stake pool
* update stake pool registration parameters
* rotate stake pool KES keys
* retire a stake pool

`cold.vkey` - a public verification key file for a stake pool’s cold.skey private signing key file. It is not sensitive and can be shared publicly.

`cold.counter` -  a counter file that tracks the number of times an operational certificate(((operational certificate))) has been generated for the relevant stake pool.

*_Note:_*  Always rotate KES keys using the latest cold.counter and increment by exactly 1.

`op.cert` -  an operational certificate that links the operator’s cold.skey and their operational kes.skey. The certificate checks whether the operational key is valid, preventing malicious interference. The certificate identifies the current operational key and is signed by the offline cold.skey. As the operational certificate is sensitive and required to start a stake pool’s block-producing node, it must be placed on a hot node to start a stake pool.

==== Addresses

Current Cardano wallet addresses are encoded in bech32 format and consist of two parts: a payment address and a staking address(((address, staking))). The payment address, along with its associated key pairs, is used to store, receive, and send funds. The staking address and its related keys manage staking-related activities, such as storing and withdrawing rewards, defining the stake pool owner, managing reward accounts, and setting the wallet’s target stake pool delegation.

An enterprise address(((address, enterprise))) is a specific type of Cardano wallet address without the ability to participate in staking. Enterprise addresses might be used by exchanges that wish to comply with regulations or in cases where staking is not desired.

`payment.addr` -  a payment address is usually generated using both a payment.vkey and a stake.vkey, associating the resulting address with both keys. Usually the payment.vkey and stake.vkey are derived from the same cryptographic entropy(((cryptographic, entropy))) or root.skey, which refers to the same original secret or seed phrase. The first payment address of any wallet is known as the base address. Cardano supports HD wallets, so any number of payment addresses can be derived from the same secret phrase.

`stake.addr` - a stake address for a Cardano wallet is generated using the stake.vkey file. It controls protocol participation, enables stake pool creation, and facilitates delegation and receiving rewards. This address cannot receive payments but is used to receive rewards from participating in the protocol. Only one stake address can be derived from a single original secret, thus all payment.addr(((payment.addr))) associated with the same secret share the same stake address component.

It is also possible to combine payment.vkey(((payment.vkey))) and stake.vkey from two different original secrets, creating what is known as a `mangled` or https://www.youtube.com/watch?v=KULzovfWn-M[`Franken Address`]. Sending tokens to such an address allows one wallet to spend them, while the other wallet can participate in the protocol and earn rewards using the same tokens.

==== Pool saturation

The protocol parameter `k` defines the saturation point(((saturation point))) for stake pool rewards. This saturation point is calculated by dividing `Cardano's total supply by k`. As of this writing, with k set at 500, the saturation point is approximately 70 million ada. A stake pool with total stake above this saturation point will receive more slots and should mint more blocks. However, rewards for the pool are capped at the saturation point. This results in diminishing returns as the same rewards pot is distributed among a larger total delegation. This incentivizes participants to avoid delegating to saturated pools.

Reaching saturation is a positive sign for a pool, as it indicates the pool’s popularity and substantial stake. However, it also means that delegators may have to look for alternative pools if they wish to delegate additional stake. The SPO of the saturated pool can also adjust parameters(((parameter))), such as increasing pool minting fees, to manage the saturation level.

The SPO can also open additional pools, leveraging the popularity of the first pool to attract stake to the new ones. This practice, known as pool-splitting or multi-pools, remains a contentious topic in the Cardano community. From a decentralization(((decentralization))) perspective, an SPO should refrain from pool splitting unless they can fully saturate the existing pool with pledge, effectively turning it into a private pool before opening a new public one. Distributed pool production increases the minimum attack vector (MAV) and protects against Sybil attacks (where a malicious actor creates multiple entities or accounts to gain control over block production).

==== Pledge vs stake

Pledge is a specific type of delegation registered on-chain as part of the pool registration process. This means that the pool’s owner/s permanently delegate a certain amount of ada to the pool, registering a pledge commitment. If the pool fails to meet the pledge commitment – meaning the amount pledged on-chain exceeds the total ada in the pool’s pledge wallets at the epoch transition snapshot(((epoch, transition snapshot))) – no rewards will be paid. To resolve this, the pool must either adjust the registration to lower the pledge so it becomes valid again or return the pledge to the designated owner addresses, fulfilling the original commitment.

To prevent Sybil attacks, Cardano uses a well-designed incentive model that encourages stake pool owners to associate as much pledge as possible with their pools. A higher pledge makes the stake pool more financially attractive to potential delegators. Staking rewards increase linearly with the amount of pledge, reaching maximum rewards when the pool is fully saturated.  Such a pool earns nearly 30% more rewards than a pool with no pledge. Saturated pools are often referred to as private stake pools(((private stake pool))), as the incentive to add delegation diminishes once the saturation threshold is met.

As there is no minimum pledge requirement, a stake pool(((stake pool))) can operate with zero pledge. However, having a pledge demonstrates the owner’s commitment, which can help build trust among delegators.  Declaring pledge can also carry potential risks, as this information is publicly available on-chain. The SPO could become a target for criminal activity attempting to steal the pledge. Additionally, regulatory requirements that mandate the disclosure of SPO identities in certain jurisdictions can pose further security risks.

Franken addresses(((Franken address))) could be useful in these scenarios. An SPO could declare the pledge while managing the pool without direct access to the payment key of the pledge. The SPO would only have access to their wallet with a payment key securing minimal funds for day-to-day operations sufficient to pay for pool maintenance fees. The main pledge is secured with another wallet’s payment key. The owner address would consist of one payment address from the pledge wallet and the staking address from the SPO wallet. As long as the pledge resides on this mangled address, the SPO can incorporate the stake as pledge without the risk of physical extortion, as they would have no access to the pledge payment key.

Regular stake refers to the standard stake that participants bring in through delegation(((delegation))). This stake is liquid allowing users to move it in and out of delegation at will. While pledge is not technically locked either, moving it out before pledge commitment changes become active will break the commitment, likely resulting in a loss of rewards.

==== Fee structure

The declared fees of a Cardano stake pool, determined by its operator, are critical for long-term sustainable operation. Fees typically cover costs such as:

* fixed server cost
* time spent on pool and server maintenance
* marketing expenses, regulatory compliance costs, including management and reporting duties

The fee structure determines how much of the rewards generated by the pool are retained by the operator and how much is distributed to delegators. If the pool does not mint blocks in an epoch, no rewards are generated and no fees are paid. Pool fees are always taken from the rewards, meaning they can diminish delegators' rewards. However, fees are never taken from delegators’ stake, as Cardano natively uses non-custodial, https://www.essentialcardano.io/glossary/liquid-staking[liquid staking].

Cardano stake pool operators set two types of fees:

* *Fixed fee* (minPoolCost): specified as a set amount in ada, this fee is intended to cover the fixed cost of pool operation. As of writing, the minimum mandatory fee is 170 ada per epoch.
* *Variable fee*: specified as a percentage, this fee can be deducted from the total staking rewards after the fixed fee is applied. Unlike the fixed fee, which remains constant as long as at least one block is minted in an epoch, the variable fee depends on the pool’s performance and the number of minted blocks relative to expected blocks. The more blocks minted, the higher the total rewards, the higher the variable fee payout for the operator. Typically, at the time of writing, the variable fee ranges from 0% to 5%.

*_Note:_* While a 5% variable fee may seem significant, it should always be assessed in relation to the expected return on staking (ROS). As of writing, the ROS is approximately 4% per year. A stake pool that sets a 5% variable fee will only reduce the annual ROS by 0.2 percentage points, resulting in a ROS of 3.8% per year.

[[spo-requirements]]
=== SPO requirements

As an open protocol, Cardano allows anyone to create and operate a stake pool using the free and open-source software(((free and open-source software))) (FOSS) – `cardano-node` and `cardano-cli`. However, it is essential for stake pool operators to possess the technical expertise required to operate a pool reliably and securely. While the requirements outlined in this section are not authoritative, they are generally recognized as critical for successful stake pool operation.

It is also important to note that many community-made tools and scripts are available, which significantly lower the technical barrier to entry for operating a stake pool. These tools assist with operational tasks but are not a substitute for the necessary technical knowledge or skills required for effective stake pool management.

==== Linux

A strong understanding of and ability to navigate, utilize, and manage the Linux operating system is a must for any stake pool operator. While cardano-node binaries are available for Linux, Mac, and Windows with each release, only Linux is supported in the block producer and relay roles. It is possible to build from source and operate cardano-node and cardano-cli on OpenBSD and potentially other Unix-based operating systems(((Unix-based operating systems))), but this is an advanced and separate topic.

Suggested readings and courses:

* https://training.linuxfoundation.org/training/introduction-to-linux/[Introduction to Linux (LFS101x) by The Linux Foundation]
* https://ubuntu.com/tutorials/command-line-for-beginners#1-overview[The Linux command line for beginners Tutorial by Canonical]

==== Networking

A solid understanding of transmission control protocol/internet protocol(((TCP/IP))) (TCP/IP) and experience with network maintenance are essential for SPOs managing a distributed network.

Suggested readings and courses:

* https://www.penguintutor.com/linux/basic-network-reference[TCP/IP Networking reference guide by Penguin Tutor]
* https://www.comptia.org/certifications/network[CompTIA Network + Certification]
* http://www.tcpipguide.com/[The TCP/IP Guide]

==== Documentation and learning

SPOs must keep their nodes updated and stay informed about new node versions and upcoming on-chain changes.

The Cardano node source code is open-source, allowing SPOs to review, clone, fork, compile, and improve it. While Cardano’s code is currently hosted on GitHub, it could be available on any version control platform(((version control platform))). SPOs should be capable of navigating projects on GitHub, understanding the documentation, and following the steps to compile and run the node.

Suggested reading:

* https://developers.cardano.org/docs/get-started/cardano-node/installing-cardano-node[Cardano.org guide for installing Cardano node]

=== Getting started

Prospective SPOs, whether new to system administration or experienced, should start by using Cardano on public testnets(((public testnet))). Currently, IOG supports two public testnet environments: preview and pre-production. Preview allows developers and users to test and provide feedback before updates are released on the mainnet, typically forking four epochs ahead. Pre-production is primarily for SPOs and developers to test major upgrades before deployment on the mainnet, usually forking one epoch ahead. Other public testnets, such as the https://github.com/cardano-community/guild-operators[Guild Network] are also available for use.

When considering launching a stake pool, it may be tempting to download and run the excellent scripts and tools created by the community for day-to-day operations. However, these tools are designed to assist those who already possess the necessary technical knowledge and skills.

Instead of rushing directly to mainnet operation, SPOs should take the time to learn essential tasks on existing testnets. This includes creating keys, compiling the node and CLI, crafting transactions, and registering signed certificates on the blockchain. Hands-on experience will reduce stress and save time when challenges arise during stake pool operations.

[[spo-guides]]
Here are a few useful guides and courses for setting up a stake pool:

* https://docs.cardano.org/developer-resources/cardano-node-course[Cardano Docs: Creating a stake pool]
* https://cardano-course.gitbook.io/cardano-course/handbook[Cardano Course: Handbook]
* https://developers.cardano.org/docs/operate-a-stake-pool/[Cardano Developer Portal: Operate a Stake Pool]
* https://www.coincashew.com/coins/overview-ada/guide-how-to-build-a-haskell-stakepool-node[Concashew’s Stake Pool Guide]

*Note:* The recommended reading and courses in this section suggest potential starting points for those interested in learning more about stake pool operations. They do not constitute endorsements.

==== Putting it all together, long time maintenance

The stability of the Haskell node has significantly improved, making basic node operation less challenging than during the early days of the Incentivized Testnet (ITN). This is especially true when using community tools mentioned in the ‘Getting started’ section, such as https://cardano-community.github.io/guild-operators/[CNTools], https://bitbucket.org/muamw10/jormanager/src/develop/[JorManager], https://github.com/gitmachtl/scripts[StakePool Operator Scripts], and others.

Prior to mainnet(((mainnet))) operations, prospective SPOs should master such key areas:

* *Monitor node health*: set up alerting systems for issues such as missed blocks, node crashes, or stuck block height.
* *Read and interpret logs*: analyze cardano-node logs to troubleshoot potential issues and investigate each missed block. Long-term luck should approximate 100%. Although block collisions (where multiple pools are assigned the same slot) do occur, they are uncommon.
* *Collaborate on GitHub*: help other SPOs analyze, contribute to, and create cardano-node issues for testnets or mainnet.
* *Maintain infrastructure*: execute node or infrastructure updates seamlessly, ensuring no service interruption.
* *Harden the pool environment*: strengthen security around the pool infrastructure.
* *Sync to universal time*: keep both the node and server synchronized with universal time to prevent operational issues.
* *Handle pool registration securely*: perform updates without exposing sensitive keys.
* *Expand node resources*: increase resource provisioning for cardano-node without interrupting services.
* *Plan for failover*: prepare and configure systems to handle critical node failures.

=== Assigning leadership slots to stake pools

==== Overview
On proof-of-work blockchains like Bitcoin, miners generate blocks by solving cryptographic puzzles, which is highly resource-intensive. In contrast, Cardano, a proof-of-stake blockchain, selects stake pools to create blocks using a stake-weighted lottery system. This system is detailed in the https://eprint.iacr.org/2016/889.pdf[Ouroboros paper], and this section offers a simplified overview.

==== Epochs, blocks, and slots
The leadership schedule on Cardano is divided into epochs and slots, with epochs being longer than slots. On the Cardano mainnet, each epoch lasts five days and begins at 21:44:51 UTC. Every epoch contains 432,000 one-second slots (five days). While different configurations may exist for other Cardano-based test networks(((test network))) or sidechains, this section focuses on the Cardano mainnet.

There is a chance for block creation in each slot. To ensure a secure process, each stake pool node must determine if the pool is:

* Allowed to create a block in a specific slot
* Able to prove to other nodes that it was permitted to create the block
* Able to hide its selection for future block creation from others

image::limbo.png[width=100%,title="Limbo"]
==== Playing Limbo
To simplify how a pool is chosen to create a block, imagine it as a game of Limbo. To win, a person (the stake pool) must go under the bar (a threshold value). For each slot, the bar is set at a unique height for each stake pool, determined by the pool’s stake. Larger pools have a higher bar, making it easier for them to win (create blocks), while smaller pools have a lower bar. The bar’s height isn’t fixed but is randomly adjusted for each participating pool based on its stake.

To determine if a stake pool can create a block in a given slot, several factors are assessed.

First, the epoch nonce is considered. This is a random number formed from two key components: the rolling nonce(((rolling nonce))) (which updates with every block) and a block hash. The rolling nonce is selected from the block just before the stability window of the previous epoch, which lasts 1.5 days. As a result, leadership information for the next epoch can only be calculated 1.5 days before it begins.

The second value used in the epoch nonce(((epoch, nonce))) is the hash of the last block from the previous epoch. These values are concatenated and hashed to produce the epoch nonce, which is the same for all pools.

The epoch nonce, the absolute slot number, and the pool’s VRF secret key are then combined to generate a random output for each slot. This output is weighted by the pool’s stake relative to the total ada staked in the system. If the weighted value is below a certain threshold, the pool is permitted to create a block – winning the game of Limbo for that slot!

==== Security
Security is maintained by ensuring only the pool operator knows when they will create a block. The pool’s VRF secret key(((verifiable random function, secret key))) is used to determine leadership selection, while the VRF public key is published on the blockchain. This ensures that only the pool operator is aware of their block-making opportunity, while others can verify the VRF signature after the block is made. This process ensures fairness and prevents anyone else from predicting block creation, making it impossible for attackers to target a stake pool with a DDoS attack.

=== Slot battles, height battles, forkers, and propagation

==== Ouroboros leader selection review
Based on the Ouroboros protocol, Cardano stake pools create blocks on behalf of their delegators. This protocol operates a lottery in every slot (one per second, per current parameters), with a pool’s chance of being selected as a leader proportional to its stake. If a pool wins the lottery, it becomes the leader for that slot. While the full details of the algorithm are covered in the  https://eprint.iacr.org/2016/889.pdf[Ouroboros paper] and other sections of this book, the key point is that any pool with stake can potentially be a leader in any slot. This can result in multiple pools being chosen as leaders for the same or nearly the same slot. However, only one block can be accepted on the chain for a given slot, leading to situations known in the Cardano community as ‘battles.’

==== Types of battles
To understand the types of battles in Cardano, it is essential to review key aspects of blockchain functionality. Consider the illustration below featuring three blocks, starting with the one on the left at height 8,265,668 in slot 244,252, with a block hash of ‘c7b2…​8bac.’ The next block, with a hash of ‘f777…​498c’ at height 8,265,669, includes the parent hash ‘c7b2…​8bac,’ indicating it is built on the previous block. This block was created 9 slots (9 seconds, per current protocol parameters) later, in slot 244,261. Finally, the third block at height 8,265,670, which includes the parent hash ‘f777…​498c,’ was created in slot 244,309. This illustrates how blocks are sequentially built upon one another, contributing to the growth of the blockchain.

image::nittygritty-illustration-1.png[width=100%,title="Basic blockchain illustration"]
==== Slot battles
A slot battle is a situation when two blocks are presented at the same height, have the same parent hash(((parent hash))), and occur in the same slot.

image::nittygritty-illustration-2.png[width=50%,title="Slot Battle"]

==== Height battles
A height battle occurs when two blocks are presented at the same height, share the same parent hash, but have different slots.

image::nittygritty-illustration-3.png[width=50%,title="Height Battle"]

==== Forkers
Forkers refers to a situation where a pool operator runs multiple block-producing nodes(((block-producing node))) simultaneously. This often happens during system upgrades when a second instance is launched before the old one is shut down. Both instances may create and distribute blocks to the network. While this does not constitute a battle, it can lead to confusion and inefficiencies in the blockchain, making it important for the community to minimize.

image::nittygritty-illustration-4.png[width=50%,title="Forker"]

==== Summary
The following table summarizes the types of contention we can have on the Cardano blockchain.
[cols="1,1,1,1,1", options="header"]
|===
|Type |Same Slot |Same Parent Hash |Same Height |Same Stake Pool
|Slot Battle |Yes |Yes |Yes |No
|Height Battle |No |Yes |Yes |No
|Forker |Yes |Yes |Yes |Yes
|===

==== Resolution of battles and forks
When a battle or fork occurs on the network, all nodes must reach consensus on which block to add to the chain and which one(s) to discard. In the Praos era (post-Vasil hard fork), two primary rules guide this decision:

.  Chain Length, the longest chain length is always preferred.
.  If the chain length is the same, we choose the block with the lowest block vrf.

==== Block VRF
The block VRF is a value generated from the epoch nonce, the slot number, and the private VRF key registered by the pool. This value does not depend on the block’s contents and cannot be manipulated by the pool operator. Block VRF values can be quite large, represented as a 128-character hexadecimal number.

==== Propagation
Propagation(((Propagation))) refers to the process of distributing a block made by a pool to the network for inclusion in the blockchain. Pool operators often invest considerable effort in optimizing their setups to ensure their blocks reach as many nodes as possible. While the technical details of this process are beyond this section’s scope, it is crucial to recognize that blocks do not reach all network participants simultaneously, and there is a time delay in their distribution.

The Cardano(((Cardano))) ecosystem provides tools to visualize each pool’s propagation time. The example below illustrates a pool’s measured propagation for the blocks it has created. On average, every node receives the block within approximately 600 milliseconds, though some outliers take significantly longer. This highlights the importance of having an effective distribution strategy for blocks.

image::nittygritty-illustration-5.png[width=50%,title="propagation time"]

==== Tying it all together: some real examples

===== The typical situation
In the typical situation, over 90% of the blocks on the chain are created smoothly, without issues. The example below depicts a normal scenario where one pool creates a block, followed by another pool building a block on top of it. In this example, the first pool creates a block in slot 10, and the second pool creates a block in slot 15. The second pool’s block is built on top of the first pool’s block, allowing the chain to continue growing.

1.  Pool A creates a block in slot 10
2.  Pool A sends a block to all of its peers on the network
3.  Pool A's peers forward the block further to all of their peers and so on.  Some nodes receive the block in slot 10, some in slot 11, some in slot 12, etc.
4.  Pool B creates a block in slot 15 and because it already has seen Pool A's block, it builds on top of it and extends the chain further and the cycle continues.

===== The height battle example
But what if pool B creates a block in slot 15 and does not have pool A’s block yet? This scenario leads to a height battle, as both pool A’s block in slot 10 and pool B’s block in slot 15 will share the same parent block. The contention is settled by comparing the block VRF(((block VRF))) values; the block with the lowest VRF value will be added to the chain, while the other block will be discarded.

===== The slot battle example
The slot battle example illustrates a scenario where both pool A and pool B create a block in slot 10, leading to immediate contention. This situation results in a slot battle, where the block with the lowest VRF value is added to the chain, and the other block is discarded.

[sidebar]
.Interesting Historical Trivia
--
Interesting historical trivia: In earlier versions of the Cardano ITN protocol, the first pool to submit a block would win the battle. This approach led to centralization, as nodes with faster internet connections or those located closer to most other nodes consistently prevailed in the battle.
--

===== The underpowered node problem
Sometimes, pool operators encounter problems with their nodes that slow down block production. This issue is often due to underpowered hardware or unoptimized node configurations. As a result, other pool operators may lose blocks through no fault of their own.

1.  Pool A creates a block in slot 10
2.  Pool B is assigned a block in slot 11 but is very slow to generate the block and it takes 5 seconds to create and propagate the block to other nodes.
3.  Meanwhile Pool C is assigned a block in slot 14 and since it hasn't seen Pool B's block yet, it builds on top of Pool A's block.
4.  Finally in slot 15 Pool B’s block is distributed and all nodes need to pick between Pool B’s block and Pool C’s block when if all pools were operating at full speed, Pool B’s block would have been the one that was added to the chain and then Pool C’s block would have built on top of that.

Underpowered nodes can cause pools to lose blocks without justification, resulting in lower chain density and reduced decentralization. This highlights the importance of having a robust block distribution strategy(((block distribution strategy))) for pool operators.

[[spo-cardano-cli]]
=== The Cardano command line interface

==== Prologue

As its name suggests, the Cardano command line interface (`cardano-cli`) is the low-level CLI component of the `cardano-node` repository. It serves as a perfect companion to cardano-node, often built alongside it or provided as a pre-compiled binary(((pre-compiled binary))). The primary purpose of `cardano-cli` is to interact with the blockchain managed by cardano-node. Would you drive a car without a steering wheel?

This section focuses on the subset of `cardano-cli` commands most useful to Cardano stake pool(((stake pool))) operators. It outlines the steps required to set up a stake pool from the very beginning, including:

* Key generation for addresses and pools
* Certificate generation
* Node queries
* Basic transactions

To walk through these steps, let’s assume you have:

* `cardano-cli` installed in your machine
* `cardano-node` installed, running, and synced to a publicly available Cardano network (eg, preview, pre-production, or mainnet)
* the `CARDANO_NODE_SOCKET_PATH` properly set in your environment so that `cardano-cli` can communicate with your running instance of `cardano-node`

_Note that the last two points are only necessary when submitting a transaction or querying the ledger. A running node is essential for interacting with or accessing the current state of the blockchain. However, generating keys, addresses, or certificates only requires cardano-cli and should often be done entirely offline for security reasons._

Before starting, check that both cardano-node and cardano-cli are up to date. Paste the following code snippet into your terminal:

----
cardano-node version
----

Your terminal should return a response similar to the following:

----
 cardano-node 1.35.6 - linux-x86_64 - ghc-8.10
 git rev 07b0c71d2e6662aec4389ec282a7e91f68c3d85f
----

Ask `cardano-cli` for its version using the command:

----
cardano-cli version
----

----
cardano-cli 1.35.6 - linux-x86_64 - ghc-8.10
git rev 07b0c71d2e6662aec4389ec282a7e91f68c3d85f
----

This indicates that both tools are running the same version (1.35.6) and originate from the same code branch (git rev 07b0c7…3d85f). Perfect!

____

Notice how we access the version command of cardano-cli (or cardano-node) using a single space character to navigate through the available commands. The version command takes no extra parameters. As you will see later, parameters are passed using a double hyphen (`--`).
____

==== Keys generation

Public/private key pairs are fundamental in cryptography. In Cardano, the holder of a private key can spend ada from an address, sign a block, or prove to other nodes their authority to sign a specific block.


*Note: It is essential to protect all private keys from both unauthorized access and accidental deletion. Since the launch of Shelley, there have been numerous examples of mismanaged keys leading to non-functional stake pools and, in rare instances, stolen funds. Proper key management is crucial for the security and functionality of a stake pool.*

==== Addresses

Every action recorded on the ledger requires a transaction fee. An address must cover this transaction fee and/or provide funds as a deposit (see the <<basic-transaction>> section). This section describes how to generate address key pairs and derive a base address used to create and register a stake pool.

Note that this section is not a complete reference for cardano-cli concerning addresses.

==== Payment key pair

We will refer to this as the `payment` key pair. The suffix `vk` identifies the *payment public key(((payment public key)))* (or verification key), while the suffix `sk` identifies the *payment private key* (or secret key). In Cardano, ada contained in an address is controlled solely by the `payment.sk`.

Let's generate one:

----
cardano-cli address key-gen --verification-key-file ./payment.vk --signing-key-file ./payment.sk
----

As mentioned earlier, `address` and `key-gen` are two nested commands of `cardano-cli`, while `--verification-key-file` and `--signing-key-file` are parameters of the entire command.

In the directory where you executed the command, you should have the following files:

----
payment.sk
payment.vk
----

Both files have the structure shown below:

----
cat ./payment.vk
----

----
{
    "type": "PaymentVerificationKeyShelley_ed25519",
    "description": "Payment Verification Key",
    "cborHex": "5820205d42785c7dc9a46898655ecda8dad8b14e47747dc94ba184edc8ada0b72969"
}
----

The `payment.sk` has the same structure, with the type `PaymentSigningKeyShelley_ed25519` and of course a different `cborHex` value. You will not learn more, it is a secret after all.

Now, we have what we need to derive an address to receive funds. Use the following command:

----
cardano-cli address build --payment-verification-key-file ./payment.vk --mainnet > payment.addr
----

The newly created `payment.addr` file contains an address in the format:

----
addr1v9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3gnt67k6
----

Three things to note:

* `--payment-verification-key-file` is the sole parameter needed for payment address creation.
* We used the `--mainnet` parameter to create this address. It means that this address won't be of any use on a testnet. Conversely, the `--testnet-magic` parameter would allow us to create an address for a specified testnet. Mishaps avoided!
* Cardano Preview Testnet is on `--testnet-magic 2` and Cardano Preprod Testnet is  on `--testnet-magic 1`

==== Staking key pair

Using the address generated above has one significant drawback: it can receive and send ada but has no staking rights associated with it, making it what we call an enterprise address(((address, enterprise))). To enable staking rights, we need to add a staking key to the address.

In the same folder where the payment key(((payment key))) pair is located, let’s generate a *staking* key pair. Following convention, we will call them `stake.vk` and `stake.sk`:

----
cardano-cli stake-address key-gen --verification-key-file ./stake.vk --signing-key-file ./stake.sk
----

Both files have the following structure:

----
{
    "type": "StakeVerificationKeyShelley_ed25519",
    "description": "Stake Verification Key",
    "cborHex": "5820eaa448543c3f95cbecf5c7ef00e481695388462c7e470b90052920138272a88b"
}
----

Similarly, we can build the corresponding staking address(((address, staking))) using the `stake.vk`.

----
cardano-cli stake-address build --stake-verification-key-file ./stake.vk --mainnet > stake.addr
----

The newly created `stake.addr` file contains:

----
stake1uy4hlpcmhd026m4ny9y9uxl94rez479g8h0sqalljf9zehguqnhcm
----

==== Building an address

As noted, both the payment key pair and the staking key pair can be used to generate addresses. While the payment address (or enterprise address) can be used to receive or send ada, the staking address serves a different purpose. A staking address is not functional on its own; it only becomes active when linked to ada residing within a payment address.

----
cardano-cli address build  --payment-verification-key-file ./payment.vk --stake-verification-key-file ./stake.vk --mainnet > base.addr
----

The newly created  `base.addr`  file contains an address that enables:

1) sending and receiving ada
2) delegating and receiving rewards

----
addr1q9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3ft07r3hw6744htxg2gtcd7t28j9tu2s0wlqpmllyj29nwssucyxn
----

Note that this address is longer than an `enterprise address(((address, enterprise)))`.

==== File summary #1

Your working directory should now contain 7 files:

----
1. base.addr
2. payment.addr
3. payment.sk
4. payment.vk
5. stake.addr
6. stake.sk
7. stake.vk
----

It is now time to back up these key pairs and send some ada to the base.addr to fund the next venture: creating a stake pool(((stake pool))).

==== Stake pool related key pairs

The creation and operation of a Cardano stake pool relies on three public/private key(((private key))) pairs.

==== Stake pool keys or cold keys

Stake pool keys, or cold keys, should be kept in a cold environment(((cold environment))), meaning they should reside on a machine that is permanently disconnected from the internet or any other networks.


*Note*: The pool private cold key governs all pool actions, including pool creation, key rotations (such as KES or VRF key pairs), fee structure, reward and pledge address settings, and pool retirement.

----
cardano-cli node key-gen --cold-verification-key-file ./pool.vk --cold-signing-key-file ./pool.sk --operational-certificate-issue-counter-file ./counter
----

Notice that in addition to the `cold-verification-key-file` and `cold-signing-key-file`, we also generated a mandatory `counter` file.

----
{
    "type": "NodeOperationalCertificateIssueCounter",
    "description": "Next certificate issue number: 0",
    "cborHex": "820058203e9dff9346dab83c109a9da73aabf4642ebe64e0274b6a0931ee4b8d838ea304"
}
----

This `counter` will be used to create an `operational certificate(((operational certificate)))` for the stake pool. For now, let's keep in mind that the `operational certificate` is generated by using this `counter` and a KES public key defined in the section "KES keys pair".

We have not yet registered the Cardano stake pool, but we can already determine its future on-chain ID.

----
cardano-cli stake-pool id --cold-verification-key-file ./pool.vk
----

and the answer is

----
pool1xhjzslnkyxvj23almagsmzeck0el7989cqz9rlms8a0pvdly0de
----

==== VRF keys pair

The VRF key pair is used by the node to determine whether to attempt signing a block. At every slot, the node checks this condition.
----
cardano-cli node key-gen-VRF --verification-key-file ./vrf.vk --signing-key-file ./vrf.sk
----

Let's have a look:

----
{
    "type": "VrfVerificationKey_PraosVRF",
    "description": "VRF Verification Key",
    "cborHex": "5820b49718bee9e359b666950c255f2ff7a3ace260963baeb8e8b618d75575dd8ce7"
}
----

The VRF key will reside on the connected block-producing node(((block-producing node))), as it is used as a parameter to start `cardano-node`.


*Note*: While it is possible to modify the VRF key of a stake pool by sending a new pool registration certificate, doing so will forfeit pool rewards for two epochs. This requirement helps encourage tight security practices.

==== KES keys pair

The KES key pair is the key used by the node to sign a block.

----
cardano-cli node key-gen-KES --verification-key-file ./kes.vk --signing-key-file ./kes.sk
----

Let's have a look:

----
{
    "type": "KesVerificationKey_ed25519_kes_2^6",
    "description": "KES Verification Key",
    "cborHex": "5820f93acee67a1af6529ff02818a18c813d05a71c3cde8a16606133dbbee7f583bc"
}
----

The KES signing key must also reside on the block-producing node.

A `kes.sk` used by a node has a validity range of 93 days (or 62 KES periods) and needs to be renewed before this period expires. That’s where the `counter` and the `operational certificate(((operational certificate)))` come into play.

==== Operational certificate

To create an `operational certificate` run:
----
cardano-cli node issue-op-cert --kes-verification-key-file ./kes.vk --cold-signing-key-file ./pool.sk --operational-certificate-issue-counter-file ./counter --kes-period 694 --out-file op.cert
----

*Some explanations are in order:*

* The `counter` will automatically be incremented by exactly *one* after running the above command. You can check this:

----
{
    "type": "NodeOperationalCertificateIssueCounter",
    "description": "Next certificate issue number: 1",
    "cborHex": "820158203e9dff9346dab83c109a9da73aabf4642ebe64e0274b6a0931ee4b8d838ea304"
}
----

The `--kes-period` defines the *starting point* of a validity range for the `kes.sk` referenced in the operational certificate. One way to calculate the `current-kes-period` of the network on Cardano mainnet is to use the formula below. We assume here that `byron_slots`, `byron_end_time` and `slots_per_kes_period` are constant values:

----
current-kes-period = (byron_slots+(CurrentTime - byron_end_time))/slots_per_kes_period
current-kes-period = (4492800+(CurrentTime-1596059091))/129600
----

`CurrenTime` on your machine can be obtained like this:

----
printf '%(%s)T\n' -1
----

Some noteworthy Cardano community members have developed fully parameterized methods to calculate the current KES period for any given network, such as https://github.com/gitmachtl/scripts/blob/master/cardano/mainnet/0x_showCurrentEpochKES.sh[this one]. Their contributions are invaluable.

*You must generate a new KES key pair and a new `operational certificate` before the end of the validity period, which lasts exactly 62 KES periods*. Your block-producing node will need to be restarted using a new `kes.sk` and a new `operational certificate`. This process is called `KES rotation`. *One period corresponds to 1.5 days. That is why KES rotation must occur every 93 days at most.* However, you can perform this rotation earlier if it is more convenient.


In the example above using `--kes-period 694` , the `operational certificate(((operational certificate)))` will certify that the `kes.sk` is valid until the network reaches the `kes-period 756`.

Since the Babbage era (September 2022), it is important to know that an operational certificate *must be rotated using a +1 counter* (previously, it could be any value higher than the last counter) and *only if the pool has produced at least one block during the interval of 93 days*. If the pool has not produced any blocks during this period of 93 days (or 62 kes-periods), the counter must be reset to its previous value before generating a new operational certificate. An example is shown at the end of this section.

`cardano-cli` offers a query that recapitulates all that:

----
cardano-cli query kes-period-info --op-cert-file ./op.cert --mainnet
----

and replies

----
✓ Operational certificate's KES period is within the correct KES period interval
✗ No blocks minted so far with the operational certificate at: ./op.cert
  On disk operational certificate counter: 0
{
    "qKesCurrentKesPeriod": 695,
    "qKesEndKesInterval": 756,
    "qKesKesKeyExpiry": null,
    "qKesMaxKESEvolutions": 62,
    "qKesNodeStateOperationalCertificateNumber": null,
    "qKesOnDiskOperationalCertificateNumber": 0,
    "qKesRemainingSlotsInKesPeriod": 7891408,
    "qKesSlotsPerKesPeriod": 129600,
    "qKesStartKesInterval": 694
}
----

Notice here that by the time we generated our first `operational certificate`, 1 kes-period passed. See the difference between `"qKesCurrentKesPeriod": 695` and `"qKesStartKesInterval": 694` !

*Rotation example with a `counter` reset:*

Let’s assume that 62 KES periods have passed, and the pool has not produced any blocks while using the first operational certificate. At this point, it's necessary to rotate the pool's KES key by generating a new operational certificate. However, since the pool did not produce any blocks, the KES key rotation must be performed without the automatic increment in the counter, which is typically done by the `cardano-cli node issue-op-cert` command. Instead, the counter must remain the same as the previous value before generating the new operational certificate.

To revert the automatic increment of the counter, a new counter can be manually specified using the command below:

----
cardano-cli node new-counter --cold-verification-key-file ./pool.vk --counter-value 0 --operational-certificate-issue-counter-file ./new.counter
----

We set a `--counter-value` of `0` and created the new counter file `new.counter`.

Let's see how `new.counter` looks:

----
{
    "type": "NodeOperationalCertificateIssueCounter",
    "description": "",
    "cborHex": "820058203e9dff9346dab83c109a9da73aabf4642ebe64e0274b6a0931ee4b8d838ea304"
}
----

The `"description"` field has unfortunately been destroyed but what matters is the `cborHex` value, reset to `+"8200...8ea304"+`. Do you notice a difference with the last time we looked at it?

It had a different `cborHex` – `‘8201...8ea304’`. That little integer change makes all the difference. Make sure to edit manually the `‘description’` field of the `new.counter` to avoid getting lost later on.

To conclude, the `new.counter` can now be used to generate a fresh operational certificate(((operational certificate))). Remember to use a new pair of KES keys and ensure that the current KES period of the network is up-to-date.

==== File summary #2

Your working directory should now contain 16 files:

----
1. base.addr
2. counter
3. kes.sk
4. kes.vk
5. new.counter <<< Example file that can safely be destroyed.
6. op.cert
7. payment.addr
8. payment.sk
9. payment.vk
10. pool.sk
11. pool.vk
12. stake.addr
13. stake.sk
14. stake.vk
15. vrf.sk
16. vrf.vk
----

==== Certificates

Certificates are actions performed on the ledger allowing to:

* Register a stake address (and deregister)
* Register a stake pool (and deregister)
* Delegate an address to a stake pool

[discrete]
==== Address registration (and deregistration)

The stake component within a base address(((address, base))) (base.addr) must be registered on the ledger before it can be used to delegate ada, receive staking rewards, or declare the pool's pledge or receive pool rewards. This is accomplished by submitting a registration certificate for the corresponding stake address (stake.addr) on the blockchain.

For now, let’s create the registration certificate with the following command:

----
cardano-cli stake-address registration-certificate --stake-verification-key-file ./stake.vk --out-file stake.registration
----

A deregistration certificate(((deregistration certificate))) for an address can also be generated using the `cardano-cli stake-address deregistration-certificate` command. This is the recommended method for stopping participation in ada staking. To incentivize users, deregistering an address refunds the 2 ada deposit paid during registration. More about this later.

[discrete]
==== Stake pool registration

Similar to a `base.addr`, a stake pool must register itself on the network before it can receive delegation and produce blocks. The stake pool registration certificate is more complex than a base address registration because it includes detailed information about the pool's configuration, such as:

* Pool keys
* Owner(s)
* Fee structure
* Pool relays
* Metadata

Let’s examine this certificate line by line, to understand its components:

----
cardano-cli stake-pool registration-certificate \
--cold-verification-key-file ./pool.vk \
--vrf-verification-key-file ./vrf.vk \
--pool-reward-account-verification-key-file ./stake.vk \
--pool-cost 340000000 \
--pool-margin 0.02 \
--pool-owner-stake-verification-key-file ./stake.vk \
--pool-pledge 0 \
--pool-relay-ipv4 xxx.xxx.xxx.xxx \
--pool-relay-port xxxx \
--metadata-url url-to-metadata \
--metadata-hash hash-of-metadata \
--mainnet \
--out-file pool.registration
----

`--cold-verification-key-file`: ensures the right cold secret key(((secret key))) signature is present when sending the certificate on-chain.

`--vrf-verification-key-file`: other pools will check whether the pool had the right to produce a block for a given slot.

`--pool-reward-account-verification-key-file`: specifies the stake.vk of the base.addr that will  receive the rewards for running the pool. Only one reward account can be assigned to a stake pool(((stake pool))).


*The reward address will not be required to sign the transaction sending the certificate on-chain.*


`--pool-cost`: the fixed cost(((fixed cost))) the pool will charge before calculating the margin fee. It cannot be set lower than 340 ada or 340000000 lovelaces at this time on mainnet.

`--pool-margin`: the percentage fee(((percentage fee))) taken by the pool on the remaining rewards after pool cost has been deducted from all block rewards. Its boundaries are 0 (0 %) and 1 (100%). In this example, it is set at 2%

`--pool-owner-stake-verification-key-file`: specifies the `stake.vk` of the `base.addr(((base.addr)))` used  as the pledge for the pool. While it can be the same as the reward account, a different address may be chosen. Multiple base addresses can be used for pledging.

*The transaction sending the certificate will include a signature for each and every address referenced as a pool owner.*

`--pool-pledge`: defines the minimum amount in lovelace that must collectively be present in the owner(s) account(s). If this requirement is not met, the pool will forfeit all rewards, both for delegators and the pool itself. To ensure flexibility or avoid risks in this example, it is set to 0.

*The address(es) declared as pool’s pledge must all be delegated to the pool being registered.*

`--pool-relay-ipv4`: the IP address of the relay node(((node, relay))) used to shield the block produced from connections to the wider network. Note that an ipv6 option exists.

`--pool-relay-port`: specifies the port on which the relay cardano-node(((cardano-node))) will be listening.

NOTE: If more than one relay is used, these parameters can be duplicated thus:

----
--pool-relay-ipv4 IP#1 \
--pool-relay-port xxxx#1\
--pool-relay-ipv4 IP#2 \
--pool-relay-port xxxx#2\
----

Alternatively, the `--single-host-pool-relay` can be used to declare a stake pool(((stake pool))) relay's DNS name that corresponds to an A or AAAA DNS record.

----
--single-host-pool-relay dns.record \
--pool-relay-port xxxx \
----

`--metadata-url`: specifies a publicly available URL that serves the metadata for the pool. This metadata provides important information about the pool, such as its name, description, and other relevant details. Here is an example of a pool’s metadata.json file:

----
{
"name":"Pool's name",
"description":"Example pool",
"ticker":"EXP",
"homepage":"https://examplepool.com"
}
----

`--metadata-hash`: a hash of the accessible metadata.json(((metadata.json))) file, which ensures the file has not been tampered with. Once the metadata.json file is downloaded from the URL, the hash can be generated using cardano-cli. The command for generating the hash is as follows:

----
cardano-cli stake-pool metadata-hash --pool-metadata-file ./metadata.json --out-file ./metadata.hash
----

Explore the `cardano-cli stake-pool registration-certificate` command to know more about other options available (`ipv6` or `SRV DNS records` for example).

[discrete]
==== Stake pool deregistration

If you wish to retire a pool, you can easily create a `deregistration certificate(((deregistration certificate)))`:

----
cardano-cli stake-pool deregistration-certificate --cold-verification-key-file ./pool.vk --epoch 410 --out-file pool.deregistration
----

The `--epoch` parameter specifies the desired epoch for the pool to become inactive. This epoch must be in the future, but it cannot exceed 18 months. This limit is defined by the `eMax` value in the `mainnet-shelley-genesis.json` configuration file on the Cardano mainnet.

When a pool operator sends a deregistration certificate on-chain, they will receive a refund of the 500 ada deposit paid for the initial pool registration as an incentive for deregistering the pool.

*Only the pool cold keys are necessary to retire a pool. If the owner is not the pool operator, they have no authority in this process.*

[discrete]
==== Delegation certificate

A `base.addr` can be delegated to a stake pool(((stake pool))) via a `delegation certificate` as follows:

----
cardano-cli stake-address delegation-certificate --stake-verification-key-file ./stake.vk --cold-verification-key-file ./pool.vk --out-file delegation.certificate
----

As expected, the delegation(((delegation))) process requires the `stake.vk` of the address from which you wish to delegate, along with the `pool.vk` of the pool you intend to delegate to. Since the pool is operated by you, obtaining this information should not be an issue.

Do not hesitate to explore the `cardano-cli stake-address delegation-certificate` command to learn how to delegate to another stake pool for which you are not the operator (ie, you do not possess the corresponding `pool.vk`).

[discrete]
==== File summary #3

Your working directory should now contain 21 files:

----
1. base.addr
2. counter
3. delegation.certificate
4. kes.sk
5. kes.vk
6. new.counter <<< Example file that can safely be destroyed.
7. metadata.hash
8. op.cert
9. payment.addr
10. payment.sk
11. payment.vk
12. pool.deregistration <<< Example file that can safely be destroyed.
13. pool.registration
14. pool.sk
15. pool.vk
16. stake.addr
17. stake.registration
18. stake.sk
19. stake.vk
20. vrf.sk
21. vrf.vk
----

Congratulations! We are almost done!

Now that all addresses, keys, and certificates are in your possession, you can interact on-chain (see the <<basic-transaction>> section) and announce your presence in the Cardano network.

==== Queries

Before building transactions, familiarize yourself with node queries. One cardano-cli query function has already been encountered: checking the KES period information of the network.

All query commands can be listed like this:

----
cardano-cli query
----

Rather than reviewing all available queries, let us focus on some useful ones for the upcoming <<basic-transaction>> section. Feel free to explore other queries independently.

[discrete]
==== Protocol parameters

First, retrieve the protocol parameters and save them in a `pparameter.json` file:

----
cardano-cli query protocol-parameters --mainnet > pparameters.json
----

`pparameter.json` includes a detailed list of smart contract-related costing models and essential information for estimating transaction costs. For our purposes, we will focus on the transaction cost estimation details.

[discrete]
==== UTxOs in an address

To manually build the transaction that will post the previously created certificates, we must identify which UTXO to use. A UTXO is uniquely identified on-chain by the combination of a transaction hash (TxHash) and a transaction index (TxIx)(((transaction, index))). An address can hold multiple UTXOs, making it essential to determine the specific UTXO for this transaction.

We can access the UTxO(s) of an address as follows:

----
cardano-cli query utxo --address addr1q9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3ft07r3hw6744htxg2gtcd7t28j9tu2s0wlqpmllyj29nwssucyxn --mainnet
----

----
                           TxHash                                 TxIx        Amount
--------------------------------------------------------------------------------------
0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211     0        5000000 lovelace + TxOutDatumNone
----


For demonstration, the address generated in the first section of this tutorial has been funded with five ada, or 5,000,000 lovelaces. While this amount is insufficient for the subsequent steps, it provides a practical example.

[discrete]
==== Slot height of the network

Cardano transactions have an expiry date, which the user can define. To set this expiry, one must first determine the `Cardano time` expressed in `slot` height:

----
cardano-cli query tip --mainnet
----

----
{
    "block": 8668162,
    "epoch": 406,
    "era": "Babbage",
    "hash": "cf5902001ba7024b07c999421804a77b6bf7858c2298e7ead1c5732a6697bcc7",
    "slot": 90368116,
    "syncProgress": "100.00"
}
----

[[basic-transaction]]
==== Basic transaction

In this section we will create a single transaction that will post the `stake.registration` of the `base.addr`, the `pool.registration` and the `delegation.certificate` that were generated in the previous sections. All in one go.

[discrete]
==== Estimate the transaction fee

We will first create a dummy transaction (`tx.draft`) to estimate the transaction fees.

----
cardano-cli transaction build-raw \
--tx-in 0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211#0 \
--tx-out addr1q9m8pcfxszyvx7gytqc2s9l400aund8z7sazfs2jtfy4h3ft07r3hw6744htxg2gtcd7t28j9tu2s0wlqpmllyj29nwssucyxn+0 \
--invalid-hereafter 0 \
--fee 0 \
--certificate-file ./stake.registration \
--certificate-file ./pool.registration \
--certificate-file ./delegation.certificate \
--out-file tx.draft
----

Because it is a `tx.draft` all values are set to `0`.

* `--tx-in`: the UTxO that will be consumed in the format *`TxHash#TxIx`*. Nothing prevents you from consuming more UTxO! Use additional `--tx-in` lines to do so.
* `--tx-out`: the address where ada change will be sent back to. Nothing prevents you from specifying more than one address! Use additional `--tx-out` lines to do so.
* `--invalid-hereafter`: the transaction will be valid until this slot height is reached.
* `--fee`: the transaction fee of what we want to calculate!
* `--certificate-file`: adding a certificate to the transaction.

Once we have the `tx.draft`, we can calculate the fees.

----
cardano-cli transaction calculate-min-fee \
--tx-body-file tx.draft  \
--tx-in-count 1 \
--tx-out-count 1 \
--witness-count 3 \
--mainnet \
--protocol-params-file pparameters.json
----

You may adjust the `--tx-in-count`, `--tx-out-count`, and `--witness-count` values accordingly. Here, we consume one UTxO, have the change sent back in a single address and will sign the transaction with 3 witnesses (a.k.a. secret keys).

The command replies :

----
197313 Lovelace
----

Perfect! Only 0.197313 ada. Not too expensive for a transaction containing three certificates.

*Note*: Transaction fees are deterministic and as such, have a lower bound. However, users can always choose to pay more than the required amount. It is important to handle fee inputs with care.

[discrete]
==== Build the final transaction

----
cardano-cli transaction build-raw \
--tx-in UTxO_TxHash#TxIx \
--tx-out $(cat base.addr)+value \
--invalid-hereafter 90369116 \
--fee 197313 \
--certificate-file ./stake.registration \
--certificate-file ./pool.registration \
--certificate-file ./delegation.certificate \
--out-file tx.final
----

* `--tx-in UTxO_TxHash#TxIx`: `TxHash`#`TxIx` of the UTxO you want to consume!
* `--tx-out $(cat base.addr)+value`

[IMPORTANT]
====

*`--tx-out` value is expressed in lovelaces.
Registering an address requires a deposit of 2 ada (2000000 lovelaces).
Registering a pool requires a deposit of 500 ada (500000000 lovelaces).
This means that the change to the `base.addr` will be : *_value = input - (502 deposit + transaction fee)_* Deregistration of an address or a pool will be accounted for by adding 2 ada or 500 ada, respectively, to the ada change value one must calculate to correctly balance a transaction! For example, to deregister simultaneously a base address and a pool: *_value = (input + 502 deposit) - transaction fee_*.
====

* `--invalid-hereafter`: The slot tip of the network plus some slots to give your transaction time to get accepted by the network. Here, 1000 slots (seconds on mainnet) or ~ 15 minutes in the future, from the last query we made at `"slot": 90368116`.
* `--fee`: the exact value we calculated earlier.
* `--certificate-file`: adding a certificate to the transaction.


*Note:*  The order in which the certificates are declared will matter in the final transaction. You cannot delegate to a pool that does not exist yet. You cannot register a pool with an owner’s address that is not registered yet. Hence, we register the `base.addr` (its staking part) first, then the pool and finally delegate to it.

[discrete]
==== Sign and send a transaction

----
cardano-cli transaction sign \
--tx-body-file ./tx.final  \
--signing-key-file ./payment.skey \
--signing-key-file ./stake.skey \
--signing-key-file ./pool.skey \
--mainnet \
--out-file tx.final.signed
----

The transaction must be signed by three private keys in this case.

* `payment.skey` will authorize spending funds from the `base.addr`.
* `stake.skey` will authorize the use of `base.addr` (its staking part) as a pool owner and authorize delegation to the pool at the same time.
* `pool.skey` will authorize the registration of the pool

*Note*: The address used for collecting pool rewards does not need to sign this transaction. In this case, the same address is used for both reward collection and pledge functions. The pool owner (pledge) is not required to sign a `de-registration certificate`. Updating pool parameters is done by sending a new `pool-registration certificate`, and the deposit is only required during the initial registration.

----
cardano-cli transaction submit \
--tx-file tx.final.signed \
--mainnet
----

Congratulations! It is all done, the pool is now registered! With some delegated stake, it will sign blocks and pay rewards to the `base.addr` (once the block-producing node is started with the appropriate keys).

==== 	Rewards withdrawal

As the pool grows in saturation, it will eventually mint blocks and start accumulating ada rewards. These rewards, however, reside in the stake account associated with the base.addr and are not immediately available as UTXOs.

To access these rewards, let’s query a random address that has accumulated ada:

----
cardano-cli query stake-address-info --address stake1u97v0sjx96u5lydjfe2g5qdwkj6plm87h80q5vc0ma6wjpq22mh4c --mainnet
----

----
[
    {
        "address": "stake1u97v0sjx96u5lydjfe2g5qdwkj6plm87h80q5vc0ma6wjpq22mh4c",
        "delegation": "pool1kchver88u3kygsak8wgll7htr8uxn5v35lfrsyy842nkscrzyvj",
        "rewardAccountBalance": 370751053
    }
]
----

This address contains `370751053` lovelaces or  `370.751053 ada` rewards.

A withdrawal transaction can be created to convert these ada rewards into spendable UTXOs.

First, let's estimate first the transaction fee for this:

----
cardano-cli transaction build-raw \
--tx-in 0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211#0 \
--tx-out $(cat base.addr)+0 \
--withdrawal $(cat stake.addr)+0 \
--invalid-hereafter 0 \
--fee 0 \
--out-file withdraw.draft
----

`--withdrawal`: specifies from which `stake.addr` rewards will be withdrawn from; `+` separates the address from the value withdrawn in lovelace.

Since we only create a fake transaction in order to calculate transaction fees, we set the value withdrawn at 0.

Next, run:

----
cardano-cli transaction calculate-min-fee \
--tx-body-file withdraw.draft  \
--tx-in-count 1 \
--tx-out-count 1 \
--witness-count 2 \
--mainnet \
--protocol-params-file pparameters.json
----

----
178525 Lovelace
----

Almost done. Let's craft the real withdrawal transaction now.

----
cardano-cli transaction build-raw \
--tx-in 0a0043122fb4913b8694bb0b0af7d0c65130d2787ced56bf61bc6ba2fcf5f211#0 \
--tx-out $(cat base.addr)+375572528 \
--withdrawal $(cat stake.addr)+370751053 \
--invalid-hereafter 90455278 \
--fee 178525 \
--out-file withdraw.draft
----

[IMPORTANT]
====

*All values are expressed in lovelaces.*

* The `base.addr` will receive as change : *`UTxO_value + rewards_withdrawn - transaction_fees`*
* *Rewards are withdrawn in full. Partial withdrawals are not allowed.*
* Additional `--tx-out` fields can be added, provided the transaction remains balanced (total input - transaction fees = total output).
====

We can now sign the transaction:

----
cardano-cli transaction sign \
--tx-body-file ./withdraw.draft  \
--signing-key-file ./payment.skey \
--signing-key-file ./stake.skey \
--mainnet \
--out-file withdraw.signed
----

Two witnesses are required:

* The `payment.sk` of the `base.addr` that pays for the transaction fee.
* The `stake.sk` of the `stake.addr`, to allow the withdrawal of ada rewards.

Send the transaction:

----
cardano-cli transaction submit \
--tx-file tx.final.signed \
--mainnet
----

==== Epilogue

This guide details all the necessary `cardano-cli` actions to become an autonomous stake pool operator on Cardano. Hopefully, this document has clarified the numerous components involved.

Community tools, like https://github.com/cardano-community/guild-operators[Guild-Operators] or the https://github.com/gitmachtl/scripts[Stake Pool Operators Scripts] repositories, abstract most of the steps described. Additionally, operations requiring a running instance of `cardano-node` (to query or post on the ledger) can be performed using a copycat of `cardano-cli` called https://github.com/blockfrost/blockfrost-cardano-cli[`blockfrost-cardano-cli`]. It can be sometimes faster than querying your local `cardano-node` instance!

Given the importance of handling private keys securely, it’s recommended to use tools that integrate hardware wallets. One such tool is `cardano-hw-cli`, a version of `cardano-cli` designed to manage both addresses and pool private keys via hardware wallets https://github.com/vacuumlabs/cardano-hw-cli[here].

*Note*: _It is essential to have a clear understanding and hands-on experience with these tools before use. For first-time users, practicing on testnets is highly recommended to avoid any mistakes._

=== Keeping time

Ouroboros is the protocol powering Cardano, symbolized by the eternal serpent consuming its own tail. Until https://eprint.iacr.org/2019/838.pdf[Ouroboros Chronos] is implemented, the ‘timeless’ Ouroboros relies on stake pool operators to help maintain accurate time.

Clock synchronization is essential in distributed networks. Nodes must prevent clock drift, which occurs when they measure time at slightly different rates. In Ubuntu and other Linux distributions, various network time protocol (NTP) programs help reduce time synchronization offsets to a few milliseconds. One commonly used program is Chrony, which should be installed and running on the node or relay for Cardano. On Ubuntu, Chrony can be installed using `apt install chrony`.

After installing Chrony, it is recommended to configure the default configuration file (`/etc/chrony/chrony.conf`) with nearby, high-performance NTP servers. These servers should be polled frequently to minimize drift from the global clock. NTP servers are categorized by stratum levels, where:

* *Stratum 0*: reserved for atomic clocks or other highly accurate time sources
* *Stratum 1*: suitable for systems that can deviate only within a few milliseconds of stratum 0
* Higher strata indicate further deviations from precise time.

To check the stratum level, use the command `chrony ntpdata`. Below is an example of a typical `chrony.conf` configuration:

[source, chrony.conf]
----
pool 192.168.2.100 minpoll 1 maxpoll 2 maxsources 1
pool time.cloudflare.com minpoll 3 maxpoll 4 maxsources 1
pool time.google.com minpoll 3 maxpoll 4 maxsources 1
maxupdateskew 5.0
makestep 0.1 -1
rtsync
leapsectz right/UTC
----
==== Comments on the example configuration

* To add NTP servers, include their IP address (e.g., 192.168.2.100) or DNS name (e.g., time.google.com) in the chrony.conf file.

* Setting lower values for minpoll and maxpoll reduces time drift; maxsources sets the maximum number of sources used from the pool.

* Public timesync servers provided by companies like Cloudflare (time.cloudflare.com), Google (time.google.com), and Facebook (time.facebook.com) are generally reliable and high-performing. The https://www.ntppool.org/en/[NTP pool project] also lists NTP servers worldwide for broader options. Running a local timesync server is another option to encourage decentralization. https://www.satsignal.eu/ntp/Raspberry-Pi-NTP.html[Guides are available] for setting one up using a Raspberry Pi.

* In the example configuration, a local Stratum 1 GPS source (192.168.2.100) on a LAN is used with a fast polling rate. Additionally, two public NTP servers (Stratum 3 Cloudflare and Stratum 1 Google) are included with slower polling rates. Be cautious with overly-aggressive polling rates to avoid being blacklisted by public timesync servers.

* On modern fiber connections near the timesync server, it is recommended to use a lower value for Chrony’s internal estimate of how fast or slow the computer clock runs relative to the timesync server. Setting maxupdateskew to 5.0 (down from the default 1000 ppm) helps maintain higher precision in time synchronization.

* Chrony can adjust system clocks more frequently by setting a lower makestep value. For example, makestep 0.1 -1 adjusts the clock whenever a drift of 0.1 seconds occurs. Network Interface Cards (NICs) with an internal clock for timestamps (which can be identified using ethtool -T) can also be enabled for hardware timestamping with hwtimestamp and the interface name or * for all interfaces.

* Drift may be checked with `chronyc tracking` and `chronyc sourcestats` to view offsets and skew.

* Rtsync can be set to enable the kernel to periodically synchronize the system clock with the real-time clock, typically every 11 minutes on Linux. If the connected timesync server does not provide leap second updates in advance, the leapsectz option (e.g., leapsectz right/UTC) may be configured. In general, it is recommended to use Coordinated Universal Time (UTC) for server time, as this is the global standard and the format most GPS-based timesync servers report in.

With that out of the way in a fairly short time (pun intended), a stake pool operator will be able to keep Cardano nodes collaborating well with the rest of the network in a timely manner!

=== Server security and hardening

_Security is a state characterized by the absence of fear or anxiety regarding one’s physical, economic, technological, or social well-being, or that of those under one’s care. In information technology (IT), achieving this requires implementing preventive measures, enforcing security policies and procedures, and conducting regular security assessments to identify and address vulnerabilities. IT security is critical today, with the widespread use of electronic communication, by protecting systems, networks, and the data they handle, and preventing data breaches._

'''''

This section addresses the security considerations for becoming an SPO. We will begin with general system administration security principles, followed by a focus on Cardano node security, containerized environments, secure shell (SSH) configuration, the advantages of using a virtual private network (VPN), and conclude with final thoughts on stake pool security.

==== System administration security

Outlined here are common best practices in IT server administration for any project.

*Note*: All examples listed here are suggestions for commands you can use on the Unix operating system (OS). Please conduct your own research (DYOR) or refer to the command-related manual (RTFM) for verification.

'''''

==== Best practice

* Use a secure operating system with long-term support to ensure access to the latest security updates and patches.
* Start with a clean, minimal setup for the operating system hosting your Cardano environment.
* Ensure that your day-to-day user account and cloud provider accounts utilize secure authentication methods, such as strong passwords and two-factor authentication (2FA).
* Whenever possible, configure your server with two public IP addresses: one for administration (SSH and/or VPN) and another for the services you want to expose. This approach minimizes targeted attacks on your administration pipelines and restricts public exposure to only those services you choose (commonly referred to as ‘minimizing the attack surface area’).
* Exercise caution during system administration. Always have a plan, document it, and test it before implementing changes in the production environment. An automated reporting system, such as Prometheus/Grafana, is advisable. Additionally, develop a recovery plan for potential incidents.
* Avoid running services as root whenever possible, as this increases the risk of unauthorized access and data breaches.
* Monitor exposed services, as they can be targets for cyberattacks. Be aware of the services running on your server and take steps to secure them. It is advisable not to leave any unused ports open, as they can provide unauthorized access. Disable any unnecessary open ports or services, or filter them using appropriate firewall rules. You can list open ports and their associated services using commands like: `sudo netstat -latupen` , `sudo lsof -i`, `sudo ss -antlp`. Some of these commands will also list services listening on 127.0.0.1, which is on the loopback interface (lo).
* Implement Fail2Ban to block unauthorized access attempts and denial-of-service (DoS) attempts. This tool helps block or delay persistent and/or malicious IP addresses, such as port scanners, crawlers, and those using brute-force techniques, from accessing your server.
* Change your server DNS to use known secure DNS (e.g. 1.1.1.1 and 1.0.0.1)
* Use a hardware or software firewall on your server to restrict ports and allow only necessary traffic. Firewall rules can mitigate DoS attacks and port flooding by implementing connection limit rules; refer to iptables-extensions(8) for examples. Consider the firewall as a backup mechanism after assessing the open services. While a firewall can help prevent further administrative incidents, it may also increase complexity and require additional attention.
* Keep your server’s operating system and installed software up-to-date to ensure that you have the latest security patches and fixes.
* Disable IPv6 on your server if it is not in use, as it can serve as a potential attack vector. Use the following command to edit the configuration file: `nano /etc/sysctl.conf`. Then, add the line: `net.ipv6.conf.all.disable_ipv6 = 1`.
* Limit the programs with suid or sgid bit set. You may list them all with: $ `sudo find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l {} \;`
* Conduct a vulnerability scan using a tool like Nmap to protect against known vulnerabilities. While it may not offer the precision or comprehensiveness of a commercial scanner, it can still provide valuable insights.
* For those using systemd services, check security with systemd-analyze security. You can harden any UNSAFE or EXPOSED service by creating an `override.conf` file in the `/etc/systemd/system/unit.service.d/` directory (where unit is the name of the systemd service). Directives such as ProtectHome, ProtectSystem, and ProtectHostname are detailed in systemd.exec(5). Use the command `systemctl edit unit.service` to create the override.
* A quick and easy way to monitor the overall health, load, and security of your system is to use a terminal multiplexer like tmux, combined with the tmuxp session manager to save and reproduce tmux sessions from YAML or JSON files. This lightweight and efficient method provides secure remote access via SSH and serves as a text-based alternative or complement to Grafana. Useful commands for this setup include `dmesg`, `journalctl`, `iptables`, `tload`, `htop`, and `systemctl`, as well as combinations of `watch`, `tail`, and `grep`.

==== Node security

* It is highly recommended not to operate both the block producer and a public relay on the same host. Since the relay is publicly exposed, if it becomes compromised or is under attack (eg, DoS), your block producer may also go offline, leading to missed block production opportunities, which can negatively impact your ranking and associated rewards. To mitigate this risk, secure the block producer behind a firewall, allowing it to connect only to the relay nodes. The relay nodes can then connect to the block producer and other peer relays.
* It is recommended to only store the essential files (such as kes.skey, vrf.skey, etc) on your server for running the Cardano node. It is also strongly recommended to keep other files related to your wallet/pool, such as private keys, on a separate, secure, and preferably air-gapped device.
* Additionally, it is important to avoid running any programs, including `cardano-node` and `db-sync`, with root privileges. Instead, create a non-privileged account and use it for these tasks, and this applies to both non-containerized and containerized environments.
* It is always advisable to use a hardware wallet for your pool as it will keep your private keys safe and secure.
* Proper server security is crucial to ensure the availability, integrity, and confidentiality of your blockchain network. Segregating different functionalities and roles across separate servers, along with using unprivileged accounts, can help reduce the risk of unauthorized access and data breaches.

'''''

==== Containerized environments

Another option is to use containerized environments, which allow Cardano’s software to run in logical separation from the hosting server, thereby containing potential breaches. Utilizing such software to ensure proper configuration also increases the level of IT knowledge.

Containerized environments provide several advantages from a security point of view:

* *Isolation*: containers are isolated from each other and from the host system, meaning that a security vulnerability or attack in one container will not impact other containers or the host.
* *Least privilege*: each container runs with a specific set of permissions, reducing the risk of privilege escalation. This means that a malicious container will only have access to the resources it needs to function.
* *Segmentation*: allows the creation of multiple isolated networks for different containers, enhancing the separation of services and reducing the attack surface.
* *Patching*: allows for quick and easy patching of vulnerabilities in an application, without the need to patch the entire system.
* *Auditing*: provides detailed information about the container environment, including system calls, network connections, and file access. This information can be used to identify potential security issues and track down the source of a security incident.
* *Security scanning*: provides a security scanning feature; several third-party security scanning tools can also be used to check images for vulnerabilities.
* *Sandboxing*: containers run in a sandboxed environment – any malicious activity is restricted and the host system is not affected.
* *Control over the environment*: enables consistent and predictable application execution.

Please note that while containerized environments enhance security, they are not a complete solution. Proper configuration and security measures within the containers are essential to ensure system safety.

A plethora of options exist that provide similar containerization functionality:

* LXC (LinuX Containers), Docker, rkt (Rocket), OpenVZ, LXD (built on top of LXC), Kubernetes, Mesos.

Note that while these alternatives provide similar functionality, they may have different architectural designs and may require different configurations and management processes. It is essential to evaluate the needs of your organization and compare each solution before making a decision.

'''''

==== Securing SSH

SSH is a fundamental service for remote server access. Proper configuration and security are essential to prevent unauthorized access. It is also advisable to implement a plan for monitoring and auditing SSH access (eg, using Grafana or Fail2Ban) and to apply regular security updates and patches.

Key security considerations for securing SSH include:


. Use a different port than the default 22/tcp, such as a port over 10000/tcp for added security. Example: `nano /etc/ssh/sshd_config` and change the line `Port 22` to `Port 10022`
. Disable access to root login on the SSH config and only use unprivileged account(s) with SUDO access. Example: `sudo nano /etc/ssh/sshd_config` and change the `PermitRootLogin to no`
. Use port knocking (`knockd`) to add an additional layer of security to your SSH connections.
. Disable (or fake) banners to prevent displaying unnecessary information that could potentially be used by attackers. Example: `nano /etc/ssh/sshd_config` and change the line `Banner /etc/issue.net` to `#Banner /etc/issue.net`
. Define a number of max concurrent sessions to limit the number of simultaneous connections to your server. Example: `nano /etc/ssh/sshd_config` and add the line `MaxSessions 10`
. Add it to your fail2ban instance to delay any attempt at brute-forcing or password guessing. Example: `nano /etc/fail2ban/jail.local` and add the section `[sshd] enabled = true`
. Disable password login in SSH. It is recommended not to use username/password authentication for SSH, instead use certificate-based (PKI) authentication for added security. Don’t forget to password protect your private key when you generate it. Example: `ssh-keygen -t rsa`
. When applicable, restrict access to the only IP address you’ll be using to connect to your server. Example: `nano /etc/ssh/sshd_config` and add the line `AllowUsers user@xxx.xxx.xxx.xxx`
. Use SFTP or SCP to transfer files (over SSH) to and from your server, as it provides an added layer of security compared to FTP.
. You can use SSH tunneling to encrypt and redirect traffic within remote nodes, in order to access backend infrastructure.

==== Use a VPN (as alternative to SSH tunneling)

It is beneficial for SPOs to use a virtual private network (VPN) (e.g. WireGuard) to access a server backend (such as Grafana or Prometheus) due to enhanced security and accessibility. A VPN establishes a secure and encrypted connection between the client device and the server backend, protecting transmitted data from potential eavesdropping or tampering.

This protection is especially important when accessing sensitive information like financial data, personal details, or confidential blockchain data. Additionally, a VPN enables remote access to the server backend, allowing SPOs to connect from anywhere with an internet connection. This capability is particularly useful for SPOs managing nodes remotely or across different locations. Furthermore, using a VPN can help bypass geographical restrictions or censorship. Overall, employing a VPN to access a server backend effectively secures and facilitates access to sensitive information and resources for SPOs.

=== Monitoring

Monitoring is a crucial part of stake pool operation. It helps minimize the chance for lost blocks and can allow the operator to maximize rewards for delegators along with contributing to strong network performance on the Cardano blockchain.

* Reliability: Monitoring helps ensure the full-time availability of a stake pool to mint and propagate assigned blocks in a reliable manner. By diligent monitoring of key metrics such as blockheight, uptime, timesync, KES expiry period, unadopted blocks, missed slots, etc., patterns of Stake Pool service disruption can be detected and prevented.
* Capacity Planning: By analyzing historical resource usage data, future resource requirements can be forecast to anticipate capacity constraints and allow the operator to scale infrastructure proactively to meet evolving Cardano Stake Pool operation needs, thereby avoiding performance degradation or service outages due to insufficient resources.

==== Prometheus

Prometheus is an open-source monitoring and alerting toolkit. It is designed for reliability, scalability, and simplicity in monitoring complex IT environments. Prometheus is often recommended for scraping Cardano Stake Pools metrics for several reasons:

* Powerful Data Model and Query Language: Prometheus employs a multi-dimensional data model and PromQL (Prometheus Query Language) for querying and analyzing time-series data. This model allows for flexible and efficient querying of metrics based on various dimensions such as labels, enabling operators to gain deep insights into the performance and health of an operator’s stake pool infrastructure. With PromQL, operators can perform complex aggregations, transformations, and statistical analysis on time-series data, making it easier to identify trends, anomalies, and patterns in monitored metrics.
* Scalability and Reliability: Prometheus is designed to be highly scalable and reliable, capable of handling large-scale deployments with thousands of servers, containers, or microservices. It employs a pull-based model, where Prometheus servers periodically scrape metrics from instrumented targets, providing a scalable approach to monitoring dynamic environments. Additionally, Prometheus supports federation, allowing multiple Prometheus servers to aggregate and federate metrics from different sources, enabling horizontal scalability and distributed monitoring setups. Its robust architecture and proven reliability make it suitable for mission-critical IT environments where uptime and performance are paramount.
* Rich Ecosystem and Integration: Prometheus has a vibrant ecosystem with a wide range of integrations and exporters for collecting metrics from various systems, applications, and services. It supports integrations with popular technologies such as Kubernetes, Docker, AWS, and more, making it easy to monitor modern cloud-native environments and microservices architectures. Additionally, Prometheus integrates seamlessly with other tools in the monitoring ecosystem, such as Grafana for visualization, Alertmanager for alerting, and third-party storage solutions like Thanos for long-term storage and high availability. This rich ecosystem of integrations and complementary tools enhances the flexibility and extensibility of Prometheus, making it a versatile choice for monitoring diverse IT environments.

For Cardano Stake Pools these are typical targets to scrape for Prometheus:

* The Cardano-node built-in EKG Prometheus exporter with Cardano node metrics on blockheight, missed-slots, KES expiry and more.
* The open source `node_exporter`, an open source Prometheus exporter for hardware and OS metrics exposed by *NIX kernels for metrics on CPU, memory, disk usage, timesync and others.
* https://cardano-community.github.io/guild-operators/[Cardano Guild Operators Koios SPO Tools] to expose `CNCLI` Prometheus metrics on block.db metrics such as number of sequentially missed blocks, adopted blocks, epoch luck, etc.

The Prometheus scrape targets are defined via a `.yml` configuration file (typically named `prometheus.yml`). To double check syntax, you can run `./promtool check config prometheus.yml`.
Before adding a visualization layer to Prometheus like Grafana it is recommended to connect to the Prometheus web portal (by default on localhost:9090) to double check that scraping targets are reachable. Check that the status is green and `up` on all configured endpoints in `Status -> Targets`. This status page is very helpful to debug scrape endpoint connections.

To scrape remote servers securely various techniques exist, see also Server Hardening.
For example, one could use a web server such as Nginx and configure it as a Reverse Proxy for the endpoint metrics to be scraped by Prometheus with Transport Layer Security (TLS) encryption in place. You can use TLS for IPs. You can also scrape Prometheus over a WireGuard VPN or other VPN service. Firewall rules should ensure that only the Prometheus monitoring server may access the remote endpoint.

*_Note:_*  Prometheus and Grafana server should be run separately from the block producing node, to avoid competition of compute resources, and disruption of block production. Ideally, a separate monitoring host should be set up. If a separate host is not available, a passive relay host may be used.

==== Grafana

Grafana is an open-source platform for monitoring and observability, specializing in data visualization and analytics. It allows operators to create dashboards, charts, and graphs to visualize and analyze metrics from various data sources. It is an ideal companion to display Prometheus metrics. Stake pool operators generally opt to use Grafana alongside Prometheus for the following reasons:

* Flexible Visualization and Dashboards: Grafana provides a highly flexible and customizable platform for visualizing metrics and building dashboards. It offers a wide variety of visualization options, including graphs, gauges, tables, heatmaps, and more, allowing operators to create rich, interactive dashboards tailored to their specific monitoring needs. Grafana supports multiple data sources, including Prometheus, Graphite, InfluxDB, Elasticsearch, and many others, enabling operators to consolidate metrics from different sources into a single unified dashboard for comprehensive monitoring and analysis.
* Extensibility and Integration: Grafana is highly extensible and supports integration with a vast ecosystem of data sources, plugins, and extensions. It offers a plugin architecture that allows developers to create custom data source plugins, panel visualizations, and integrations with third-party services. This extensibility enables Grafana to adapt to diverse monitoring environments and integrate seamlessly with existing tools and systems. Additionally, Grafana supports features such as annotations, templating, and alerts, enhancing its functionality and making it a versatile platform for monitoring IT services.
* Community and Adoption: Grafana has a large and active community of users, developers, and contributors, driving innovation and adoption in the monitoring space. The Grafana community has developed a wide range of plugins, dashboards, and integrations, which are freely available through the Grafana Plugin Repository and community forums. This vibrant ecosystem of community-contributed content provides operators with access to a wealth of resources and pre-built solutions for monitoring various technologies, applications, and infrastructure components. Additionally, Grafana’s popularity and widespread adoption make it a de facto standard for visualization and monitoring in many organizations, ensuring long-term support, stability, and continued development of the platform.

Some Prometheus exporters like `node_exporter` come with their own pre-configured Grafana dashboard.  `Cardano-node` does not have a default Grafana dashboard yet, but the community has created various dashboards and shared those online to copy and adapt or for inspiration.

Grafana dashboards can be easily configured with a graphical drag & drop interface or editing the JSON configuration file.

==== Alerting with Prometheus and Grafana

Effective alerting options exist within Prometheus and Grafana, and alerts may be configured with either service:

* Prometheus Alertmanager: Alertmanager is a component of the Prometheus monitoring system responsible for handling alerts generated by Prometheus servers. It receives alerts from Prometheus via its alerting rules and then performs actions based on those alerts, such as sending notifications to various alerting channels (e.g., email, Slack, PagerDuty, Telegram, xMatters). Alertmanager focuses on managing and routing alerts efficiently, ensuring that the right notifications reach the appropriate recipients according to defined alert routing and suppression rules. Alertmanager is tightly integrated with Prometheus and is primarily designed to work with Prometheus-generated alerts. It provides native integration with Prometheus’s alerting rules and relies on Prometheus’s pull-based model for collecting metrics. While Alertmanager can integrate with other monitoring systems and services via webhooks and APIs, its primary focus is on handling alerts generated by Prometheus. The Prometheus Alertmanager is configured via YAML-files.

* Grafana Alerting: Grafana Alerting is a feature built into the Grafana platform that enables operators to create and manage alerts directly within the graphical Grafana dashboards. It allows operators to define alert conditions based on query results from data sources and configure alert notifications to be sent via various channels (e.g., email, Slack, PagerDuty, Telegram, xMatters) Grafana Alerting is tightly integrated with Grafana’s visualization and dashboarding capabilities, enabling operators to create rich, interactive dashboards with embedded alerts and seamlessly transition between monitoring and alerting workflows within the Grafana interface. Grafana Alerting offers integration capabilities with various data sources and external systems. Grafana Alerting allows operators to define alert conditions based on data queries from diverse data sources, enabling flexible and customizable alerting workflows tailored to specific monitoring environments. Additionally, Grafana Alerting can integrate with external notification services and platforms, providing users with a wide range of options for alert notification delivery.

Thresholds can be defined for each relevant monitoring metric to determine when alerts are triggered. Useful alerts include:

* Last blockheight: Did the block producer lag behind the anticipated blockheight?
* Disc usage: Is disk space running out?
* Missed or ghosted blocks: Did the block producer miss minting or propagating a sequential number of assigned blocks?
* Missed slot leadership checks: Did the block producer miss checking leadership eligibility for a large number of slots?
* Available memory: Is memory usage too high and potentially affecting node performance?
* Endpoint availability: Are all relevant endpoints for scraping available?
* KES expiry: How much time is left before KES keys expire?
* Time synchronization: Is the server time out of sync?

For advanced alert routing and communication, cloud platforms such as xMatters or PagerDuty can be added as another layer between the generated alerts from either Prometheus or Grafana with the potential benefits:

* Reducing MTTR (mean time to respond) by suppressing redundant alerts and only relay the most critical insights to on-call resolvers.
* Customizing alert data and response actions to eliminate manual work.
* Allowing resolvers to pause and resume. An example being Grafana alerts directly from xMatters notifications as resolution is reached.

*_Note:_*  xMatters has a free tier that works for both Prometheus Alertmanager and Grafana Alerting.

==== Zabbix

https://www.zabbix.com/[Zabbix] is another integrated, all-in-one monitoring solution with out-of-the-box capabilities for monitoring diverse IT components and can be configured to monitor Cardano Nodes. Prometheus and Grafana do offer more scalability, flexibility, and customization options, but Zabbix is an alternative.

==== RTView

https://docs.cardano.org/cardano-components/cardano-rtview[RTView] is a real-time monitoring program that provides visibility on the state of running Cardano nodes. It supports multiple node monitoring, even if the nodes work on different machines.

The main benefit of RTView is simplicity. It is simple to use; technically there is no installation, you just unpack an archive and run an executable. It is also simple to configure through an interactive dialog and shows particular changes the user should make in the node configuration files.

RTView does render a webpage dashboard and offers a less-complex but robust alternative to a well-configured Prometheus and Grafana monitoring setup.

==== Koios gLiveview

https://cardano-community.github.io/guild-operators/Scripts/gliveview/[Koios gLiveView] is a local monitoring tool to use in addition to remote monitoring tools like Prometheus and Grafana, Zabbix or RTView. This is especially useful for systemd deployments  as it provides a terminal UI to monitor real time node status for Stake Pool operators.

*_Note:_*  If Koios gLiveView is launched on a block producer with an up-to-date block.db the tool will show block minting metrics and real-time left until the next block.

==== Manual Cardano log review

For Stake pool operators it is important to be able to read and interpret logs from cardano-node to troubleshoot and find potential issues. It is best practice to investigate each missed block and determine what went wrong. Long-term luck should be near 100% and while block collisions within the same slot occur, they are uncommon. About 5% of all blocks result in slot battles, as the outcome of a slot battle is random, about 2.5% of blocks are expected to be lost over time.

Ideally, an operator will investigate issues that affect block production within a stake pool and make adjustments to ensure smooth and reliable operation moving forward.

This is a typical debugging sequence:

* Determine the slot number missed from the calculated leaderlog.
* Was more than one block missed in sequence? If so, this is likely a serious issue such as an improperly started node, expired KES keys, or hardware or server failure.
* If a single block was lost, it is time to debug.
* Search the node log for the slot number it missed.
* Did the block producer recognize it was it’s turn to mint a block (nodeIsLeader)?
* Did the block producer mint the block? What was the blockheight and blockhash?
* Did the block producer add this block to its local chain or did it run into an internal fork?
* Did the relays see this blockhash and add it to their local chains?
* Blockheight can also be investigated in any of the public Cardano blockchain explorers.
* Did another pool mint this blockheight with the same slot number? If so, this was the result of a slot collision and is normal.
* Did another pool mint this blockheight with a different slot number? This is considered a Height battle and is usually the result of a misconfigured pool.
** If the block was propagated within its slot time (one second) it was very likely a race condition and the other pool was awarded the block based on a lower VRF hash. Not much can be done about these conditions at this time outside of working with the pool operators with misconfigured stake pools.
** If block propagation took longer than the awarded slot, it needs to be investigated. It is possible that a bottleneck or misconfiguration exists, preventing speedy propagation such as poor upload bandwidth.

Pool operators may choose to assist in diagnosing network-wide issues while, although rare, benefit from as many data-points as possible. Operators can consider contributing information about nodes to the following community services and keep informed about new and upcoming services:

* Operators may send the current chain tip of their block producer to Pooltool via https://github.com/cardano-community/cncli/blob/develop/USAGE.md#sendtip-command[cncli-SendTip]. This will show a green badge on Pooltool with current tip height and helps Pooltool to capture orphan blocks. While this doesn’t guarantee every orphan block made will be seen by Pooltool, a large number of reported orphaned blocks across pools can help diagnose wider network issues.
* Operators may also share the number of blocks assigned for an epoch and validate the correctness of past epochs via https://github.com/cardano-community/cncli/blob/develop/USAGE.md#sendslots-command[cncli-SendSlots]. This helps to debug issues on Leaderlog calculation and can increase pool performance visibility for delegators.
* Block propagation metrics may also be sent to monitor network propagation of new blocks as seen by the local cardano-node with the https://cardano-community.github.io/guild-operators/Scripts/blockperf/[blockPerf.sh] script; a public dashboard is in the works to display these metrics. Pooltool may also be checked regularly and operators can compare their own block propagation times with other operators.

'''''

==== Final thoughts

Keep the setup simple and minimize the attack surface. Being overly cautious can increase the complexity of monitoring and may isolate you from your system. Carefully manage risks until confident in your security, and always have a contingency plan.

Your laptop, air-gapped system, relay node servers, and block producer server will have different security levels based on their operational and economic value, as well as the context of use (cloud, dedicated, or bare metal, and geographical location). Develop a security plan after considering various scenarios and making informed decisions.

Take the time to design your infrastructure before implementation. This will save time in maintenance and improvement later.
