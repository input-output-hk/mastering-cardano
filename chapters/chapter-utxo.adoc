== The (E)UTxO Model

=== Accounting Models

Every cryptocurrency needs an _accounting model_ to keep track of who owns what, and Cardano is no exception.

One popular option for such a model is the so-called _account_ (or _balance_) _based_ model,
where users have accounts storing their balances and where transactions modify those balances.

This model should be familiar to most readers with a bank account, because it is the model used by banks,
which reflects the way most of us tend to think about accounting.

Ethereum is one example of a cryptocurrency which uses the account based model.
If Alice and Bob initially hold 100 ETH and 10 ETH respectively
and if Alices sends 30 ETH to Bob, then their balances would be updated as follows:

.Alice sends 30 ETH to Bob in the account based model
image::Alice_sends_30_ETH_to_Bob.png[]

=== The Pure UTxO Model

The account based model is not the only model, though, and it is not the one used by Cardano.
Instead, Cardano follows Bitcoin in this regard and extends Bitcoin's _UTxO model_ to the so-called _Extended UTxO model (EUTxO)_.

The term "UTxO" is an acronym for _Unspent transaction output_ and denotes just that:
the output of a transaction that has not yet been spent.

_Transactions_ are the fundamental building blocks of all blockchains, no matter what accounting model they use.
Transactions are what causes change and makes things happen.
But where in the account based model, transactions update balances,
in the UTxO model, they spend previously unspent outputs of past transactions and create new unspent outputs.

Transactions in the UTxO model have one or more _inputs_ and one or more _outputs_.
Each input spends an existing UTxO (and thereby renders it "spent"), each output creates a new UTxO,
which can then later be used as input for another transaction.

You can think of (unspent) transaction outputs as "coins" or "banknotes" that can be spent in future transactions.
When you receive a payment, you receive a new coin or banknote, which you can then spend in a future transaction.
When you spend money, you hand over coins or banknotes you received in the past.

In a sense, the UTxO model is finer grained than the account based model: It keeps track of each individual coin or banknote, not just of total balances.


Where the account based model resembles a bank account, the UTxO model resembles cash: If you pay somebody with cash, you hand over banknotes or coins from your wallet, which are unspent outputs of past transactions (when somebody paid _you_). You always have to spend whole banknotes and coins, you can't just keep half a coin in your wallet and hand over the other half.

UTxO's can only be spent as a whole, not partially. In this regard, they really behave like coins or banknotes:
If you pay somebody with cash and do not have the exact amount in your wallet, you do not tear a banknote in half,
but instead hand over too much money and expect change in return.

This is how it works in the UTxO model as well: One or more of the outputs of a transaction typically go back to yourself as change and are called _change outputs_.

This analogy with cash is not perfect, though, because even though you need to spend complete UTxO's, you can create new UTxO's with arbitrary values. If you pay somebody with cash, you can't just create new banknotes or coins out of thin air. But in the UTxO model, you can create new UTxO's with arbitrary values, as long as the values of the newly created UTxO's do not exceed the values of the UTxO's you spend.

So for example, if you have an input "coin" worth 100 ADA, you can create outputs worth 70 ADA and 30 ADA respectively, something you certainly cannot do with caseh.

Let us look at the example of Alice and Bob again, but this time in the UTxO model: Alice and Bob have 100 ADA and 10 ADA respectively. Alice might have two UTxO's, one worth 60 ADA, the other worth 40 ADA. Bob might have one UTxO worth 10 ADA. 

If Alice wants to send 30 ADA to Bob, she can create a transaction with one input (her UTxO worth 40 ADA) and two outputs, one output worth 30 ADA going to Bob, the other output worth 10 ADA going back to Alice.

She could also use her other UTxO, worth 60 ADA, and send 30 ADA back to herself. She could even use _both_ her UTxO's as inputs and create a change output worth 70 ADA. Or _two_ change outputs worth 50 ADA and 20 ADA or any other combination that adds up to 70 ADA.

EVen with this simple example, Alice has almost infinite possibilities to structure her transaction, as long as the sum of the output values equals the sum of the input values, the outputs going to Bob add up to 30 ADA and the change outputs add up to the correct change.

This sounds complicated, and it is, but in practice, no user has to worry about this: Wallets take care of all the details and create transactions automatically, picking the right UTxO's as inputs and creating the right outputs. Here the process of picking the right inputs is called _coin selection_.

Coin selection is really analogous to the process of picking the right coins and banknotes from your physical wallet when you pay with cash: You don't want too many coins in your wallet, you don't want to receive too many small coinsfootnote:[Such small coins are called _dust_ in the context of cryptocurrencies - UTxO's with a small value.] as change, but you also do not want to hand over all your small change. Wallets try to find a good balance between these competing goals.

.Alice sends 30 ADA to Bob in the UTxO model
image::Alice_sends_30_ADA_to_Bob.png[]

Note that this example is idealized: In reality, Alice would need to pay _transaction fees_ for the transaction, so the change outputs going back to herself would be slightly smaller than the difference between her inputs and the 30 ADA she sends to Bob.

Outputs in the pure UTxO model are given by an _address_ and a _value_.
The _address_, which in the case of Cardano contains a _PubKey Hash_ (the hash of a verification key),
determines who is allowed to later spend this output: 

Transactions trying to spend the output need to be _signed_
by the corresponding signing key (a transaction can be signed by arbitrarily many keys).
The _value_ is an arbitraryfootnote:[A certain minimal amount of ADA, the so-called _minimum deposit_, always needs to be included.]
mixture of ADA and native tokens.

Cardano transactions must be _balanced_: Roughly speaking, the sum of input values must equal the sum of output values.
There are some exceptions and refinements to this simple rule:

    * Each transaction needs to include _transaction fees_,
      which get subtracted from the input values before comparing them to the output values.
    * Cardano native tokens can be _minted_ or _burnt_ in a transaction.
    * Staking rewards can be withdrawn, getting added to the outputs without having compensating
      inputsfootnote:[Those staking rewards come from an internal reward account, not a regular UTxO.].

=== Extending It: The EUTxO Model

The UTxO model is simple and elegant, and it allows users to receive and send funds from and to arbitrary other users.

These days however, users expect more from a blockchain than just the ablity to send and receive funds. They want to be able to create _smart contracts_ that can do more than just move funds around, that can implement arbitrary logic and enforce complex rules. They also want to be able to create _fungible_ or _non-fungible_ tokens (sometimes called _NFT's_) and trade them on decentralized exchanges or sell them on decentralized marketplaces.

In the UTxO model, a transaction can spend inputs locked at a specific address if it is signed by the
signing key corresponding to that address.

In the _Extended_ UTxO model, this is generalized by replacing the need for certain signatures
with arbitrary logic.

In addition to using hashed public keys as (part of) addresses,
the EUTxO model introduces addresses that contain hashed _scripts_, written in a programming language (_Plutus Core_ in the case of Cardano).

During validation, when a transaction has an input at such a _script_ address, the corresponding script is executed.
If script execution completes without error, spending the input is valid; otherwise it is invalid.

To make this idea work, three more ingredients are needed:

    * In the UTxO model, a transaction output is given by an address and a value.
      The EUTxO model adds a third component, a piece of data called
      _datum_ footnote:[Adding a datum to an output is optional, but outputs at script addresses without datum
      are unspendable. Datums can also be added to PubKey addresses].
    * A transaction trying to spend an output at a script address must add another piece of data to the input,
      the _redeemer_. The redeemer can be thought of as a "key" used to "unlock" an input,
      a generalization of the signature used to unlock outputs at PubKey addressesfootnote.
    * When a Plutus Core script is executed for validation, it gets datum, redeemer and a _context_
      as arguments. The context contains the transaction being validated and all its inputs and outputs,
      but nothing else.

It turns out that this design hits a sweet spot regarding expressiveness and security:

    * Bitcoin offers smart contract capabilities in the form of _Bitcoin Script_, but those scripts only "see"
      the output being validated and the Bitcoin analog of a redeemer,
      not the whole transaction with other inputs and outputs. As a consequence, Bitcoin Script is extremely limited
      and unable to offer smart contracts of the type users have come to expect from blockchains like Ethereum.
    * Ethereum smart contracts are very powerful and flexible, but also extremely hard to get right.
      Their context is the whole state of the blockchain, which makes it difficult to predict what will happen when they get executed.
      This has led to several infamous exploits and bugs in the past, resulting in the unexpected loss of many millions
      of ether.

Cardano's EUTxO model with datums, redeemers and contexts is powerful and flexible enough to do whatever can be done
on Ethereum, but also simple enough to make it much easier to predict the effect of a given transaction.

Cardano transactions can be validated _locally_, without the need to submit them to the blockchain first,
because the context only contains the transaction itself and its inputs and outputs.
They can still fail when submitted, because some other transaction could have spent an expected input in the meantime,
but if all inputs are still unspent, the transaction will have the predicted effect.

As a consequence, Cardano transactions only incur a fee if they actually succeed and are included in the blockchain.
On Ethereum, transactions can fail and still cost gas. This can never happen on
Cardano (as long as a user does not go out of his way to circumvent all safety mechanisms).
