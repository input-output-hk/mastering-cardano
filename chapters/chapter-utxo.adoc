== The (E)UTxO Model

=== Accounting Models

Every cryptocurrency needs an _accounting model_ to keep track of who owns what, and Cardano is no exception.

One popular option for such a model is the so-called _account_ (or _balance_) _based_ model,
where users have accounts storing their balances and where transactions modify those balances.

This model should be familiar to most readers with a bank account, because it is the model used by banks,
which reflects the way most of us tend to think about accounting.

Ethereum is one example of a cryptocurrency which uses the account based model.
If Alice and Bob initially hold 100 ETH and 10 ETH respectively
and if Alices sends 30 ETH to Bob, then their balances would be updated as follows:

.Alice sends 30 ETH to Bob in the account based model
image::Alice_sends_30_ETH_to_Bob.png[]

=== The Pure UTxO Model

The account based model is not the only model, though, and it is not the one used by Cardano.
Instead, Cardano follows Bitcoin in this regard and extends Bitcoin's _UTxO model_ to the so-called _Extended UTxO model (EUTxO)_.

The term "UTxO" is an acronym for _Unspent transaction output_ and denotes just that:
the output of a transaction that has not yet been spent.

_Transactions_ are the fundamental building blocks of all blockchains, no matter what accounting model they use.
Transactions are what causes change and makes things happen.
But where in the account based model, transactions update balances,
in the UTxO model, they spend previously unspent outputs of past transactions and create new unspent outputs.

Transactions in the UTxO model have one or more _inputs_ and one or more _outputs_.
Each input spends an existing UTxO (and thereby renders it "spent"), each output creates a new UTxO,
which can then later be used as input for another transaction.

You can think of (unspent) transaction outputs as "coins" or "banknotes" that can be spent in future transactions.
When you receive a payment, you receive a new coin or banknote, which you can then spend in a future transaction.
When you spend money, you hand over coins or banknotes you received in the past.

In a sense, the UTxO model is finer grained than the account based model: It keeps track of each individual coin or banknote, not just of total balances.


Where the account based model resembles a bank account, the UTxO model resembles cash: If you pay somebody with cash, you hand over banknotes or coins from your wallet, which are unspent outputs of past transactions (when somebody paid _you_). You always have to spend whole banknotes and coins, you can't just keep half a coin in your wallet and hand over the other half.

UTxO's can only be spent as a whole, not partially. In this regard, they really behave like coins or banknotes:
If you pay somebody with cash and do not have the exact amount in your wallet, you do not tear a banknote in half,
but instead hand over too much money and expect change in return.

This is how it works in the UTxO model as well: One or more of the outputs of a transaction typically go back to yourself as change and are called _change outputs_.

This analogy with cash is not perfect, though, because even though you need to spend complete UTxO's, you can create new UTxO's with arbitrary values. If you pay somebody with cash, you can't just create new banknotes or coins out of thin air. But in the UTxO model, you can create new UTxO's with arbitrary values, as long as the values of the newly created UTxO's do not exceed the values of the UTxO's you spend.

So for example, if you have an input "coin" worth 100 ADA, you can create outputs worth 70 ADA and 30 ADA respectively, something you certainly cannot do with caseh.

Let us look at the example of Alice and Bob again, but this time in the UTxO model: Alice and Bob have 100 ADA and 10 ADA respectively. Alice might have two UTxO's, one worth 60 ADA, the other worth 40 ADA. Bob might have one UTxO worth 10 ADA. 

If Alice wants to send 30 ADA to Bob, she can create a transaction with one input (her UTxO worth 40 ADA) and two outputs, one output worth 30 ADA going to Bob, the other output worth 10 ADA going back to Alice.

She could also use her other UTxO, worth 60 ADA, and send 30 ADA back to herself. She could even use _both_ her UTxO's as inputs and create a change output worth 70 ADA. Or _two_ change outputs worth 50 ADA and 20 ADA or any other combination that adds up to 70 ADA.

EVen with this simple example, Alice has almost infinite possibilities to structure her transaction, as long as the sum of the output values equals the sum of the input values, the outputs going to Bob add up to 30 ADA and the change outputs add up to the correct change.

This sounds complicated, and it is, but in practice, no user has to worry about this: Wallets take care of all the details and create transactions automatically, picking the right UTxO's as inputs and creating the right outputs. Here the process of picking the right inputs is called _coin selection_.

Coin selection is really analogous to the process of picking the right coins and banknotes from your physical wallet when you pay with cash: You don't want too many coins in your wallet, you don't want to receive too many small coinsfootnote:[Such small coins are called _dust_ in the context of cryptocurrencies - UTxO's with a small value.] as change, but you also do not want to hand over all your small change. Wallets try to find a good balance between these competing goals.

.Alice sends 30 ADA to Bob in the UTxO model
image::Alice_sends_30_ADA_to_Bob.png[]

Note that this example is idealized: In reality, Alice would need to pay _transaction fees_ for the transaction, so the change outputs going back to herself would be slightly smaller than the difference between her inputs and the 30 ADA she sends to Bob.

Outputs in the pure UTxO model are given by an _address_ and a _value_.
The _address_, which in the case of Cardano contains a _PubKey Hash_ (the hash of a verification key),
determines who is allowed to later spend this output: 

Transactions trying to spend the output need to be _signed_
by the corresponding signing key (a transaction can be signed by arbitrarily many keys).
The _value_ is an arbitraryfootnote:[A certain minimal amount of ADA, the so-called _minimum deposit_, always needs to be included.]
mixture of ADA and native tokens.

Cardano transactions must be _balanced_: Roughly speaking, the sum of input values must equal the sum of output values.
There are some exceptions and refinements to this simple rule:

    * Each transaction needs to include _transaction fees_,
      which get subtracted from the input values before comparing them to the output values.
    * Cardano native tokens can be _minted_ or _burnt_ in a transaction.
    * Staking rewards can be withdrawn, getting added to the outputs without having compensating
      inputsfootnote:[Those staking rewards come from an internal reward account, not a regular UTxO.].

=== What changes?

Without change, there can be no impact on the real world. _Something_ has to change as the result of a transaction, otherwise the transaction is pointless.

In the account based model, the change is in the balances of the accounts.

If you know about imperative programming, you can think of the balances in the account based model as _global_ variables that get updated by transactions.

In the UTxO model, the change is in the set of UTxO's: Some UTxO's get spent, some new UTxO's get created, but no output ever gets modified. Once an output has been created, it will remain unchanged forever. The only effect a transaction has is to spend existing outputs and create new ones.

If you know about functional programming, you can think of the UTxO's as _immutable_ data structures that get _consumed_ by transactions, but never _modified_.

In the example above, before Alice sends 30 ADA to Bob, the UTxO-set consists of Alice's two UTxO's (60 ADA and 40 ADA) and Bob's UTxO of 10 ADA.

.The old UTxO-set before Alice's transaction
image::change_before_utxo.png[]

Alice's transaction consumes her UTxO worth 40 ADA and creates two new UTxO's, one worth 30 ADA going to Bob, the other worth 10 ADA going back to Alice.

So while no individual output changes, the _set_ of unspent outputs changes: One output is removed from the set (because it is now _spent_), and two new ones are added.

.The new UTxO-set after Alice's transaction
image::change_after_utxo.png[]

Of course there may be many more UTxO's on the blockchain that we are not considering here, but they have no influence on the transaction we are looking at.

=== Extending It: The EUTxO Model

The UTxO model is simple and elegant, and it allows users to receive and send funds from and to arbitrary other users.

These days however, users expect more from a blockchain than just the ablity to send and receive funds. They want to be able to create _smart contracts_ that can do more than just move funds around, that can implement arbitrary logic and enforce complex rules. They also want to be able to create _fungible_ or _non-fungible_ tokens (sometimes called _NFT's_) and trade them on decentralized exchanges or sell them on decentralized marketplaces.

In the UTxO model, a transaction can spend inputs locked at a specific address if it is signed by the
signing key corresponding to that address.

In the _Extended_ UTxO model, this is generalized by replacing the need for certain signatures
with arbitrary logic.

In addition to using hashed public keys as (part of) addresses,
the EUTxO model introduces addresses that contain hashed _scripts_, written in a programming language (_Plutus Core_ in the case of Cardano).

During validation, when a transaction has an input at such a _script_ address, the corresponding script is executed.
If script execution completes without error, spending the input is valid; otherwise it is invalid.

To make this idea work, three more ingredients are needed:

    * In the UTxO model, a transaction output is given by an address and a value.
      The EUTxO model adds a third component, a piece of data called
      _datum_ footnote:[Adding a datum to an output is optional, but outputs at script addresses without datum
      are unspendable. Datums can also be added to PubKey addresses].
    * A transaction trying to spend an output at a script address must add another piece of data to the input,
      the _redeemer_. The redeemer can be thought of as a "key" used to "unlock" an input,
      a generalization of the signature used to unlock outputs at PubKey addressesfootnote.
    * When a Plutus Core script is executed for validation, it gets datum, redeemer and a _context_
      as arguments. The context contains the transaction being validated and all its inputs and outputs,
      but nothing else.

It turns out that this design hits a sweet spot regarding expressiveness and security:

    * Bitcoin offers smart contract capabilities in the form of _Bitcoin Script_, but those scripts only "see"
      the output being validated and the Bitcoin analog of a redeemer,
      not the whole transaction with other inputs and outputs. As a consequence, Bitcoin Script is extremely limited
      and unable to offer smart contracts of the type users have come to expect from blockchains like Ethereum.
    * Ethereum smart contracts are very powerful and flexible, but also extremely hard to get right.
      Their context is the whole state of the blockchain, which makes it difficult to predict what will happen when they get executed.
      This has led to several infamous exploits and bugs in the past, resulting in the unexpected loss of many millions
      of ether.

Cardano's EUTxO model with datums, redeemers and contexts is powerful and flexible enough to do whatever can be done
on Ethereum, but also simple enough to make it much easier to predict the effect of a given transaction.

Cardano transactions can be validated _locally_, without the need to submit them to the blockchain first,
because the context only contains the transaction itself and its inputs and outputs.
They can still fail when submitted, because some other transaction could have spent an expected input in the meantime,
but if all inputs are still unspent, the transaction will have the predicted effect.

As a consequence, Cardano transactions only incur a fee if they actually succeed and are included in the blockchain.
On Ethereum, transactions can fail and still cost gas. This can never happen on
Cardano (as long as a user does not go out of his way to circumvent all safety mechanisms).

This is an extremely important point and deserves further explanations:

On a blockchain like Ethereum, the outcome of a transaction can potentially be influenced by _anything_ happening on the blockchain. It is therefore impossible to determine the effect of a transaction offchain, before submitting it.

On a blockchain using the EUTxO model, the outcome of a transaction is determined by the transaction itself, its inputs and outputs, and nothing else. It therefore _is_ possible to determine the effect of a transaction offchain, before submitting it.

As noted above, the only thing that can possibly change on an EUTxO blockchain is the set of UTxO's, but the outputs themselves can never change. So it _is_ possible that a transaction has inputs that are consumed by other transactions before it is submitted, in which case it will fail (without incurring a fee). But if all inputs are still unspent, the transaction will have the predicted effect.

=== Atomic Swaps

Let's make this more concrete with an example: _Atomic swaps_.

We have mentioned _native tokens_ and NFT's before, and we will look at them in more detail later, but for now, let's just assume that they exist.

Let's say Alice is the owner of an NFT, and she is willing to sell it to Bob for 100 ADA.

She doesn't necessarily trust Bob, so she doesn't just want to send her NFT to Bob and hope he will pay her 100 ADA later.

Likewise, Bob doesn't trust Alice and doesn't want to send her 100 ADA, hoping she will send him the NFT afterwards.

This problem can actually be solved with the UTxO model, even withough smart contracts: Alice or Bob can craft a transaction with two inputs, Alice's NFT and Bob's 100 ADA and outputs 100 ADA for Alice and the NFT for Bob. Alice can _partially_ sign the transaction, then send it (offchain, for example by email) to Bob. Bob can then add his signature and submit the transaction to the blockchain.

Note that this is secure: Alice can't submit the transaction without Bob's signature, and Bob can't submit the transaction without Alice's signature. Furthermore, Bob can't manipulate the transaction to his advantage before signing, because Alice's signature would no longer be valid.

Such a transaction is an example of an _atomic swap_: The transactions swaps Alice's NFT and Bob's 100 ADA "atomically", without the need for trust. Either Alice receives her 100 ADA and Bob receives the NFT, or neither of them does.

.Alice and Bob perform an atomic swap in the UTxO model
image::atomic-swap-utxo.png[]

This approach has at least two problems: The partially signed transaction needs to be sent offchain, which is neither ideal nor very user friendly. And Alice "somehow" needs to find Bob and agree with him on the terms of the swap - again an offchain process.

Within the EUtxO model, this can be improved by using  a script to enforce the terms of the swap. Alice can craft a transaction that spends her NFT and creates an output locked by a script that requires _someone_ (maybe Bob, but Alice doesn't care) to send 100 ADA to Alice to unlock it.

So how does this work?

Alice will send her NFT to a _script address_ and put the price (100 ADA in our example) into the _datum_ of the output.

In order to unlock that UTxO and spend it, the script will check that the spending transaction contains an output of 100 ADA to Alice. Remember that the script can "see" the whole spending transaction (and nothing else), so in particular, it can see the outputs of the transaction and can therefore check whether one such output is 100 ADA to Alice.

(In practice, the script will probably also allow Alice to reclaim her NFT at any time - otherwise, she might have problems getting it back if nobody wants to buy it.)

Anybody will be able to spend this UTxO and get Alice's NFT, _provided_ they also send 100 ADA to Alice.

So in this example, Alice ceases control of her NFT by sending it to a script address, but she also ensures that she will get paid 100 ADA if somebody other than herself wants to spend that UTxO.

Note how in this example, the second transaction only needs to be signed by Bob (to authorize spending the 100 ADA belonging to him). Spending the NFT is authorized by running the script and not by anybody signing the transaction.

.Alice and Bob perform an atomic swap in the EUTxO model
image::atomic-swap-eutxo.png[]

We will see later that there is a problem with this smart contract, the so-called _double satisfaction_ problem, but rest assured that it can be solved within the EUTxO model.
